<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Spirograph Deluxe ‚Äî Wild Mode</title>
<style>
    /* ===== Base Layout (keeps your vibe) ===== */
    *{margin:0;padding:0;box-sizing:border-box}
    body{
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        background: radial-gradient(1200px 600px at 60% 40%, #101030 0%, #0b0b1d 45%, #050510 100%);
        color:#fff; overflow:hidden; height:100vh;
    }
    .container{display:flex; height:100vh}
    .controls{
        width:330px; min-width:300px; background:rgba(0,0,0,.75);
        padding:18px; border-right:1px solid #233; overflow-y:auto; backdrop-filter: blur(10px);
    }
    .canvas-container{flex:1; position:relative; display:flex; align-items:center; justify-content:center;}
    canvas{
        border:2px solid #233; border-radius:12px; background:#000;
        box-shadow: 0 0 35px rgba(0,255,255,.25);
        width:min(1100px, 92vw - 360px); height:min(78vh, 820px);
        max-width:92vw; max-height:82vh;
        aspect-ratio: 4/3;
    }
    .status{
        position:absolute; top:16px; left:16px; background:rgba(0,0,0,.8);
        padding:10px 12px; border-radius:8px; font-size:12px; border:1px solid #0ff; z-index:10;
    }

    /* ===== Panels ===== */
    h2{
        text-align:center; margin-bottom:14px; color:#0ff; letter-spacing:1px;
        text-shadow:0 0 10px rgba(0,255,255,.5);
    }
    .control-group{
        margin-bottom:16px; padding:12px; background:rgba(255,255,255,.05);
        border:1px solid rgba(255,255,255,.15); border-radius:10px;
    }
    .control-group h3{
        margin-bottom:10px; color:#00ffff; font-size:14px;
        text-shadow:0 0 8px rgba(0,255,255,.4);
    }
    .control-group h4{margin:8px 0 6px; color:#66f0ff; font-size:13px;}
    label{display:block; margin:6px 0 4px; font-size:12px; color:#cfd8dc}
    .inline{display:flex; gap:8px; align-items:center}
    .two-col{display:grid; grid-template-columns:1fr 1fr; gap:8px}
    .value{font-size:11px; color:#0ff; text-align:right}
    input, select, button{
        width:100%; padding:8px; border:1px solid #445; border-radius:6px;
        background:rgba(255,255,255,.08); color:#fff; font-size:12px;
    }
    input[type="range"]{accent-color:#08a6ff; background:transparent}
    input[type="color"]{height:38px; padding:0; border:none; cursor:pointer; background:#111; border:1px solid #345}
    button{
        background:linear-gradient(45deg,#00ffff,#0a7cff); border:none; color:#001018;
        font-weight:700; cursor:pointer; transition:.2s; text-transform:uppercase; letter-spacing:.6px;
    }
    button:hover{transform: translateY(-1px); box-shadow:0 5px 14px rgba(0,255,255,.25)}
    .btn-secondary{background:linear-gradient(45deg,#ff9a44,#fc6076)}
    .btn-ghost{background:transparent; border:1px solid #336; color:#cde}
    .gear-mode{display:flex; gap:8px; margin-bottom:8px}
    .gear-mode button{flex:1; padding:8px 6px; font-size:11px}
    .gear-mode .active{background:linear-gradient(45deg,#ff6b6b,#ee5a52); color:#111}

    .mathematical-info{
        font-size:10px; color:#9bb; margin-top:10px; padding:10px;
        background:rgba(0,0,0,.35); border-radius:8px; border-left:3px solid #0ff
    }

    .small{font-size:11px; opacity:.8}
    .kbd{
        display:inline-grid; place-items:center; min-width:20px; padding:2px 6px;
        border-radius:4px; border:1px solid #456; background:#0a0f18; font-weight:700; font-size:11px
    }

    /* Help overlay */
    .help{
        position:absolute; right:16px; top:16px; z-index:12;
        background:rgba(0,0,0,.9); border:1px solid #345; padding:10px 12px; border-radius:10px;
        font-size:12px; display:none; width:280px
    }
    .help ul{margin-left:14px}
    .tag{display:inline-block; font-size:10px; padding:2px 6px; border:1px solid #345; border-radius:999px; opacity:.8}

    .row{display:flex; gap:8px}
    .row > *{flex:1}

    .chip{display:inline-block; font-size:10px; padding:3px 8px; border-radius:999px; border:1px solid #345; margin-right:6px}
    .muted{opacity:.65}

    .hr{height:1px; background:linear-gradient(90deg,rgba(0,0,0,0), #2b5566, rgba(0,0,0,0)); margin:10px 0}

    /* Responsive tweak */
    @media (max-width:1050px){
        .controls{width:44vw}
        canvas{width:56vw; height:auto}
    }
    @media (max-width:820px){
        body{overflow:auto}
        .container{flex-direction:column}
        .controls{width:100vw; height:auto; max-height:55vh}
        .canvas-container{height:calc(100vh - 55vh)}
        canvas{width:92vw; height:auto}
    }
</style>
</head>
<body>
<div class="container">
    <div class="controls">
        <h2>SPIROGRAPH DELUXE</h2>

        <!-- Gear Configuration -->
        <div class="control-group">
            <h3>Gear Configuration</h3>
            <div class="gear-mode">
                <button id="internal-mode" class="active">INTERNAL</button>
                <button id="external-mode">EXTERNAL</button>
            </div>

            <h4>Fixed Gear</h4>
            <label>Shape</label>
            <select id="fixed-gear-shape">
                <option value="circle" selected>Circle</option>
                <option value="ellipse">Ellipse</option>
                <option value="lobed">Lobed Gear</option>
            </select>
            <div class="two-col">
                <div><label id="fixed-size1-label">Radius (R)</label><input type="range" id="fixed-size1" min="50" max="250" value="150"></div>
                <div><label class="value" id="fixed-size1-value">150</label></div>
            </div>
            <div id="fixed-2-wrap" style="display:none" class="two-col">
                <div><label id="fixed-size2-label">Semi-Minor (B)</label><input type="range" id="fixed-size2" min="10" max="250" value="100"></div>
                <div><label class="value" id="fixed-size2-value">100</label></div>
            </div>
            <div id="fixed-3-wrap" style="display:none" class="two-col">
                <div><label id="fixed-size3-label">Lobes (N)</label><input type="range" id="fixed-size3" min="2" max="10" step="1" value="3"></div>
                <div><label class="value" id="fixed-size3-value">3</label></div>
            </div>

            <h4>Moving Gear</h4>
            <label>Shape</label>
            <select id="moving-gear-shape">
                <option value="circle" selected>Circle</option>
                <option value="ellipse">Ellipse</option>
                <option value="lobed">Lobed Gear</option>
            </select>
            <div class="two-col">
                <div><label id="moving-size1-label">Radius (r)</label><input type="range" id="moving-size1" min="10" max="150" value="50"></div>
                <div><label class="value" id="moving-size1-value">50</label></div>
            </div>
            <div id="moving-2-wrap" style="display:none" class="two-col">
                <div><label id="moving-size2-label">Semi-Minor (b)</label><input type="range" id="moving-size2" min="5" max="150" value="30"></div>
                <div><label class="value" id="moving-size2-value">30</label></div>
            </div>
            <div id="moving-3-wrap" style="display:none" class="two-col">
                <div><label id="moving-size3-label">Lobes (n)</label><input type="range" id="moving-size3" min="2" max="10" step="1" value="3"></div>
                <div><label class="value" id="moving-size3-value">3</label></div>
            </div>

            <div class="two-col">
                <div><label>Pen Distance</label><input type="range" id="pen-distance" min="1" max="150" value="30"></div>
                <div><label class="value" id="pen-distance-value">30</label></div>
            </div>
        </div>

        <!-- Animation -->
        <div class="control-group">
            <h3>Animation</h3>
            <div class="row">
                <button id="play-pause">‚ñ∂Ô∏è PLAY</button>
                <button id="reset">üîÑ RESET</button>
                <button class="btn-secondary" id="randomize">üé≤ RANDOM</button>
            </div>
            <div class="two-col" style="margin-top:6px">
                <div><label>Speed</label><input type="range" id="speed" min="0.1" max="100" step="0.1" value="1"></div>
                <div><label class="value" id="speed-value">1.0x</label></div>
            </div>
        </div>

        <!-- Drawing -->
        <div class="control-group">
            <h3>Drawing</h3>
            <div class="two-col">
                <div><label>Line Width</label><input type="range" id="line-width" min="0.5" max="5" step="0.5" value="2"></div>
                <div><label class="value" id="line-width-value">2px</label></div>
            </div>
            <div class="two-col">
                <div>
                    <label>Color Mode</label>
                    <select id="color-mode">
                        <option value="solid" selected>Solid</option>
                        <option value="rainbow">Rainbow</option>
                        <option value="palette">Palette</option>
                    </select>
                </div>
                <div id="solid-color-wrap"><label>Pen Color</label><input type="color" id="pen-color" value="#00ffff"></div>
            </div>
            <div id="palette-wrap" class="two-col" style="display:none">
                <div>
                    <label>Palette</label>
                    <select id="palette-select"></select>
                </div>
                <div>
                    <label>Color Speed</label>
                    <input type="range" id="color-speed" min="0" max="2" step="0.01" value="0.35">
                </div>
            </div>
            <div id="rainbow-wrap" class="two-col" style="display:none">
                <div><label>Hue Speed</label><input type="range" id="rainbow-speed" min="0" max="5" step="0.05" value="0.8"></div>
                <div><label class="value"><span id="rainbow-speed-value">0.80</span>x</label></div>
            </div>

            <div class="hr"></div>
            <label class="inline"><input type="checkbox" id="show-gears" checked style="width:auto;margin-right:8px">Show Gears</label>
            <label class="inline"><input type="checkbox" id="show-pen" checked style="width:auto;margin-right:8px">Show Pen</label>
            <div class="row" style="margin-top:8px">
                <button id="clear" class="btn-ghost">üóëÔ∏è CLEAR</button>
                <button id="save-png">üíæ PNG</button>
            </div>
        </div>

        <!-- Kaleidoscope & Multi-pen -->
        <div class="control-group">
            <h3>Symmetry + Multi-Pen</h3>
            <div class="two-col">
                <div><label>Segments</label><input type="range" id="kaleido-segments" min="1" max="16" step="1" value="1"></div>
                <div><label class="value" id="kaleido-segments-value">1</label></div>
            </div>
            <label class="inline"><input type="checkbox" id="kaleido-mirror" style="width:auto;margin-right:8px">Mirror</label>
            <div class="two-col" style="margin-top:6px">
                <div><label>Pen Count</label><input type="range" id="pen-count" min="1" max="12" value="1"></div>
                <div><label class="value" id="pen-count-value">1</label></div>
            </div>
            <div class="two-col">
                <div><label>Angular Spread (¬∞)</label><input type="range" id="pen-angle-spread" min="0" max="180" value="30"></div>
                <div><label class="value" id="pen-angle-spread-value">30¬∞</label></div>
            </div>
            <div class="two-col">
                <div><label>Radial Spread</label><input type="range" id="pen-radial-spread" min="-40" max="40" step="1" value="0"></div>
                <div><label class="value" id="pen-radial-spread-value">0</label></div>
            </div>
        </div>

        <!-- Post FX (kept from your original; compacted controls) -->
        <div class="control-group">
            <h3>Post-Processing FX</h3>
            <div class="chip">Glow</div>
            <label class="inline"><input type="checkbox" id="fx-glow" style="width:auto;margin-right:6px">Enable</label>
            <div class="two-col">
                <div><label>Color</label><input type="color" id="fx-glow-color" value="#00ffff"></div>
                <div><label>Amount</label><input type="range" id="fx-glow-amount" min="0" max="50" value="15"></div>
            </div>

            <div class="hr"></div>
            <div class="chip">Shadow</div>
            <label class="inline"><input type="checkbox" id="fx-shadow" style="width:auto;margin-right:6px">Enable</label>
            <div class="two-col">
                <div><label>Color</label><input type="color" id="fx-shadow-color" value="#000000"></div>
                <div><label>Blur</label><input type="range" id="fx-shadow-blur" min="0" max="30" value="5"></div>
            </div>
            <div class="two-col">
                <div><label>Offset X</label><input type="range" id="fx-shadow-x" min="-20" max="20" value="5"></div>
                <div><label>Offset Y</label><input type="range" id="fx-shadow-y" min="-20" max="20" value="5"></div>
            </div>

            <div class="hr"></div>
            <div class="chip">Blur</div>
            <label class="inline"><input type="checkbox" id="fx-blur" style="width:auto;margin-right:6px">Enable</label>
            <div><label>Amount</label><input type="range" id="fx-blur-amount" min="0" max="20" step="0.5" value="0"></div>

            <div class="hr"></div>
            <div class="chip">Tint</div>
            <label class="inline"><input type="checkbox" id="fx-tint" style="width:auto;margin-right:6px">Enable</label>
            <div class="two-col">
                <div><label>Color</label><input type="color" id="fx-tint-color" value="#ff0000"></div>
                <div><label>Alpha</label><input type="range" id="fx-tint-alpha" min="0" max="1" step="0.01" value="0.2"></div>
            </div>
            <label>Blend Mode</label>
            <select id="fx-tint-mode">
                <option value="source-atop">Source Atop</option>
                <option value="multiply">Multiply</option>
                <option value="screen">Screen</option>
                <option value="overlay">Overlay</option>
                <option value="color" selected>Color</option>
                <option value="lighter">Lighter</option>
            </select>

            <div class="hr"></div>
            <div class="chip">Scanlines</div>
            <label class="inline"><input type="checkbox" id="fx-scan" style="width:auto;margin-right:6px">Enable</label>
            <div class="two-col">
                <div><label>Color</label><input type="color" id="fx-scan-color" value="#000000"></div>
                <div><label>Alpha</label><input type="range" id="fx-scan-alpha" min="0" max="1" step="0.01" value="0.15"></div>
            </div>
            <div class="two-col">
                <div><label>Thickness</label><input type="range" id="fx-scan-thick" min="1" max="5" value="1"></div>
                <div><label>Spacing</label><input type="range" id="fx-scan-space" min="1" max="10" value="3"></div>
            </div>
        </div>

        <!-- Audio + Recording + Presets -->
        <div class="control-group">
            <h3>Audio + Capture + Presets</h3>
            <div class="two-col">
                <div>
                    <div class="chip">Audio Reactive</div>
                    <label class="inline"><input type="checkbox" id="audio-enable" style="width:auto;margin-right:6px">Enable</label>
                    <div class="two-col">
                        <div><label>Sensitivity</label><input type="range" id="audio-sens" min="0" max="2" step="0.01" value="0.7"></div>
                        <div><label class="small">maps speed/width/pen</label></div>
                    </div>
                    <div class="row">
                        <button id="audio-mic" class="btn-ghost">üéô Mic</button>
                        <label class="btn-ghost" style="display:grid;place-items:center;cursor:pointer">
                            üìÅ Audio
                            <input type="file" id="audio-file" accept="audio/*" style="display:none">
                        </label>
                    </div>
                </div>
                <div>
                    <div class="chip">Recorder</div>
                    <div class="row">
                        <button id="rec-start" class="btn-ghost">‚è∫ Start</button>
                        <button id="rec-stop" disabled>‚èπ Stop</button>
                    </div>
                    <div class="small muted" id="rec-status">Idle</div>
                </div>
            </div>
            <div class="hr"></div>
            <div class="two-col">
                <div>
                    <div class="chip">Presets</div>
                    <div class="row" style="margin-top:4px">
                        <input id="preset-name" placeholder="Preset name"/>
                        <button id="preset-save" class="btn-ghost">üíæ Save</button>
                    </div>
                    <div class="row" style="margin-top:6px">
                        <select id="preset-list"></select>
                        <button id="preset-load">üì• Load</button>
                        <button id="preset-delete" class="btn-ghost">üóë</button>
                    </div>
                </div>
                <div>
                    <div class="chip">Share</div>
                    <div class="row" style="margin-top:4px">
                        <button id="share-link" class="btn-ghost">üîó Copy Link</button>
                        <button id="apply-hash">‚Ü©Ô∏é Load from URL</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Math info -->
        <div class="mathematical-info">
            <h4 style="color:#0ff;margin-bottom:4px">Gear System Info</h4>
            <div id="math-display">Select gear shapes and parameters.</div>
        </div>
        <div class="small muted" style="margin-top:8px">
            Tip: press <span class="kbd">?</span> for shortcuts.
        </div>
    </div>

    <div class="canvas-container">
        <canvas id="spirograph-canvas"></canvas>
        <div class="status" id="status">Ready ‚Äî click canvas to start</div>
        <div class="help" id="help">
            <div style="margin-bottom:6px"><span class="tag">Keyboard</span></div>
            <ul>
                <li><span class="kbd">P</span> Play/Pause</li>
                <li><span class="kbd">D</span> Toggle Drawing</li>
                <li><span class="kbd">R</span> Randomize</li>
                <li><span class="kbd">S</span> Save PNG</li>
                <li><span class="kbd">G</span> Toggle Gears</li>
                <li><span class="kbd">K</span> Toggle Kaleidoscope (1 ‚ÜîÔ∏é last)</li>
                <li><span class="kbd">?</span> Help</li>
            </ul>
        </div>
    </div>
</div>

<script>
/* ===== Utilities ===== */
const TAU = Math.PI * 2;
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const lerp = (a, b, t) => a + (b - a) * t;
const hexToRgb = (hex)=>({r:parseInt(hex.slice(1,3),16), g:parseInt(hex.slice(3,5),16), b:parseInt(hex.slice(5,7),16)});
const rgbToHex = ({r,g,b})=>"#"+[r,g,b].map(v=>v.toString(16).padStart(2,"0")).join("");
function mixHex(a, b, t){
    const A = hexToRgb(a), B = hexToRgb(b);
    return rgbToHex({ r:Math.round(lerp(A.r,B.r,t)), g:Math.round(lerp(A.g,B.g,t)), b:Math.round(lerp(A.b,B.b,t)) });
}
function rotateAround(pt, cx, cy, ang){
    const dx=pt.x-cx, dy=pt.y-cy, c=Math.cos(ang), s=Math.sin(ang);
    return { x: cx + dx*c - dy*s, y: cy + dx*s + dy*c };
}
function mirrorVertical(pt, cx){ return { x: cx*2 - pt.x, y: pt.y }; }
function randomInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min }
function randomBool(){ return Math.random()<0.5 }
function randomHex(){ return '#'+Math.floor(Math.random()*0xFFFFFF).toString(16).padStart(6,'0') }
function copyToClipboard(text){ navigator.clipboard?.writeText(text).catch(()=>{}); }

/* ===== Palettes ===== */
const PALETTES = {
    NeonWave: ["#00FFFF","#00B0FF","#4C00FF","#FF00E6","#FF0066"],
    SunsetPop: ["#ff9a44","#ff6a00","#ff2a6d","#c04bf9","#00dbff"],
    Arctic: ["#c4fff9","#5ce1e6","#00bcd4","#0081a7","#00171f"],
    Citrus: ["#f8f32b","#f7b733","#fc4a1a","#ed5565","#c73a63"],
    Aurora: ["#00FFA3","#29F19C","#00D1FF","#9E00FF","#FF1CF7"],
    Vapor: ["#64f4ac","#50e3c2","#4bc0c8","#c779d0","#feac5e"],
};
const PALETTE_NAMES = Object.keys(PALETTES);

/* ===== Shapes (from your original, adapted) ===== */
class GearShape{ constructor(p={}){ this.params=p } getPoint(t){ throw "impl" } getDerivative(t){ throw "impl" }
    getTangentAngle(t){ const d=this.getDerivative(t); return Math.atan2(d.dy_dt, d.dx_dt) }
    getSpeed(t){ const d=this.getDerivative(t); return Math.sqrt(d.dx_dt**2 + d.dy_dt**2) }
    draw(c, cen, rot){ const N=100; c.beginPath();
        for(let i=0;i<=N;i++){ const t=(i/N)*TAU; const p=this.getPoint(t);
            const x=p.x*Math.cos(rot)-p.y*Math.sin(rot)+cen.x;
            const y=p.x*Math.sin(rot)+p.y*Math.cos(rot)+cen.y;
            if(i===0) c.moveTo(x,y); else c.lineTo(x,y);
        } c.closePath(); c.stroke();
    }
}
class CircleGear extends GearShape{ constructor(r){ super({radius:r}); if(r<=0) throw Error("rad>0")}
    getPoint(t){ return {x:this.params.radius*Math.cos(t), y:this.params.radius*Math.sin(t)} }
    getDerivative(t){ return {dx_dt:-this.params.radius*Math.sin(t), dy_dt:this.params.radius*Math.cos(t)} }
    getSpeed(){ return this.params.radius }
    draw(c,cen){ c.beginPath(); c.arc(cen.x,cen.y,this.params.radius,0,TAU); c.stroke() }
}
class EllipseGear extends GearShape{ constructor(a,b){ super({a,b}); if(a<=0||b<=0) throw Error("axes>0")}
    getPoint(t){ return {x:this.params.a*Math.cos(t), y:this.params.b*Math.sin(t)} }
    getDerivative(t){ return {dx_dt:-this.params.a*Math.sin(t), dy_dt:this.params.b*Math.cos(t)} }
}
class LobedGear extends GearShape{ constructor(bR,lA,nL){ super({baseRadius:bR,lobeAmplitude:lA,numLobes:nL}); if(bR<=0||nL<1) throw Error("Lobed invalid")}
    getPoint(t){ const {baseRadius:R,lobeAmplitude:A,numLobes:N}=this.params; const r=R+A*Math.cos(N*t);
        return {x:r*Math.cos(t), y:r*Math.sin(t)}
    }
    getDerivative(t){ const {baseRadius:R,lobeAmplitude:A,numLobes:N}=this.params; const dr=-N*A*Math.sin(N*t);
        const r=R+A*Math.cos(N*t);
        return {dx_dt:dr*Math.cos(t)-r*Math.sin(t), dy_dt:dr*Math.sin(t)+r*Math.cos(t)}
    }
}

/* ===== App State ===== */
const app = {
    canvas:null, ctx:null, animationId:null,
    isAnimating:false, isDrawing:false,

    // gears
    fixedGear:null, movingGear:null,
    fixedGearShapeType:'circle', fixedGearSize1:150, fixedGearSize2:100, fixedGearSize3:3,
    movingGearShapeType:'circle', movingGearSize1:50, movingGearSize2:30, movingGearSize3:3,
    penDistance:30, gearMode:'internal',

    // time
    t_fixed:0, t_moving:0,

    // kinematics
    centerX:0, centerY:0,
    currentMovingGearCenter:{x:0,y:0}, currentMovingGearOrientation:0,

    // drawing
    speed:1, baseSpeed:1,
    penColor:'#00ffff', lineWidth:2, baseLineWidth:2, showGears:true, showPen:true,
    pattern:[], segmentCounter:0,

    // color engine
    colorMode:'solid',
    paletteName: PALETTE_NAMES[0],
    colorSpeed:0.35,
    rainbowSpeed:0.8,

    // multi-pen
    penCount:1, penAngleSpread:30, penRadialSpread:0,
    lastPenPositions:[],

    // kaleidoscope
    kaleidoSegments:1, kaleidoMirror:false,

    // FX
    effects:{
        glow:false, glowColor:'#00ffff', glowAmount:15,
        shadow:false, shadowColor:'#000000', shadowBlur:5, shadowX:5, shadowY:5,
        blur:false, blurAmount:0,
        tint:false, tintColor:'#ff0000', tintAlpha:.2, tintMode:'color',
        scan:false, scanColor:'#000000', scanAlpha:.15, scanThick:1, scanSpace:3
    },
    offscreenCanvas:null, offscreenContext:null,

    // audio
    audioEnabled:false, audioCtx:null, analyser:null, audioSourceNode:null, audioData:null, audioSens:0.7, audioEl:null,

    // recorder
    rec: { mr:null, chunks:[], active:false },

    // status
    statusEl:null, mathEl:null
};

/* ===== Init ===== */
window.addEventListener('load', () => {
    app.canvas = document.getElementById('spirograph-canvas');
    app.ctx = app.canvas.getContext('2d');
    app.statusEl = document.getElementById('status');
    app.mathEl = document.getElementById('math-display');
    sizeCanvas();
    bindUI();
    createGears();
    updateKinematics();
    draw(); // first paint
    // Load palettes
    const sel = document.getElementById('palette-select');
    PALETTE_NAMES.forEach(n => { const o=document.createElement('option'); o.value=n; o.textContent=n; sel.appendChild(o); });
    refreshMath();
    loadPresetsToList();
    // Load from URL if present
    if(location.hash.length>2) applyHashState();
});

function sizeCanvas(){
    const rect = app.canvas.getBoundingClientRect();
    const cssW = rect.width || 800, cssH = rect.height || 600;
    const dpr = window.devicePixelRatio || 1;
    app.canvas.width = Math.round(cssW * dpr);
    app.canvas.height= Math.round(cssH * dpr);
    app.canvas.style.width = cssW+'px';
    app.canvas.style.height= cssH+'px';
    app.centerX = cssW/2; app.centerY = cssH/2;
    app.ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', () => { sizeCanvas(); draw(); });

/* ===== UI & Events ===== */
function $(id){ return document.getElementById(id) }
function bindUI(){
    // gear mode
    $('internal-mode').onclick = () => setGearMode('internal');
    $('external-mode').onclick = () => setGearMode('external');

    // shapes
    $('fixed-gear-shape').onchange = ()=> updateGearShapeUI('fixed');
    $('moving-gear-shape').onchange = ()=> updateGearShapeUI('moving');
    ['fixed','moving'].forEach(p=>{
        ['size1','size2','size3'].forEach(x=>{
            $(p+'-'+x).oninput = updateGearConfig;
        });
    });
    $('pen-distance').oninput = ()=> { app.penDistance=parseFloat($('pen-distance').value); $('pen-distance-value').textContent=app.penDistance; if(!app.isAnimating) draw(); refreshMath(); };

    // animation
    $('play-pause').onclick = toggleAnimation;
    $('reset').onclick = resetAll;
    $('randomize').onclick = randomizeAll;
    $('speed').oninput = ()=> { app.baseSpeed = parseFloat($('speed').value); $('speed-value').textContent=app.baseSpeed.toFixed(1)+'x'; if(!app.isAnimating) draw(); };

    // drawing
    $('line-width').oninput = ()=> { app.baseLineWidth = parseFloat($('line-width').value); $('line-width-value').textContent=app.baseLineWidth+'px'; if(!app.isAnimating) draw(); };
    $('color-mode').onchange = onColorModeChange;
    $('pen-color').oninput = ()=> app.penColor = $('pen-color').value;
    $('palette-select').onchange = ()=> app.paletteName = $('palette-select').value;
    $('color-speed').oninput = ()=> app.colorSpeed = parseFloat($('color-speed').value);
    $('rainbow-speed').oninput = ()=> { app.rainbowSpeed = parseFloat($('rainbow-speed').value); $('rainbow-speed-value').textContent = app.rainbowSpeed.toFixed(2); };

    $('clear').onclick = ()=>{ app.pattern=[]; app.segmentCounter=0; if(!app.isAnimating) draw(); updateStatus(); };
    $('save-png').onclick = savePNG;

    // kaleido & multi-pen
    $('kaleido-segments').oninput = ()=> { app.kaleidoSegments = parseInt($('kaleido-segments').value); $('kaleido-segments-value').textContent=app.kaleidoSegments; if(!app.isAnimating) draw(); };
    $('kaleido-mirror').onchange = ()=> { app.kaleidoMirror = $('kaleido-mirror').checked; if(!app.isAnimating) draw(); };
    $('pen-count').oninput = ()=> { app.penCount=parseInt($('pen-count').value); $('pen-count-value').textContent=app.penCount; app.lastPenPositions.length=0; };
    $('pen-angle-spread').oninput = ()=> { app.penAngleSpread=parseFloat($('pen-angle-spread').value); $('pen-angle-spread-value').textContent=app.penAngleSpread+'¬∞'; };
    $('pen-radial-spread').oninput = ()=> { app.penRadialSpread=parseFloat($('pen-radial-spread').value); $('pen-radial-spread-value').textContent=app.penRadialSpread; };

    // FX
    $('fx-glow').onchange = ()=> app.effects.glow = $('fx-glow').checked;
    $('fx-glow-color').oninput = ()=> app.effects.glowColor = $('fx-glow-color').value;
    $('fx-glow-amount').oninput = ()=> app.effects.glowAmount = parseFloat($('fx-glow-amount').value);

    $('fx-shadow').onchange = ()=> app.effects.shadow = $('fx-shadow').checked;
    $('fx-shadow-color').oninput = ()=> app.effects.shadowColor = $('fx-shadow-color').value;
    $('fx-shadow-blur').oninput = ()=> app.effects.shadowBlur = parseFloat($('fx-shadow-blur').value);
    $('fx-shadow-x').oninput = ()=> app.effects.shadowX = parseFloat($('fx-shadow-x').value);
    $('fx-shadow-y').oninput = ()=> app.effects.shadowY = parseFloat($('fx-shadow-y').value);

    $('fx-blur').onchange = ()=> app.effects.blur = $('fx-blur').checked;
    $('fx-blur-amount').oninput = ()=> app.effects.blurAmount = parseFloat($('fx-blur-amount').value);

    $('fx-tint').onchange = ()=> app.effects.tint = $('fx-tint').checked;
    $('fx-tint-color').oninput = ()=> app.effects.tintColor = $('fx-tint-color').value;
    $('fx-tint-alpha').oninput = ()=> app.effects.tintAlpha = parseFloat($('fx-tint-alpha').value);
    $('fx-tint-mode').onchange = ()=> app.effects.tintMode = $('fx-tint-mode').value;

    $('fx-scan').onchange = ()=> app.effects.scan = $('fx-scan').checked;
    $('fx-scan-color').oninput = ()=> app.effects.scanColor = $('fx-scan-color').value;
    $('fx-scan-alpha').oninput = ()=> app.effects.scanAlpha = parseFloat($('fx-scan-alpha').value);
    $('fx-scan-thick').oninput = ()=> app.effects.scanThick = parseFloat($('fx-scan-thick').value);
    $('fx-scan-space').oninput = ()=> app.effects.scanSpace = parseFloat($('fx-scan-space').value);

    // audio
    $('audio-enable').onchange = ()=> app.audioEnabled = $('audio-enable').checked;
    $('audio-sens').oninput = ()=> app.audioSens = parseFloat($('audio-sens').value);
    $('audio-mic').onclick = enableMic;
    $('audio-file').onchange = handleAudioFile;

    // recorder
    $('rec-start').onclick = startRecording;
    $('rec-stop').onclick = stopRecording;

    // presets & share
    $('preset-save').onclick = savePreset;
    $('preset-load').onclick = loadPreset;
    $('preset-delete').onclick = deletePreset;
    $('share-link').onclick = copyShareLink;
    $('apply-hash').onclick = applyHashState;

    // canvas events
    app.canvas.addEventListener('click', toggleDrawing);

    // keys
    window.addEventListener('keydown', onKey);
}
function onKey(e){
    const k = e.key.toLowerCase();
    if(k==='?'){ toggleHelp(); }
    else if(k==='p'){ toggleAnimation(); }
    else if(k==='d'){ toggleDrawing(); }
    else if(k==='r'){ randomizeAll(); }
    else if(k==='s'){ savePNG(); }
    else if(k==='g'){ app.showGears=!app.showGears; $('show-gears').checked=app.showGears; if(!app.isAnimating) draw(); }
    else if(k==='k'){ app.kaleidoSegments = app.kaleidoSegments===1?8:1; $('kaleido-segments').value=app.kaleidoSegments; $('kaleido-segments-value').textContent=app.kaleidoSegments; if(!app.isAnimating) draw(); }
}
function toggleHelp(){
    const el=$('help'); const v=getComputedStyle(el).display; el.style.display= v==='none' ? 'block':'none';
}

/* ===== Gear Config & Kinematics (kept logic, extended) ===== */
function updateGearShapeUI(prefix){
    const sel = $(prefix+'-gear-shape').value;
    const s1L = $(prefix+'-size1-label');
    const w2 = $(prefix+'-2-wrap'), w3=$(prefix+'-3-wrap');
    if(prefix==='fixed') app.fixedGearShapeType=sel; else app.movingGearShapeType=sel;
    // labels + visibility
    w2.style.display = 'none'; w3.style.display='none';
    if(sel==='circle'){ s1L.textContent = prefix==='fixed' ? 'Radius (R)' : 'Radius (r)'; }
    else if(sel==='ellipse'){
        s1L.textContent = prefix==='fixed' ? 'A' : 'a';
        w2.style.display = 'grid';
        $(prefix+'-size2-label').textContent = prefix==='fixed' ? 'B' : 'b';
    } else if(sel==='lobed'){
        s1L.textContent = prefix==='fixed' ? 'Rb' : 'rb';
        w2.style.display = 'grid'; w3.style.display='grid';
        $(prefix+'-size2-label').textContent = prefix==='fixed' ? 'Al' : 'al';
        $(prefix+'-size3-label').textContent = 'Lobes ('+(prefix==='fixed'?'N':'n')+')';
    }
    updateGearConfig();
}
function createGears(){
    const fg = {type:app.fixedGearShapeType, s1:app.fixedGearSize1, s2:app.fixedGearSize2, s3:app.fixedGearSize3};
    const mg = {type:app.movingGearShapeType, s1:app.movingGearSize1, s2:app.movingGearSize2, s3:app.movingGearSize3};
    try{
        app.fixedGear = fg.type==='circle' ? new CircleGear(fg.s1) :
                        fg.type==='ellipse' ? new EllipseGear(fg.s1, fg.s2) :
                        new LobedGear(fg.s1, fg.s2, fg.s3);
        app.movingGear = mg.type==='circle' ? new CircleGear(mg.s1) :
                        mg.type==='ellipse' ? new EllipseGear(mg.s1, mg.s2) :
                        new LobedGear(mg.s1, mg.s2, mg.s3);
    }catch(e){
        alert("Gear error: "+e.message+" ‚Äî resetting to defaults");
        app.fixedGearShapeType='circle'; app.fixedGearSize1=150;
        app.movingGearShapeType='circle'; app.movingGearSize1=50;
        $('fixed-gear-shape').value='circle'; $('moving-gear-shape').value='circle';
        updateGearShapeUI('fixed'); updateGearShapeUI('moving');
        app.fixedGear = new CircleGear(150); app.movingGear = new CircleGear(50);
    }
}
function updateGearConfig(){
    app.fixedGearShapeType = $('fixed-gear-shape').value;
    app.fixedGearSize1 = parseFloat($('fixed-size1').value);
    app.fixedGearSize2 = parseFloat($('fixed-size2').value);
    app.fixedGearSize3 = parseInt($('fixed-size3').value);

    app.movingGearShapeType = $('moving-gear-shape').value;
    app.movingGearSize1 = parseFloat($('moving-size1').value);
    app.movingGearSize2 = parseFloat($('moving-size2').value);
    app.movingGearSize3 = parseInt($('moving-size3').value);

    $('fixed-size1-value').textContent = app.fixedGearSize1;
    $('fixed-size2-value').textContent = app.fixedGearSize2;
    $('fixed-size3-value').textContent = app.fixedGearSize3;
    $('moving-size1-value').textContent = app.movingGearSize1;
    $('moving-size2-value').textContent = app.movingGearSize2;
    $('moving-size3-value').textContent = app.movingGearSize3;

    createGears();
    if(!app.isAnimating){ updateKinematics(); draw(); }
    refreshMath();
}
function setGearMode(mode){
    app.gearMode = mode;
    $('internal-mode').classList.toggle('active', mode==='internal');
    $('external-mode').classList.toggle('active', mode==='external');
    if(!app.isAnimating){ updateKinematics(); draw(); }
    refreshMath();
    updateStatus();
}
function updateKinematics(){
    if(!app.fixedGear||!app.movingGear) return;
    const t_f = app.t_fixed, t_m = app.t_moving;
    const PF = app.fixedGear.getPoint(t_f);
    const PFG = { x: app.centerX + PF.x, y: app.centerY + PF.y };
    const phiF = app.fixedGear.getTangentAngle(t_f);
    const PM = app.movingGear.getPoint(t_m);
    const phiM = app.movingGear.getTangentAngle(t_m);

    app.currentMovingGearOrientation = (app.gearMode==='internal') ? (phiF - phiM) : (phiF - phiM + Math.PI);

    // moving gear center = follow tangent constraint
    const c = Math.cos(app.currentMovingGearOrientation), s = Math.sin(app.currentMovingGearOrientation);
    const rot_dx = PM.x*c - PM.y*s, rot_dy = PM.x*s + PM.y*c;

    app.currentMovingGearCenter.x = PFG.x - rot_dx;
    app.currentMovingGearCenter.y = PFG.y - rot_dy;
}
function getPenPositions(){
    const cx = app.currentMovingGearCenter.x, cy = app.currentMovingGearCenter.y;
    const baseAng = app.currentMovingGearOrientation;
    const pcs = [];
    const mid = (app.penCount-1)/2;
    for(let i=0;i<app.penCount;i++){
        const offIndex = i - mid;
        const ang = baseAng + (app.penAngleSpread * Math.PI/180) * offIndex;
        const rad = app.penDistance + app.penRadialSpread * offIndex;
        pcs.push({ x: cx + rad * Math.cos(ang), y: cy + rad * Math.sin(ang) });
    }
    return pcs;
}

/* ===== Color Engine ===== */
function onColorModeChange(){
    app.colorMode = $('color-mode').value;
    $('solid-color-wrap').style.display = app.colorMode==='solid' ? 'block' : 'none';
    $('palette-wrap').style.display = app.colorMode==='palette' ? 'grid' : 'none';
    $('rainbow-wrap').style.display = app.colorMode==='rainbow' ? 'grid' : 'none';
}
function colorFromEngine(penIndex){
    if(app.colorMode==='solid') return app.penColor;
    if(app.colorMode==='rainbow'){
        const h = (app.segmentCounter * app.rainbowSpeed + penIndex*23) % 360;
        return `hsl(${h}, 100%, 60%)`;
    }
    // palette
    const arr = PALETTES[app.paletteName] || PALETTES[PALETTE_NAMES[0]];
    const prog = (app.segmentCounter*app.colorSpeed*0.01 + penIndex*0.07) % 1;
    // find segment in palette
    const seg = 1/(arr.length-1);
    const idx = Math.floor(prog / seg);
    const t = (prog - idx*seg)/seg;
    return mixHex(arr[idx], arr[idx+1] ?? arr[idx], t);
}

/* ===== Draw Loop ===== */
function draw(){
    const ctx = app.ctx; if(!ctx) return;

    // update time when animating
    if(app.isAnimating){
        const sF = app.fixedGear.getSpeed(app.t_fixed);
        const speedMultiplier = app.audioEnabled ? (1 + getAudioEnergy()*app.audioSens) : 1;
        const effSpeed = app.baseSpeed * speedMultiplier;
        app.speed = effSpeed;

        let dt_f = (Math.abs(sF)<1e-6) ? 0.001*effSpeed : (0.5*effSpeed)/sF;
        dt_f = clamp(dt_f, -0.35, 0.35);
        app.t_fixed += dt_f;

        const dSR = sF * dt_f;
        const sM = app.movingGear.getSpeed(app.t_moving);
        let b_dt_m = (Math.abs(sM)<1e-6) ? (Math.abs(dSR)>1e-7 ? 0.001*Math.sign(dSR) : 0) : dSR/sM;
        app.t_moving += ((app.gearMode==='internal')?1:-1) * b_dt_m;
    }

    updateKinematics();

    // collect new segments if drawing
    const frameSegments = [];
    if(app.isAnimating && app.isDrawing){
        const cur = getPenPositions();
        if(app.lastPenPositions.length !== cur.length){
            // initialize last positions on change
            app.lastPenPositions = cur.map(p => ({...p}));
        }
        for(let i=0;i<cur.length;i++){
            const from = app.lastPenPositions[i];
            const to = cur[i];
            const color = colorFromEngine(i);
            const width = app.baseLineWidth + (app.audioEnabled ? getAudioEnergy()*app.audioSens*2.0 : 0);
            const seg = { from:{...from}, to:{...to}, color, width };
            frameSegments.push(seg);
            app.pattern.push(seg);
            app.segmentCounter++;
            app.lastPenPositions[i] = {...to};
        }
    }else{
        // sync last positions with current single pen when not drawing (so first line is clean)
        app.lastPenPositions = getPenPositions().map(p=>({...p}));
    }

    // render
    const dpr = window.devicePixelRatio||1;
    const bW = ctx.canvas.width, bH = ctx.canvas.height;
    const cssW = app.centerX*2, cssH = app.centerY*2;

    // choose drawing context (offscreen for blur)
    let pCtx = ctx; let tmpCanvas = null;
    if(app.effects.blur && app.effects.blurAmount>0){
        if(!app.offscreenCanvas){ app.offscreenCanvas=document.createElement('canvas'); app.offscreenContext=app.offscreenCanvas.getContext('2d'); }
        app.offscreenCanvas.width = bW; app.offscreenCanvas.height=bH;
        app.offscreenContext.setTransform(dpr,0,0,dpr,0,0);
        pCtx = app.offscreenContext;
        tmpCanvas = app.offscreenCanvas;
    }

    // clear base
    pCtx.fillStyle = '#000';
    pCtx.fillRect(0,0,cssW,cssH);

    // shadow/glow
    pCtx.save();
    if(app.effects.glow && app.effects.glowAmount>0){
        pCtx.shadowOffsetX=0; pCtx.shadowOffsetY=0;
        pCtx.shadowBlur = app.effects.glowAmount;
        pCtx.shadowColor = app.effects.glowColor;
    }else if(app.effects.shadow){
        pCtx.shadowOffsetX=app.effects.shadowX;
        pCtx.shadowOffsetY=app.effects.shadowY;
        pCtx.shadowBlur = app.effects.shadowBlur;
        pCtx.shadowColor = app.effects.shadowColor;
    }

    // draw full pattern + this frame (pattern already includes frameSegments)
    drawPatternWithSymmetry(pCtx, app.pattern);
    pCtx.restore();

    // post: blur
    if(tmpCanvas){
        ctx.fillStyle='#000'; ctx.fillRect(0,0,cssW,cssH);
        ctx.save();
        ctx.filter = `blur(${app.effects.blurAmount}px)`;
        ctx.drawImage(tmpCanvas,0,0,cssW,cssH);
        ctx.restore();
    }

    // tint
    if(app.effects.tint){
        ctx.save();
        ctx.globalCompositeOperation = app.effects.tintMode;
        ctx.fillStyle = `rgba(${hexToRgb(app.effects.tintColor).r},${hexToRgb(app.effects.tintColor).g},${hexToRgb(app.effects.tintColor).b},${app.effects.tintAlpha})`;
        ctx.fillRect(0,0,cssW,cssH);
        ctx.restore();
    }
    // scanlines
    if(app.effects.scan){
        drawScanLines(ctx, cssW, cssH, app.effects.scanColor, app.effects.scanAlpha, app.effects.scanThick, app.effects.scanSpace);
    }

    // overlay gears & pen
    if(app.showGears) drawGears();
    if(app.showPen) drawPenMarker();

    if(app.isAnimating) app.animationId = requestAnimationFrame(draw);
}
function drawPatternWithSymmetry(ctx, pattern){
    const segs = app.kaleidoSegments;
    if(segs<=1 && !app.kaleidoMirror){
        drawSegments(ctx, pattern);
        return;
    }
    // For each original segment, draw rotated copies (and mirrored if enabled)
    for(const s of pattern){
        for(let k=0;k<segs;k++){
            const ang = k * TAU / segs;
            const f = rotateAround(s.from, app.centerX, app.centerY, ang);
            const t = rotateAround(s.to,   app.centerX, app.centerY, ang);
            drawSegment(ctx, f, t, s.color, s.width);

            if(app.kaleidoMirror){
                const fm = mirrorVertical(f, app.centerX);
                const tm = mirrorVertical(t, app.centerX);
                drawSegment(ctx, fm, tm, s.color, s.width);
            }
        }
    }
}
function drawSegments(ctx, list){
    for(const s of list) drawSegment(ctx, s.from, s.to, s.color, s.width);
}
function drawSegment(ctx, from, to, color, width){
    ctx.strokeStyle = color; ctx.lineWidth = width; ctx.lineCap='round'; ctx.lineJoin='round';
    ctx.beginPath(); ctx.moveTo(from.x, from.y); ctx.lineTo(to.x, to.y); ctx.stroke();
}
function drawGears(){
    const ctx = app.ctx;
    ctx.save();
    ctx.strokeStyle='rgba(255,255,255,0.33)'; ctx.lineWidth=1.5;
    app.fixedGear.draw(ctx, {x:app.centerX, y:app.centerY}, 0);
    ctx.strokeStyle='rgba(0,255,255,0.6)';
    app.movingGear.draw(ctx, app.currentMovingGearCenter, app.currentMovingGearOrientation);
    // centers
    ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.beginPath(); ctx.arc(app.centerX,app.centerY,2,0,TAU); ctx.fill();
    ctx.fillStyle='rgba(0,255,255,0.9)'; ctx.beginPath(); ctx.arc(app.currentMovingGearCenter.x,app.currentMovingGearCenter.y,2,0,TAU); ctx.fill();
    ctx.restore();
}
function drawPenMarker(){
    const ctx = app.ctx;
    const pens = getPenPositions();
    ctx.save();
    for(const p of pens){
        ctx.fillStyle = app.penColor;
        ctx.beginPath(); ctx.arc(p.x, p.y, Math.max(2, app.baseLineWidth/(window.devicePixelRatio||1)), 0, TAU); ctx.fill();
        ctx.strokeStyle='rgba(255,255,0,0.6)'; ctx.lineWidth=1; ctx.setLineDash([2,2]);
        ctx.beginPath(); ctx.moveTo(app.currentMovingGearCenter.x, app.currentMovingGearCenter.y); ctx.lineTo(p.x, p.y); ctx.stroke();
    }
    ctx.setLineDash([]);
    ctx.restore();
}
function drawScanLines(ctx, w, h, color, alpha, thick, space){
    const {r,g,b} = hexToRgb(color);
    ctx.save();
    ctx.strokeStyle = `rgba(${r},${g},${b},${alpha})`;
    ctx.lineWidth = thick;
    for(let y=0; y<h; y += thick + space){
        ctx.beginPath(); ctx.moveTo(0, y + thick/2); ctx.lineTo(w, y + thick/2); ctx.stroke();
    }
    ctx.restore();
}

/* ===== Controls: Animation / Drawing / Status ===== */
function toggleAnimation(){
    app.isAnimating = !app.isAnimating;
    const b = $('play-pause');
    if(app.isAnimating){
        b.textContent='‚è∏Ô∏è PAUSE'; b.classList.add('btn-secondary');
        updateKinematics(); draw();
    }else{
        b.textContent='‚ñ∂Ô∏è PLAY'; b.classList.remove('btn-secondary');
        if(app.animationId){ cancelAnimationFrame(app.animationId); app.animationId=null; }
    }
    updateStatus();
}
function toggleDrawing(){
    if(!app.isAnimating && !app.isDrawing) toggleAnimation();
    app.isDrawing = !app.isDrawing;
    if(app.isDrawing){
        app.lastPenPositions = getPenPositions().map(p=>({...p}));
    }
    updateStatus();
}
function resetAll(){
    app.t_fixed=0; app.t_moving=0; app.segmentCounter=0;
    app.isDrawing=false; if(app.isAnimating) toggleAnimation();
    app.pattern=[]; app.lastPenPositions=[];
    updateKinematics(); draw(); updateStatus();
}
function updateStatus(){
    const s = app.statusEl;
    if(app.isDrawing){ s.textContent='Drawing ‚Äî click canvas or press D to pause drawing'; s.style.borderColor='#0f0'; }
    else if(app.isAnimating){ s.textContent='Animating ‚Äî click canvas to start drawing'; s.style.borderColor='#ff0'; }
    else{ s.textContent='Paused ‚Äî click canvas or press P to play'; s.style.borderColor='#0ff'; }
}
function refreshMath(){
    const desc = (type,s1,s2,s3,pfx)=> {
        let d = type.toUpperCase()+" (";
        if(type==='circle') d += `${pfx.R}=${s1}`;
        else if(type==='ellipse') d += `${pfx.A}=${s1}, ${pfx.B}=${s2}`;
        else d += `${pfx.Rb}=${s1}, ${pfx.Al}=${s2}, ${pfx.N}=${s3}`;
        return d+")";
    };
    app.mathEl.innerHTML = `Mode: ${app.gearMode.toUpperCase()}<br>
        Fixed: ${desc(app.fixedGearShapeType,app.fixedGearSize1,app.fixedGearSize2,app.fixedGearSize3,{R:'R',A:'A',B:'B',Rb:'Rb',Al:'Al',N:'N'})}<br>
        Moving: ${desc(app.movingGearShapeType,app.movingGearSize1,app.movingGearSize2,app.movingGearSize3,{R:'r',A:'a',B:'b',Rb:'rb',Al:'al',N:'n'})}<br>
        Pen Dist: ${app.penDistance}`;
}

/* ===== Save PNG ===== */
function savePNG(){
    // render to a clean temp canvas with FX applied
    const dpr = window.devicePixelRatio||1;
    const cssW = app.centerX*2, cssH=app.centerY*2;
    const t = document.createElement('canvas'); const tc = t.getContext('2d');
    t.width = cssW*dpr; t.height = cssH*dpr; tc.setTransform(dpr,0,0,dpr,0,0);

    // prepare stage similar to draw()
    let pCtx = tc, tmp=null;
    if(app.effects.blur && app.effects.blurAmount>0){
        tmp = document.createElement('canvas'); tmp.width=t.width; tmp.height=t.height;
        const tc2 = tmp.getContext('2d'); tc2.setTransform(dpr,0,0,dpr,0,0);
        pCtx = tc2;
    }
    pCtx.fillStyle='#000'; pCtx.fillRect(0,0,cssW,cssH);
    pCtx.save();
    if(app.effects.glow){ pCtx.shadowOffsetX=0; pCtx.shadowOffsetY=0; pCtx.shadowBlur=app.effects.glowAmount; pCtx.shadowColor=app.effects.glowColor; }
    else if(app.effects.shadow){ pCtx.shadowOffsetX=app.effects.shadowX; pCtx.shadowOffsetY=app.effects.shadowY; pCtx.shadowBlur=app.effects.shadowBlur; pCtx.shadowColor=app.effects.shadowColor; }
    drawPatternWithSymmetry(pCtx, app.pattern);
    pCtx.restore();
    if(tmp){
        tc.fillStyle='#000'; tc.fillRect(0,0,cssW,cssH);
        tc.save(); tc.filter = `blur(${app.effects.blurAmount}px)`; tc.drawImage(tmp,0,0,cssW,cssH); tc.restore();
    }
    if(app.effects.tint){ tc.save(); tc.globalCompositeOperation=app.effects.tintMode; const {r,g,b}=hexToRgb(app.effects.tintColor);
        tc.fillStyle=`rgba(${r},${g},${b},${app.effects.tintAlpha})`; tc.fillRect(0,0,cssW,cssH); tc.restore(); }
    if(app.effects.scan){ drawScanLines(tc, cssW, cssH, app.effects.scanColor, app.effects.scanAlpha, app.effects.scanThick, app.effects.scanSpace); }

    const a = document.createElement('a');
    a.download = `spiro-deluxe-${Date.now()}.png`;
    a.href = t.toDataURL('image/png'); a.click();
}

/* ===== Randomize ===== */
function randomizeAll(){
    resetAll();
    // gear mode
    setGearMode(randomBool()?'internal':'external');

    // shapes + params
    const pickShape = ()=> ['circle','ellipse','lobed'][randomInt(0,2)];
    $('fixed-gear-shape').value = pickShape(); updateGearShapeUI('fixed');
    $('moving-gear-shape').value = pickShape(); updateGearShapeUI('moving');

    $('fixed-size1').value = randomInt(70,240);
    $('moving-size1').value = randomInt(15,130);

    if(app.fixedGearShapeType!=='circle'){
        $('fixed-size2').value = randomInt(20,230);
        if(app.fixedGearShapeType==='lobed') $('fixed-size3').value = randomInt(2,9);
    }
    if(app.movingGearShapeType!=='circle'){
        $('moving-size2').value = randomInt(10,130);
        if(app.movingGearShapeType==='lobed') $('moving-size3').value = randomInt(2,9);
    }

    $('pen-distance').value = randomInt(8,140);
    $('speed').value = (Math.random()<0.3? randomInt(10,60)/10 : randomInt(1,25)/10);
    $('line-width').value = [0.5,1,1.5,2,2.5,3,3.5,4,4.5,5][randomInt(0,9)];

    // multi-pen + kaleido
    $('pen-count').value = randomInt(1,8);
    $('pen-angle-spread').value = randomInt(0,120);
    $('pen-radial-spread').value = randomInt(-20,20);
    $('kaleido-segments').value = randomInt(1,12);
    $('kaleido-mirror').checked = randomBool();

    // color engine
    $('color-mode').value = ['solid','rainbow','palette'][randomInt(0,2)]; onColorModeChange();
    if($('color-mode').value==='solid') $('pen-color').value = randomHex();
    if($('color-mode').value==='palette'){ $('palette-select').value = PALETTE_NAMES[randomInt(0,PALETTE_NAMES.length-1)]; $('color-speed').value = Math.random().toFixed(2); }
    if($('color-mode').value==='rainbow'){ $('rainbow-speed').value = (Math.random()*4+0.2).toFixed(2); $('rainbow-speed').dispatchEvent(new Event('input')); }

    // FX
    $('fx-glow').checked = randomBool(); $('fx-shadow').checked = !$('fx-glow').checked && randomBool();
    $('fx-blur').checked = randomBool() && Math.random()<0.5; $('fx-blur-amount').value = randomInt(0,12);
    $('fx-tint').checked = randomBool() && Math.random()<0.4; $('fx-tint-color').value = randomHex(); $('fx-tint-alpha').value = (Math.random()*0.4).toFixed(2);
    $('fx-scan').checked = Math.random()<0.2; // subtle

    // visuals toggles
    $('show-gears').checked = randomBool(); $('show-pen').checked = randomBool();

    // apply
    updateGearConfig();
    app.baseSpeed = parseFloat($('speed').value); $('speed-value').textContent=app.baseSpeed.toFixed(1)+'x';
    app.baseLineWidth = parseFloat($('line-width').value); $('line-width-value').textContent=app.baseLineWidth+'px';

    app.penCount=parseInt($('pen-count').value); $('pen-count-value').textContent=app.penCount;
    app.penAngleSpread=parseFloat($('pen-angle-spread').value); $('pen-angle-spread-value').textContent=app.penAngleSpread+'¬∞';
    app.penRadialSpread=parseFloat($('pen-radial-spread').value); $('pen-radial-spread-value').textContent=app.penRadialSpread;
    app.kaleidoSegments=parseInt($('kaleido-segments').value); $('kaleido-segments-value').textContent=app.kaleidoSegments;
    app.kaleidoMirror = $('kaleido-mirror').checked;

    app.penColor = $('pen-color').value;
    app.colorMode = $('color-mode').value;
    app.paletteName = $('palette-select').value;
    app.colorSpeed = parseFloat($('color-speed').value);
    app.rainbowSpeed = parseFloat($('rainbow-speed').value);

    // FX map
    app.effects.glow = $('fx-glow').checked; app.effects.glowColor=$('fx-glow-color').value; app.effects.glowAmount=parseFloat($('fx-glow-amount').value);
    app.effects.shadow=$('fx-shadow').checked; app.effects.shadowColor=$('fx-shadow-color').value; app.effects.shadowBlur=parseFloat($('fx-shadow-blur').value);
    app.effects.shadowX=parseFloat($('fx-shadow-x').value); app.effects.shadowY=parseFloat($('fx-shadow-y').value);
    app.effects.blur=$('fx-blur').checked; app.effects.blurAmount=parseFloat($('fx-blur-amount').value);
    app.effects.tint=$('fx-tint').checked; app.effects.tintColor=$('fx-tint-color').value; app.effects.tintAlpha=parseFloat($('fx-tint-alpha').value); app.effects.tintMode=$('fx-tint-mode').value;
    app.effects.scan=$('fx-scan').checked; app.effects.scanColor=$('fx-scan-color').value; app.effects.scanAlpha=parseFloat($('fx-scan-alpha').value); app.effects.scanThick=parseFloat($('fx-scan-thick').value); app.effects.scanSpace=parseFloat($('fx-scan-space').value);

    app.showGears = $('show-gears').checked; app.showPen = $('show-pen').checked;

    draw();
}

/* ===== Audio Reactive ===== */
async function ensureAudioCtx(){
    if(!app.audioCtx){
        const ctx = new (window.AudioContext||window.webkitAudioContext)();
        app.audioCtx = ctx;
        app.analyser = ctx.createAnalyser(); app.analyser.fftSize = 2048;
        app.audioData = new Uint8Array(app.analyser.frequencyBinCount);
    }
}
async function enableMic(){
    await ensureAudioCtx();
    const stream = await navigator.mediaDevices.getUserMedia({audio:true});
    if(app.audioSourceNode) app.audioSourceNode.disconnect();
    app.audioSourceNode = app.audioCtx.createMediaStreamSource(stream);
    app.audioSourceNode.connect(app.analyser);
    app.audioEnabled = true; $('audio-enable').checked = true;
}
function handleAudioFile(e){
    const file = e.target.files?.[0]; if(!file) return;
    if(!app.audioEl){ app.audioEl = new Audio(); app.audioEl.loop=true; }
    app.audioEl.src = URL.createObjectURL(file);
    app.audioEl.play();
    ensureAudioCtx().then(()=>{
        if(app.audioSourceNode) app.audioSourceNode.disconnect();
        const src = app.audioCtx.createMediaElementSource(app.audioEl);
        src.connect(app.analyser); app.analyser.connect(app.audioCtx.destination);
        app.audioSourceNode = src;
        app.audioEnabled = true; $('audio-enable').checked = true;
    });
}
function getAudioEnergy(){
    if(!app.audioEnabled || !app.analyser) return 0;
    app.analyser.getByteFrequencyData(app.audioData);
    // take upper-mids (visual pleasing)
    const len = app.audioData.length;
    const from = Math.floor(len*0.2), to = Math.floor(len*0.8);
    let sum=0; for(let i=from;i<to;i++) sum += app.audioData[i];
    const avg = sum / (to-from) / 255; // 0..1
    // also softly modulate pen distance
    app.penDistance = parseFloat($('pen-distance').value) * (1 + (avg-0.5) * app.audioSens * 0.2);
    return avg;
}

/* ===== Recorder (WebM) ===== */
function startRecording(){
    if(app.rec.active) return;
    const stream = app.canvas.captureStream(60);
    const mime = MediaRecorder.isTypeSupported('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9'
               : MediaRecorder.isTypeSupported('video/webm;codecs=vp8') ? 'video/webm;codecs=vp8'
               : 'video/webm';
    const mr = new MediaRecorder(stream, { mimeType: mime, videoBitsPerSecond: 8_000_000 });
    app.rec.chunks = [];
    mr.ondataavailable = e => { if(e.data?.size) app.rec.chunks.push(e.data) };
    mr.onstop = ()=> {
        const blob = new Blob(app.rec.chunks, {type:mime});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href=url; a.download=`spirograph-${Date.now()}.webm`; a.click();
        $('rec-status').textContent = 'Saved WebM';
    };
    mr.start();
    app.rec.mr = mr; app.rec.active = true;
    $('rec-start').disabled = true; $('rec-stop').disabled = false; $('rec-status').textContent = 'Recording‚Ä¶';
}
function stopRecording(){
    if(!app.rec.active) return;
    app.rec.mr.stop();
    app.rec.active = false;
    $('rec-start').disabled = false; $('rec-stop').disabled = true; $('rec-status').textContent = 'Finalizing‚Ä¶';
}

/* ===== Presets / Share ===== */
function currentState(){
    return {
        // gears
        fixed:{t:app.fixedGearShapeType, s1:app.fixedGearSize1, s2:app.fixedGearSize2, s3:app.fixedGearSize3},
        moving:{t:app.movingGearShapeType, s1:app.movingGearSize1, s2:app.movingGearSize2, s3:app.movingGearSize3},
        penDistance: parseFloat($('pen-distance').value), mode: app.gearMode,
        // draw & color
        baseSpeed: app.baseSpeed, baseLineWidth: app.baseLineWidth,
        color:{mode:app.colorMode, pen:app.penColor, palette:app.paletteName, cspd:app.colorSpeed, rs:app.rainbowSpeed},
        show:{gears:app.showGears, pen:app.showPen},
        // multi + kaleido
        multi:{count:app.penCount, ang:app.penAngleSpread, rad:app.penRadialSpread},
        kaleido:{seg:app.kaleidoSegments, mirror:app.kaleidoMirror},
        // fx
        fx:{...app.effects}
    };
}
function applyState(s){
    // gears
    $('fixed-gear-shape').value=s.fixed.t; $('moving-gear-shape').value=s.moving.t; updateGearShapeUI('fixed'); updateGearShapeUI('moving');
    $('fixed-size1').value=s.fixed.s1; $('fixed-size2').value=s.fixed.s2; $('fixed-size3').value=s.fixed.s3;
    $('moving-size1').value=s.moving.s1; $('moving-size2').value=s.moving.s2; $('moving-size3').value=s.moving.s3;
    $('pen-distance').value=s.penDistance;
    setGearMode(s.mode);
    updateGearConfig();

    // draw
    $('speed').value=s.baseSpeed; $('speed').dispatchEvent(new Event('input'));
    $('line-width').value=s.baseLineWidth; $('line-width').dispatchEvent(new Event('input'));

    $('color-mode').value=s.color.mode; onColorModeChange();
    $('pen-color').value=s.color.pen; app.penColor=s.color.pen;
    $('palette-select').value=s.color.palette; app.paletteName=s.color.palette;
    $('color-speed').value=s.color.cspd; app.colorSpeed=s.color.cspd;
    $('rainbow-speed').value=s.color.rs; $('rainbow-speed').dispatchEvent(new Event('input'));

    $('show-gears').checked=s.show.gears; app.showGears=s.show.gears;
    $('show-pen').checked=s.show.pen; app.showPen=s.show.pen;

    // multi + kaleido
    $('pen-count').value=s.multi.count; $('pen-count').dispatchEvent(new Event('input'));
    $('pen-angle-spread').value=s.multi.ang; $('pen-angle-spread').dispatchEvent(new Event('input'));
    $('pen-radial-spread').value=s.multi.rad; $('pen-radial-spread').dispatchEvent(new Event('input'));
    $('kaleido-segments').value=s.kaleido.seg; $('kaleido-segments').dispatchEvent(new Event('input'));
    $('kaleido-mirror').checked=s.kaleido.mirror; app.kaleidoMirror=s.kaleido.mirror;

    // fx
    Object.assign(app.effects, s.fx);
    $('fx-glow').checked=app.effects.glow; $('fx-glow-color').value=app.effects.glowColor; $('fx-glow-amount').value=app.effects.glowAmount;
    $('fx-shadow').checked=app.effects.shadow; $('fx-shadow-color').value=app.effects.shadowColor; $('fx-shadow-blur').value=app.effects.shadowBlur; $('fx-shadow-x').value=app.effects.shadowX; $('fx-shadow-y').value=app.effects.shadowY;
    $('fx-blur').checked=app.effects.blur; $('fx-blur-amount').value=app.effects.blurAmount;
    $('fx-tint').checked=app.effects.tint; $('fx-tint-color').value=app.effects.tintColor; $('fx-tint-alpha').value=app.effects.tintAlpha; $('fx-tint-mode').value=app.effects.tintMode;
    $('fx-scan').checked=app.effects.scan; $('fx-scan-color').value=app.effects.scanColor; $('fx-scan-alpha').value=app.effects.scanAlpha; $('fx-scan-thick').value=app.effects.scanThick; $('fx-scan-space').value=app.effects.scanSpace;

    draw();
}
function savePreset(){
    const name = $('preset-name').value.trim() || `Preset ${new Date().toLocaleTimeString()}`;
    const list = JSON.parse(localStorage.getItem('spiro_presets')||'[]');
    list.push({name, state: currentState()});
    localStorage.setItem('spiro_presets', JSON.stringify(list));
    loadPresetsToList(); $('preset-name').value=''; flashStatus('Saved preset ‚úîÔ∏è');
}
function loadPresetsToList(){
    const list = JSON.parse(localStorage.getItem('spiro_presets')||'[]');
    const sel = $('preset-list'); sel.innerHTML='';
    list.forEach((p,i)=>{ const o=document.createElement('option'); o.value=i; o.textContent=p.name; sel.appendChild(o); });
}
function loadPreset(){
    const list = JSON.parse(localStorage.getItem('spiro_presets')||'[]');
    const idx = parseInt(($('preset-list').value)||'-1'); if(idx<0 || !list[idx]) return;
    applyState(list[idx].state); flashStatus(`Loaded ‚Äú${list[idx].name}‚Äù`);
}
function deletePreset(){
    const list = JSON.parse(localStorage.getItem('spiro_presets')||'[]');
    const idx = parseInt(($('preset-list').value)||'-1'); if(idx<0) return;
    const name = list[idx].name;
    list.splice(idx,1); localStorage.setItem('spiro_presets', JSON.stringify(list));
    loadPresetsToList(); flashStatus(`Deleted ‚Äú${name}‚Äù`);
}
function copyShareLink(){
    const state = currentState();
    const packed = btoa(unescape(encodeURIComponent(JSON.stringify(state))));
    const url = location.origin + location.pathname + '#s=' + packed;
    copyToClipboard(url); flashStatus('Link copied üîó');
}
function applyHashState(){
    try{
        const h = new URL(location.href).hash;
        if(!h.startsWith('#s=')) { flashStatus('No state in URL'); return; }
        const payload = h.slice(3);
        const state = JSON.parse(decodeURIComponent(escape(atob(payload))));
        applyState(state); flashStatus('Loaded from URL ‚úîÔ∏è');
    }catch(e){ flashStatus('Invalid URL state ‚ùó'); }
}
function flashStatus(msg){
    const el = app.statusEl;
    const prev = el.textContent;
    el.textContent = msg;
    setTimeout(()=>{ el.textContent = prev; }, 1500);
}

/* ===== END ===== */
</script>
</body>
</html>
