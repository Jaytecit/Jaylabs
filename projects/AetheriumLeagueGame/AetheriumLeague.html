<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Aetherium Echo — League Edition (Fixed)</title>
  <style>
    :root { --bg: #05070a; --fg: #e6e6e6; --highlight: #4ff; }
    html, body { height: 100%; margin: 0; background: #000; overflow: hidden; user-select: none; -webkit-user-select: none; cursor: none; }
    
    .hud-layer { position: fixed; inset: 0; pointer-events: none; z-index: 10; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; font-family: "Courier New", monospace; text-shadow: 0 0 5px currentColor; color: rgba(200, 220, 255, 0.7); transition: color 0.3s; }
    .top-bar { display: flex; justify-content: space-between; width: 100%; font-size: 12px; letter-spacing: 1px; text-transform: uppercase; }
    .controls-hint { font-size: 10px; opacity: 0.5; text-align: center; }
    
    .scanlines { position: fixed; inset: 0; background: linear-gradient(to bottom, rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%); background-size: 100% 4px; pointer-events: none; z-index: 5; opacity: 0.6; }
    .vignette { position: fixed; inset: 0; background: radial-gradient(circle at center, transparent 50%, rgba(0,0,0,0.9) 100%); pointer-events: none; z-index: 6; }
    
    #gate { position: fixed; inset: 0; background: #000; z-index: 100; display: flex; align-items: center; justify-content: center; color: #4ff; font-family: monospace; transition: opacity 0.5s; pointer-events: auto; cursor: pointer; }
    .click-start { animation: blink 1s infinite; }
    @keyframes blink { 50% { opacity: 0.3; } }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.3/lib/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.3/lib/addons/p5.sound.min.js"></script>
</head>
<body>

<div class="hud-layer">
  <div class="top-bar">
    <span>JayLabs System V.10.2</span>
    <span>Aetherium League</span>
    <span>Visual Fix Applied</span>
  </div>
  <div class="controls-hint" id="control-text">KEYBOARD: WASD Move • SPACE Dash • E Overdrive • SHIFT Bash</div>
</div>

<div class="scanlines"></div>
<div class="vignette"></div>
<div id="gate" onclick="unlockAudio()">
  <div class="click-start">[ CLICK OR PRESS A TO START ]</div>
</div>

<script>
// ==========================================
// CONFIGURATION
// ==========================================
const C = {
  WIN_SCORE: 7,
  BASE_PADDLE_H: 90,
  BASE_SPEED: 9,
  BALL: { SIZE: 18 },
  DASH: { DURATION: 14, COOLDOWN: 55, BOOST: 3 },
  OVERDRIVE: { DURATION: 240, CHARGE_PER_HIT: 16 },
  DIFFICULTY: [
    { name: 'ZEN',   base: 4,  max: 10, aiLerp: 0.03, desc: "Easy / Practice" },
    { name: 'ECHO',  base: 9,  max: 22, aiLerp: 0.08, desc: "Normal" },
    { name: 'HYPER', base: 13, max: 30, aiLerp: 0.14, desc: "Hard" },
    { name: 'SONIC', base: 18, max: 45, aiLerp: 0.25, desc: "Extreme" }
  ],
  TIMING: { HITSTOP: 4, RESPAWN: 60, BUFF_DURATION: 600, HAZARD: 420, ASTEROID: 520 },
  GAMEPAD: { DEADZONE: 0.2, BTN_ACCEPT: 0, BTN_DASH: 0, BTN_BASH: 2, BTN_OVERDRIVE: 1 }
};

const CHARACTERS = [
  { name: 'VECTOR',     color: [200, 80, 100], spd: 1.0, size: 1.0, desc: "Balanced Pilot" },
  { name: 'JUGGERNAUT', color: [10, 90, 100],  spd: 0.7, size: 1.4, desc: "Heavy / Large Hitbox" },
  { name: 'WRAITH',     color: [280, 80, 100], spd: 1.3, size: 0.8, desc: "Fast / Small Hitbox" },
  { name: 'GLITCH',     color: [120, 100, 100],spd: 1.0, size: 1.0, desc: "High Acceleration" },
  { name: 'NOMAD',      color: [40, 100, 100], spd: 1.1, size: 0.9, desc: "Aggressive Style" },
  { name: 'GUARDIAN',   color: [220, 60, 100], spd: 0.8, size: 1.2, desc: "Defense Specialist" },
  { name: 'ECHO',       color: [320, 80, 100], spd: 1.0, size: 1.0, desc: "Precision Pilot" },
  { name: 'ORACLE',     color: [180, 40, 100], spd: 1.0, size: 1.0, desc: "Standard Model" }
];

// ==========================================
// GLOBAL STATE
// ==========================================
let gameState = 'TITLE'; 
let menuDelay = 0;
let bloomBuffer;
let audioEnabled = false;

// Selection Indices
let charIndex = 0;
let diffIndex = 1;

// Objects
let starfield = [];
let p1 = null, p2 = null; 
let balls = [];
let particles = [];
let floaters = []; 
let powerups = [];
let hazards = [];
let asteroids = [];
let matchDirector;
let tournament; 

// FX
let shake = 0;
let hitStop = 0;
let globalHue = 0;
let sfx = {};

// ==========================================
// SETUP
// ==========================================
function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 100);
  noCursor();
  
  bloomBuffer = createGraphics(width/2, height/2);
  bloomBuffer.colorMode(HSB, 360, 100, 100, 100);

  for(let i=0; i<420; i++) starfield.push(new Star());

  setupAudio();
  
  window.addEventListener("gamepadconnected", (e) => updateUIForGamepad(true));
  window.addEventListener("gamepaddisconnected", () => updateUIForGamepad(false));
}

function unlockAudio() {
  if (!audioEnabled) {
    userStartAudio().then(() => {
      audioEnabled = true;
      sfx.bgDrone.amp(0.15, 2.0);
      document.getElementById('gate').style.opacity = 0;
      setTimeout(() => document.getElementById('gate').style.display='none', 500);
    });
  }
}

function updateUIForGamepad(connected) {
  const el = document.getElementById('control-text');
  if (connected) {
    el.innerText = "GAMEPAD: Stick Move • (A) Dash • (B) Overdrive • (X) Bash";
    el.style.color = "#4f8";
  } else {
    el.innerText = "KEYBOARD: WASD Move • SPACE Dash • E Overdrive • SHIFT Bash";
    el.style.color = "rgba(200, 220, 255, 0.7)";
  }
}

// ==========================================
// MAIN LOOP
// ==========================================
function draw() {
  if (hitStop > 0) { hitStop--; return; }
  
  globalHue = (frameCount * 0.2) % 360;
  
  handleInput();
  
  background(230, 40, 8, 100); 
  drawStarfield();

  push();
  if (shake > 0) {
    translate(random(-shake, shake), random(-shake, shake));
    shake *= 0.9;
    if (shake < 0.5) shake = 0;
  }

  switch(gameState) {
    case 'TITLE':       drawTitle(); break;
    case 'CHAR_SELECT': drawCharSelect(); break;
    case 'DIFF_SELECT': drawDiffSelect(); break;
    case 'BRACKET':     drawBracket(); break;
    case 'GAME':        runGame(); break;
    case 'MATCH_OVER':  drawMatchOver(); break;
    case 'CHAMPION':    drawChampion(); break;
  }
  
  pop();
  applyBloom();
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  bloomBuffer.resizeCanvas(width/2, height/2);
}

// ==========================================
// INPUT
// ==========================================
function handleInput() {
  if (menuDelay > 0) { menuDelay--; return; }

  let moveX = 0, moveY = 0;
  let confirm = false;

  // Keyboard
  if (keyIsDown(UP_ARROW) || keyIsDown(87)) moveY = -1;
  if (keyIsDown(DOWN_ARROW) || keyIsDown(83)) moveY = 1;
  if (keyIsDown(LEFT_ARROW) || keyIsDown(65)) moveX = -1;
  if (keyIsDown(RIGHT_ARROW) || keyIsDown(68)) moveX = 1;
  if (keyIsDown(13) || keyIsDown(32)) confirm = true; 

  // Gamepad Safety Check
  const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
  const gp = gamepads[0]; // Get first controller
  
  if (gp) {
    if (gp.buttons.some(b => b.pressed) && !audioEnabled) unlockAudio();
    if (gp.axes[1] < -0.5 || gp.buttons[12].pressed) moveY = -1;
    if (gp.axes[1] > 0.5 || gp.buttons[13].pressed) moveY = 1;
    if (gp.axes[0] < -0.5 || gp.buttons[14].pressed) moveX = -1;
    if (gp.axes[0] > 0.5 || gp.buttons[15].pressed) moveX = 1;
    if (gp.buttons[0].pressed) confirm = true;
  }

  if ((moveX !== 0 || moveY !== 0 || confirm) && !audioEnabled) unlockAudio();

  // State Logic
  if (gameState === 'TITLE' && confirm) {
    playSound('select');
    gameState = 'CHAR_SELECT';
    menuDelay = 15;
  }
  else if (gameState === 'CHAR_SELECT') {
    if (moveX !== 0) {
      charIndex = (charIndex + moveX + CHARACTERS.length) % CHARACTERS.length;
      playSound('blip');
      menuDelay = 10;
    }
    if (confirm) {
      playSound('select');
      gameState = 'DIFF_SELECT';
      menuDelay = 15;
    }
  }
  else if (gameState === 'DIFF_SELECT') {
    if (moveY !== 0) {
      diffIndex = (diffIndex + moveY + 4) % 4;
      playSound('blip');
      menuDelay = 10;
    }
    if (confirm) {
      playSound('select');
      startTournament(); 
      gameState = 'BRACKET';
      menuDelay = 30; 
    }
  }
  else if (gameState === 'BRACKET' && confirm) {
    playSound('select');
    initMatch();
    gameState = 'GAME';
    menuDelay = 15;
  }
  else if ((gameState === 'MATCH_OVER' || gameState === 'CHAMPION') && confirm) {
    if (gameState === 'CHAMPION' || tournament.playerEliminated) {
      gameState = 'TITLE'; 
    } else {
      advanceTournament();
      gameState = 'BRACKET';
    }
    playSound('select');
    menuDelay = 30;
  }
}

// ==========================================
// GAME LOGIC
// ==========================================
function startTournament() {
  let roster = [ { isPlayer: true, char: CHARACTERS[charIndex] } ];
  let pool = CHARACTERS.filter((c, i) => i !== charIndex);
  pool.sort(() => Math.random() - 0.5);
  for(let i=0; i<7; i++) roster.push({ isPlayer: false, char: pool[i % pool.length] });

  tournament = {
    round: 1, 
    bracket: roster, 
    matches: [[0,1], [2,3], [4,5], [6,7]],
    playerEliminated: false
  };
}

function advanceTournament() {
  let currentMatches = tournament.matches;
  let winners = [];
  for (let m of currentMatches) {
    let pA = tournament.bracket[m[0]];
    let pB = tournament.bracket[m[1]];
    if (pA.isPlayer) winners.push(pA);
    else if (pB.isPlayer) winners.push(pB);
    else winners.push( Math.random() > 0.5 ? pA : pB );
  }
  tournament.bracket = winners;
  tournament.round++;
  if (tournament.round === 2) tournament.matches = [[0,1], [2,3]];
  else if (tournament.round === 3) tournament.matches = [[0,1]];
}

function initMatch() {
  let playerObj = tournament.bracket[0];
  let opponentObj = tournament.bracket[1];
  
  p1 = new Paddle(40, true, playerObj.char);
  p2 = new Paddle(width-40-C.BASE_PADDLE_H*0.2, false, opponentObj.char); 
  
  balls = []; powerups = []; particles = []; floaters = []; hazards = []; asteroids = [];
  matchDirector = new Director();
  
  spawnFloatingText("VS " + opponentObj.char.name, width/2, height/2 - 100, opponentObj.char.color, 120);
}

function runGame() {
  if (!p1 || !p2) { initMatch(); return; }

  matchDirector.update();
  p1.update();
  p2.update();

  for (let i = powerups.length - 1; i >= 0; i--) {
    powerups[i].update();
    if (powerups[i].dead) powerups.splice(i, 1);
  }
  for (let i = hazards.length - 1; i >= 0; i--) {
    hazards[i].update();
    if (hazards[i].isDead()) hazards.splice(i, 1);
  }
  for (let i = asteroids.length - 1; i >= 0; i--) {
    asteroids[i].update();
    if (asteroids[i].isOffscreen()) asteroids.splice(i, 1);
  }
  
  for (let i = balls.length - 1; i >= 0; i--) {
    let b = balls[i];
    b.update();
    b.checkPaddle(p1);
    b.checkPaddle(p2);
    b.checkPowerups();
    hazards.forEach(h => h.affect(b));
    for (let j = asteroids.length - 1; j >= 0; j--) {
      asteroids[j].checkHit(b);
    }
    if (p1.hasShield) checkShield(b, p1);
    if (p2.hasShield) checkShield(b, p2);

    let res = b.checkScore();
    if (res !== 0) {
      handleScore(res, b);
      balls.splice(i, 1);
    }
  }

  for (let i = particles.length - 1; i >= 0; i--) {
    particles[i].update();
    if (particles[i].life <= 0) particles.splice(i, 1);
  }
  for (let i = floaters.length - 1; i >= 0; i--) {
    floaters[i].update();
    if (floaters[i].life <= 0) floaters.splice(i, 1);
  }

  drawField();
  drawEntities();
  drawUI();
}

function drawEntities() {
  hazards.forEach(h => h.draw());
  asteroids.forEach(a => a.draw());
  if(p1) p1.draw(); 
  if(p2) p2.draw();
  balls.forEach(b => b.draw());
  powerups.forEach(p => p.draw());
  particles.forEach(p => p.draw());
}

function drawUI() { floaters.forEach(f => { f.draw(); }); }

// ==========================================
// HELPERS
// ==========================================
function spawnExplosion(x, y, c, count=15) {
  for(let i=0; i<count; i++) particles.push(new Particle(x, y, c, 8));
}

function spawnFloatingText(s,x,y,c,l=60) {
  floaters.push({
    s,x,y,c,l,ml:l,
    update:function(){this.y--;this.l--;},
    draw:function(){fill(this.c[0],this.c[1],100,map(this.l,0,this.ml,0,100));textSize(24);text(this.s,this.x,this.y);}
  });
}

function handleScore(winner, ballRef) {
  let scorer = winner === 1 ? p1 : p2;
  scorer.score++;
  
  shake = 15;
  spawnExplosion(ballRef.x, ballRef.y, scorer.color);
  spawnFloatingText(winner === 1 ? "POINT" : "ENEMY POINT", width/2, height/3, scorer.color);
  playSound('score');

  if (scorer.score >= C.WIN_SCORE) {
    if (winner === 1 && tournament.round === 3) gameState = 'CHAMPION';
    else gameState = 'MATCH_OVER';
  } else {
    matchDirector.onScore();
  }
}

function checkShield(ball, paddle) {
  let shieldX = paddle.isHuman ? paddle.x - 20 : paddle.x + paddle.w + 20;
  let hit = (paddle.isHuman && ball.x < shieldX && ball.vx < 0) || 
            (!paddle.isHuman && ball.x > shieldX && ball.vx > 0);
  
  if (hit && Math.abs(ball.y - height/2) < height) { 
    ball.vx *= -1.5; ball.x += ball.vx; 
    paddle.hasShield = false; 
    playSound('shield_break');
    spawnExplosion(shieldX, ball.y, [180, 100, 100], 30);
    shake = 10;
    spawnFloatingText("SAVED!", shieldX, ball.y, [180, 100, 100]);
  }
}

// ==========================================
// RENDER SCREENS
// ==========================================
function drawTitle() {
  textAlign(CENTER, CENTER);
  textSize(100); textStyle(BOLD); fill(globalHue, 80, 100);
  text("AETHERIUM", width/2, height/3);
  textSize(80); fill((globalHue+180)%360, 80, 100);
  text("LEAGUE", width/2, height/3 + 80);
  if (frameCount % 60 < 30) { textSize(24); fill(0, 0, 100); text("PRESS START / SPACE / A", width/2, height*0.75); }
  textSize(14); fill(0, 0, 60); text("JAYLABS V.10.2", width/2, height - 30);
}

function drawCharSelect() {
  textAlign(CENTER, CENTER);
  textSize(40); fill(0,0,100); text("SELECT PILOT", width/2, height*0.15);
  let c = CHARACTERS[charIndex];
  rectMode(CENTER); stroke(c.color); strokeWeight(4); fill(c.color[0], c.color[1], 20);
  rect(width/2, height/2, 300, 300); noStroke();
  textSize(50); fill(c.color); text(c.name, width/2, height/2 - 40);
  textSize(20); fill(0,0,80); text(c.desc, width/2, height/2 + 20);
  if (frameCount % 40 < 20) { textSize(40); fill(0,0,100); text("<", width/2 - 200, height/2); text(">", width/2 + 200, height/2); }
}

function drawDiffSelect() {
  textAlign(CENTER, CENTER); textSize(40); fill(0,0,100); text("SELECT DIFFICULTY", width/2, height*0.2);
  for(let i=0; i<C.DIFFICULTY.length; i++) {
    let d = C.DIFFICULTY[i]; let y = height*0.35 + i * 80;
    if (i === diffIndex) {
      fill(globalHue, 100, 100); textSize(32); textStyle(BOLD); text("> " + d.name + " <", width/2, y);
      textSize(16); fill(0,0,100); textStyle(NORMAL); text(d.desc, width/2, y + 30);
    } else {
      fill(0,0,50); textSize(24); textStyle(NORMAL); text(d.name, width/2, y);
    }
  }
}

function drawBracket() {
  textAlign(CENTER, CENTER); textSize(40); fill(0,0,100); text("LEAGUE STANDINGS", width/2, height*0.1);
  textSize(20); fill(globalHue, 80, 100);
  let rText = tournament.round === 1 ? "QUARTER FINALS" : tournament.round === 2 ? "SEMI FINALS" : "GRAND FINAL";
  text(rText, width/2, height*0.16);
  let players = tournament.bracket;
  let count = players.length; let spacing = height * 0.6 / count; let startY = height * 0.25;
  for(let i=0; i<count; i++) {
    let p = players[i]; let y = startY + i * spacing + spacing/2;
    textAlign(LEFT, CENTER);
    if (p.isPlayer) { fill(globalHue, 100, 100); textStyle(BOLD); } else { fill(p.char.color); textStyle(NORMAL); }
    text(p.char.name, width*0.3, y);
  }
  textAlign(CENTER, CENTER);
  if (frameCount % 60 < 30) { textSize(20); fill(0,0,100); text("PRESS START TO BEGIN MATCH", width/2, height - 50); }
}

function drawMatchOver() {
  textAlign(CENTER, CENTER); let won = p1.score >= C.WIN_SCORE;
  textSize(80); 
  if (won) { fill(120, 100, 100); text("VICTORY", width/2, height/2); }
  else { fill(0, 100, 100); text("ELIMINATED", width/2, height/2); tournament.playerEliminated = true; }
  textSize(20); fill(0,0,100); text("PRESS START", width/2, height/2 + 80);
}

function drawChampion() {
  textAlign(CENTER, CENTER); textSize(100); fill(globalHue, 100, 100); text("LEAGUE CHAMPION", width/2, height/2 - 40);
  textSize(30); fill(0,0,100); text(CHARACTERS[charIndex].name, width/2, height/2 + 60); text("PRESS START TO RETURN", width/2, height - 100);
}

function drawField() {
  stroke(220, 20, 20, 15); strokeWeight(2); line(width/2, 0, width/2, height);
  noFill(); ellipse(width/2, height/2, 100);
  textSize(120); textStyle(BOLD); textAlign(CENTER, CENTER);
  fill(p1.color[0], 60, 40, 20); text(p1.score, width/2 - 150, height/2);
  fill(p2.color[0], 60, 40, 20); text(p2.score, width/2 + 150, height/2);
}

function applyBloom() {
  bloomBuffer.background(0,0,0,0); bloomBuffer.image(get(), 0, 0, width/2, height/2);
  bloomBuffer.filter(BLUR, 4); 
  push(); blendMode(ADD); tint(255,140); image(bloomBuffer, 0, 0, width, height); pop(); 
  blendMode(BLEND);
}

function drawStarfield() {
  push(); blendMode(ADD);
  for(let s of starfield) { s.update(); s.draw(); }
  pop(); blendMode(BLEND);
}

// ==========================================
// CLASSES
// ==========================================
class Director {
  constructor() { 
    this.timer = C.TIMING.RESPAWN; 
    this.state = 'SERVE'; 
    this.nextPowerup = 300; 
    this.nextHazard = C.TIMING.HAZARD; 
    this.nextAsteroid = C.TIMING.ASTEROID;
  }
  update() {
    if (balls.length === 0 && this.state !== 'SERVE') { this.state = 'SERVE'; this.timer = C.TIMING.RESPAWN; }
    if (this.state === 'SERVE') {
      this.timer--;
      if (this.timer <= 0) { balls.push(new Ball(width/2, height/2)); playSound('spawn'); this.state = 'PLAY'; }
    }
    if (this.state === 'PLAY') {
      if (--this.nextPowerup <= 0) { powerups.push(new Powerup()); this.nextPowerup = random(300, 800); }
      if (--this.nextHazard <= 0) { hazards.push(new Hazard(random()<0.4?'vortex':'glitch')); this.nextHazard = random(C.TIMING.HAZARD*0.7, C.TIMING.HAZARD*1.3); }
      if (--this.nextAsteroid <= 0 && asteroids.length < 3) { asteroids.push(new Asteroid()); this.nextAsteroid = random(C.TIMING.ASTEROID*0.8, C.TIMING.ASTEROID*1.4); }
    }
  }
  onScore() { 
    this.state='SERVE'; this.timer=C.TIMING.RESPAWN; 
    this.nextPowerup = 240; this.nextHazard = C.TIMING.HAZARD; this.nextAsteroid = C.TIMING.ASTEROID;
    hazards = []; asteroids = [];
  }
}

class Paddle {
  constructor(x, isHuman, charData) {
    this.x = x; this.y = height/2; this.isHuman = isHuman;
    this.baseH = C.BASE_PADDLE_H * charData.size;
    this.h = this.baseH; this.w = 16;
    this.color = charData.color; this.speedMod = charData.spd;
    this.score = 0; this.dy = 0; this.energy = 0;
    this.dashTimer = 0; this.dashCooldown = 0; this.dashDir = 0;
    this.bashTimer = 0; this.growTimer = 0; this.freezeTimer = 0; this.hasShield = false;
    this.overdriveTimer = 0;
  }
  update() {
    if (this.freezeTimer > 0) { this.freezeTimer--; this.x = this.isHuman ? 40+random(-2,2) : width-40-this.w+random(-2,2); return; }
    else this.x = this.isHuman ? 40 : width - 40 - this.w;

    if (this.growTimer > 0) this.growTimer--;
    if (this.dashCooldown > 0) this.dashCooldown--;
    if (this.dashTimer > 0) this.dashTimer--;
    if (this.overdriveTimer > 0) this.overdriveTimer--;

    let sizeMul = (this.growTimer>0 ? 1.4 : 1) * (this.overdriveTimer>0 ? 1.25 : 1);
    this.h = this.baseH * sizeMul;

    let moveY = 0, doDash = false, doBash = false, doOverdrive = false;

    if (this.isHuman) {
      if (keyIsDown(87)||keyIsDown(UP_ARROW)) moveY = -1;
      if (keyIsDown(83)||keyIsDown(DOWN_ARROW)) moveY = 1;
      if (keyIsDown(32)||keyIsDown(88)) doDash = true;
      if (keyIsDown(16)||keyIsDown(89)) doBash = true;
      if (keyIsDown(69)) doOverdrive = true;

      const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
      const gp = gamepads[0];
      if (gp) {
        if (Math.abs(gp.axes[1]) > C.GAMEPAD.DEADZONE) moveY = gp.axes[1];
        if (gp.buttons[C.GAMEPAD.BTN_DASH]?.pressed) doDash = true;
        if (gp.buttons[C.GAMEPAD.BTN_BASH]?.pressed) doBash = true;
        if (gp.buttons[C.GAMEPAD.BTN_OVERDRIVE]?.pressed) doOverdrive = true;
      }

      this.dy = lerp(this.dy, moveY * C.BASE_SPEED * 3, 0.18);
      if (doDash && this.dashCooldown <= 0) { this.activateDash(moveY); }
      if (doBash && this.bashTimer <= 0) { this.activateBash(); }
      if (doOverdrive && this.energy >= 100 && this.overdriveTimer <= 0) { this.activateOverdrive(); }
    } else {
      let diff = C.DIFFICULTY[diffIndex];
      let threat = balls.find(b => b.vx > 0);
      let dest = threat ? threat.y : height/2;
      if (diffIndex === 0) dest += sin(frameCount*0.1)*60; // Zen mode error
      let lerpFactor = diff.aiLerp + (this.energy/3000);
      this.y = lerp(this.y, dest - this.h/2, lerpFactor);
      if (threat && abs(threat.x-this.x)<50 && abs(threat.y-(this.y+this.h/2))<60 && this.bashTimer<=0) {
        if(random()<(diffIndex*0.2)) this.activateBash();
      }
      if (threat && this.dashCooldown<=0 && abs(threat.x-this.x) < width*0.35) this.activateDash(Math.sign(threat.vy||1));
      if (this.energy>=100 && this.overdriveTimer<=0 && threat) this.activateOverdrive();
    }
    let speed = C.BASE_SPEED * this.speedMod;
    if (this.dashTimer>0) speed *= C.DASH.BOOST;
    if (this.overdriveTimer>0) speed *= 0.75;

    this.y += constrain(this.dy, -speed, speed);

    if (this.dashTimer>0) { this.y += this.dashDir * speed * 0.35; if(frameCount%2===0) particles.push(new Particle(this.x+this.w/2, this.y+this.h/2, this.color, this.h/3, random(-1,1), random(-1,1), 15, true)); }
    if (this.bashTimer>0) this.bashTimer--;
    this.y = constrain(this.y, 10, height - this.h - 10);
    if (this.energy<120) this.energy+=0.05;
  }
  activateDash(dir=0) { this.dashTimer=C.DASH.DURATION; this.dashCooldown=C.DASH.COOLDOWN; this.dashDir = dir!==0 ? Math.sign(dir) : Math.sign(this.dy||1); playSound('dash'); shake = max(shake, 6); this.dy += this.dashDir * C.BASE_SPEED * 2; spawnExplosion(this.x+this.w/2,this.y+this.h/2,this.color,8); }
  activateBash() { this.bashTimer=15; playSound('bash'); }
  activateOverdrive() { this.overdriveTimer = C.OVERDRIVE.DURATION; this.energy = 0; shake = max(shake, 12); spawnFloatingText("OVERDRIVE", this.x + (this.isHuman?-30:30), this.y-20, [this.color[0],100,100], 90); }
  draw() {
    let drawW = this.w, drawX = this.x;
    if (this.freezeTimer > 0) { fill(200, 50, 100); rect(drawX-5, this.y-5, drawW+10, this.h+10); }
    if (this.bashTimer > 0) { drawW = this.w*2.5; drawX = this.isHuman ? this.x : this.x - this.w*1.5; }
    if (this.hasShield) { stroke(180, 100, 100, 80+sin(frameCount*0.2)*20); strokeWeight(4); let sx = this.isHuman ? this.x-20 : this.x+this.w+20; line(sx,0,sx,height); noStroke(); }
    if (this.overdriveTimer>0) { stroke(this.color[0],100,100,70); strokeWeight(6); noFill(); rect(drawX-4, this.y-6, drawW+8, this.h+12, 6); noStroke(); }
    fill(this.color[0], this.color[1], this.color[2]); noStroke(); rect(drawX, this.y, drawW, this.h, 4);
    fill(this.color[0], 20, 100); rect(drawX+4, this.y+4, drawW-8, this.h-8, 2);
    if (this.dashTimer>0) { fill(this.color[0],60,100,60); rect(drawX-6, this.y+this.h*0.25, 3, this.h*0.5); }
    if (this.isHuman) { 
      let energyPct = constrain(this.energy/100, 0, 1);
      fill(120, 80, 100); rect(this.x-10, this.y+this.h-(this.h*energyPct), 4, this.h*energyPct);
      let dashPct = 1 - (this.dashCooldown / C.DASH.COOLDOWN); fill(200,60,100,70); rect(this.x-16, this.y+this.h-(this.h*dashPct), 3, this.h*dashPct);
    }
  }
}

class Ball {
  constructor(x, y) {
    this.x = x; this.y = y; this.size = C.BALL.SIZE; this.trail = [];
    let set = C.DIFFICULTY[diffIndex]; this.maxS = set.max; this.speed = set.base;
    let angle = random(-PI/4, PI/4); let dir = random() > 0.5 ? 1 : -1;
    this.vx = cos(angle)*this.speed*dir; this.vy = sin(angle)*this.speed;
    this.hue = 0; this.lastHit = null; this.inOverdrive = false;
  }
  update() {
    if (this.inOverdrive && this.lastHit) {
      let target = this.lastHit === p1 ? p2 : p1;
      if (target) this.y = lerp(this.y, target.y + target.h/2, 0.08);
    }
    this.x += this.vx; this.y += this.vy;
    if (this.y<0 || this.y>height) { this.vy*=-1; this.y=constrain(this.y,0,height); playSound('wall'); }
    this.trail.push({x:this.x, y:this.y}); if(this.trail.length>12) this.trail.shift();
  }
  checkPaddle(p) {
    let ph=p.h, pw=p.bashTimer>0?p.w*2.5:p.w;
    let px=p.bashTimer>0&&!p.isHuman?p.x-p.w*1.5:p.x;
    if (this.x+this.size/2>px && this.x-this.size/2<px+pw && this.y+this.size/2>p.y && this.y-this.size/2<p.y+ph) {
      this.lastHit=p; this.hue=p.color[0];
      let intersectY = this.y - (p.y+ph/2); let angle = (intersectY/(ph/2)) * (PI/3);
      let force = 1;
      if(p.bashTimer>0) { this.speed=this.maxS+5; hitStop=4; shake=10; force+=0.8; playSound('bash_hit'); spawnExplosion(this.x,this.y,p.color,30); }
      else { this.speed = min(this.speed+1.5, this.maxS); playSound('hit'); spawnExplosion(this.x,this.y,p.color,10); }
      if (p.dashTimer>0) { force+=0.6; shake = max(shake, 8); }
      if (p.overdriveTimer>0) { this.inOverdrive=true; this.speed=this.maxS+8; force+=1.2; this.hue=(p.color[0]+180)%360; spawnExplosion(this.x,this.y,[this.hue,100,100],25); }
      p.energy = min(120, p.energy + (p.bashTimer>0?25:14));
      this.vx = this.speed * force * cos(angle) * (p.isHuman?1:-1); this.vy = this.speed * force * sin(angle); this.x += this.vx;
    }
  }
  checkPowerups() {
    for(let i=0; i<powerups.length; i++) {
      let pu = powerups[i];
      if(dist(this.x,this.y,pu.x,pu.y) < this.size+pu.size) { pu.activate(this); powerups.splice(i,1); playSound('powerup'); }
    }
  }
  checkScore() { if(this.x<-50) return 2; if(this.x>width+50) return 1; return 0; }
  draw() {
    noStroke();
    for(let i=0; i<this.trail.length; i++) { let t=this.trail[i]; fill(this.hue,80,100,map(i,0,this.trail.length,0,80)); ellipse(t.x,t.y,map(i,0,this.trail.length,5,this.size)); }
    let core = this.inOverdrive ? this.size*1.8 : this.size;
    fill(0,0,100); ellipse(this.x,this.y,core); fill(this.hue,90,100,50); ellipse(this.x,this.y,core*1.8);
  }
}

class Powerup {
  constructor() {
    this.x = width/2+random(-200,200); this.y=random(100,height-100); this.size=25; this.dead=false;
    let r=random(1);
    if(r<0.2) this.t='MULTIBALL'; else if(r<0.35) this.t='BIG'; else if(r<0.5) this.t='ENERGY';
    else if(r<0.65) this.t='EXTEND'; else if(r<0.78) this.t='SHIELD'; else if(r<0.88) this.t='FREEZE'; else this.t='VORTEX';
  }
  update() { this.y+=sin(frameCount*0.05); }
  activate(b) {
    this.dead=true; let ben = b.lastHit ? b.lastHit : (b.vx>0?p1:p2); let opp = ben===p1?p2:p1; let c=[0,0,100];
    if(this.t==='MULTIBALL') { c=[50,100,100]; for(let i=0;i<2;i++) balls.push(new Ball(b.x,b.y)); }
    else if(this.t==='BIG') { c=[150,100,100]; b.size*=2; }
    else if(this.t==='ENERGY') { c=[280,100,100]; ben.energy=100; }
    else if(this.t==='EXTEND') { c=[120,100,100]; ben.growTimer=C.TIMING.BUFF_DURATION; }
    else if(this.t==='SHIELD') { c=[180,100,100]; ben.hasShield=true; }
    else if(this.t==='FREEZE') { c=[200,100,100]; opp.freezeTimer=90; playSound('freeze'); }
    else if(this.t==='VORTEX') { c=[300,100,100]; hazards.push(new Hazard('vortex')); }
    spawnFloatingText(this.t, this.x, this.y-30, c);
  }
  draw() {
    push(); translate(this.x,this.y); rotate(frameCount*0.05); let c=[0,0,100];
    if(this.t==='MULTIBALL') c=[50,100,100]; if(this.t==='BIG') c=[150,100,100]; if(this.t==='ENERGY') c=[280,100,100];
    if(this.t==='EXTEND') c=[120,100,100]; if(this.t==='SHIELD') c=[180,100,100]; if(this.t==='FREEZE') c=[200,100,100]; if(this.t==='VORTEX') c=[300,100,100];
    stroke(c); strokeWeight(2); noFill(); rectMode(CENTER); rect(0,0,this.size,this.size); fill(c); noStroke(); rect(0,0,this.size/2,this.size/2); pop();
  }
}

class Hazard {
  constructor(type='glitch') { this.type=type; this.x=width/2; this.y=random(height*0.25,height*0.75); this.r=random(90,150); this.life=360; this.hue=type==='vortex'?300:260; }
  update() { this.life--; }
  draw() { noFill(); strokeWeight(4); stroke(this.hue,90,80,this.life/4); ellipse(this.x,this.y,this.r*2 + sin(frameCount*0.2)*20); noStroke(); }
  affect(ball) { if(dist(this.x,this.y,ball.x,ball.y)<this.r) { if(this.type==='vortex'){ ball.vx += (this.x-ball.x)*0.01; ball.vy += (this.y-ball.y)*0.01; } else { ball.vx += random(-0.8,0.8); ball.vy += random(-0.8,0.8); } } }
  isDead() { return this.life<=0; }
}

class Asteroid {
  constructor() { this.y=random(height); this.size=random(16,38); this.speed=random(2,5); this.x=random()<0.5? -this.size : width+this.size; this.vx=(this.x<0?1:-1)*this.speed; }
  update() { this.x += this.vx; }
  draw() { fill(30,20,80); rectMode(CORNER); rect(this.x,this.y,this.size,this.size); }
  checkHit(ball) { if(dist(this.x,this.y,ball.x,ball.y) < this.size/2 + ball.size/2) { ball.vx*=-1; ball.vy*=-1; this.vx*=-1.2; shake=6; return true; } return false; }
  isOffscreen() { return this.x < -60 || this.x > width+60; }
}

class Star {
  constructor() { this.reset(); }
  reset() { this.x=random(-width,width); this.y=random(-height,height); this.z=random(width); this.speed=random(6,14); this.parallax=random(0.6,1.4); }
  update() { this.z-=this.speed; if(this.z<1) this.reset(); }
  draw() {
    let sx=map(this.x/this.z,0,1,0,width)+width/2; let sy=map(this.y/this.z,0,1,0,height)+height/2; let r=map(this.z,0,width,12*this.parallax,0);
    let hue=(globalHue + this.speed*4 + this.x*0.02)%360;
    fill(hue,80,100,80); noStroke(); ellipse(sx,sy,r*0.6,r);
    fill(hue,40,100,50); rectMode(CENTER); rect(sx,sy,r*0.3,r*1.2);
  }
}

class Particle {
  constructor(x, y, c, s=6, vx=random(-3,3), vy=random(-3,3), l=40, isRect=false) { this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.c=c; this.l=l; this.ml=l; this.s=s; this.isRect=isRect; }
  update() { this.x+=this.vx; this.y+=this.vy; this.l--; }
  draw() { noStroke(); fill(this.c[0],this.c[1],100,map(this.l,0,this.ml,0,100)); if(this.isRect){ rectMode(CENTER); rect(this.x,this.y,this.s,this.s*1.4); } else { ellipse(this.x,this.y,this.s); } }
}

// ==========================================
// AUDIO
// ==========================================
function setupAudio() {
  sfx.bgDrone = new p5.Oscillator('sine'); sfx.bgDrone.freq(55); sfx.bgDrone.start(); sfx.bgDrone.amp(0);
}
function playSound(t) {
  if (!audioEnabled) return;
  let o = new p5.Oscillator('triangle'), e = new p5.Envelope();
  if (t === 'hit') { o.freq(random(400,600)); e.setADSR(0.001,0.05,0,0.05); } 
  else if (t === 'bash_hit') { o.setType('sawtooth'); o.freq(150); e.setADSR(0.001,0.2,0,0.2); } 
  else if (t === 'score') { o.setType('sine'); o.freq(880); e.setADSR(0.01,0.4,0,0.5); } 
  else if (t === 'wall') { o.freq(200); e.setADSR(0.001,0.05,0,0.05); }
  else if (t === 'select') { o.setType('sine'); o.freq(440); e.setADSR(0.01,0.1,0,0.1); }
  else if (t === 'blip') { o.setType('square'); o.freq(220); e.setADSR(0.001,0.05,0,0.05); }
  else if (t === 'shield_break') { o.setType('sawtooth'); o.freq(200); e.setADSR(0.01,0.1,0,0.3); }
  else if (t === 'freeze') { o.setType('sine'); o.freq(1200); e.setADSR(0.01,0.3,0,0.2); }
  else if (t === 'dash') { o.setType('noise'); e.setADSR(0.01,0.1,0,0.1); }
  else if (t === 'spawn') { o.setType('sine'); o.freq(600); e.setADSR(0.1,0.2,0,0.2); }
  else if (t === 'powerup') { o.setType('square'); o.freq(1200); e.setADSR(0.01,0.1,0,0.1); }
  o.start(); e.play(o); setTimeout(() => o.stop(), 1000);
}
</script>
</body>
</html>
