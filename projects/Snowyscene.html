<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Christmas VR Experience</title>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; }
        #info {
            position: absolute; top: 10px; left: 0; width: 100%;
            text-align: center; color: white; font-family: sans-serif;
            pointer-events: none; text-shadow: 0 0 5px black; z-index: 1;
            background: rgba(0,0,0,0.5); padding: 10px;
        }
        #video-input { display: none; }
    </style>
</head>
<body>
    <div id="info">
        <b>Ultimate Christmas VR</b><br/>
        LEFT Stick: Move | TRIGGER: Grab Snow/Presents/Play TV<br/>
        Stack snowballs to build a snowman!
    </div>
    
    <!-- Hidden input for loading movies -->
    <input type="file" id="video-input" accept="video/*">

    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

        // --- Configuration ---
        const SNOW_COUNT = 5000;
        const SNOW_RANGE = 25;
        
        // --- Globals ---
        let camera, scene, renderer;
        let controller1, controller2;
        let controllerGrip1, controllerGrip2;
        let raycaster;
        let dolly; // The camera rig container
        
        // State
        const snowSystem = { mesh: null, velocities: [] };
        const thrownSnowballs = [];
        const interactableObjects = [];
        const footprints = [];
        let santaGroup;
        let videoElement;

        // Interaction
        const tempMatrix = new THREE.Matrix4();
        const cursor = new THREE.Mesh(
            new THREE.RingGeometry(0.02, 0.04, 32).rotateX(-Math.PI / 2),
            new THREE.MeshBasicMaterial({ color: 0xffff00, opacity: 0.8, transparent: true })
        );

        // Sound Context
        let audioCtx;
        
        init();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020205);
            scene.fog = new THREE.FogExp2(0x020205, 0.015);

            // Setup Camera Rig (Dolly) for movement
            dolly = new THREE.Group();
            dolly.position.set(0, 0, 4);
            scene.add(dolly);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.6, 0);
            dolly.add(camera);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);
            document.body.appendChild(VRButton.createButton(renderer));

            // --- Scene Building ---
            createEnvironment();
            createChristmasLights();
            createSnowSystem();
            createSanta();
            createPresents();
            createMulledWine(2, 0.5, 3);
            createTV(-3, 1.5, -2);
            setupControllers();

            raycaster = new THREE.Raycaster();
            scene.add(cursor);

            window.addEventListener('resize', onWindowResize);
            
            // Video Input Handler
            document.getElementById('video-input').addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    const url = URL.createObjectURL(file);
                    videoElement.src = url;
                    videoElement.play();
                }
            });

            // *** CRITICAL FIX: Start the loop ***
            renderer.setAnimationLoop(render);
        }

        // --- CREATION HELPERS ---

        function createEnvironment() {
            // Ground
            const groundGeo = new THREE.PlaneGeometry(60, 60, 128, 128);
            const pos = groundGeo.attributes.position;
            for(let i=0; i<pos.count; i++){
                pos.setZ(i, Math.sin(pos.getX(i)*0.1)*0.5 + Math.cos(pos.getY(i)*0.1)*0.5);
            }
            groundGeo.computeVertexNormals();
            
            const groundMat = new THREE.MeshStandardMaterial({
                color: 0xffffff, roughness: 0.2, metalness: 0.1
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            ground.name = "ground";
            scene.add(ground);
            interactableObjects.push(ground);

            // Trees
            for(let i=0; i<20; i++) createTree((Math.random()-0.5)*40, (Math.random()-0.5)*40);

            // Lights
            const ambient = new THREE.AmbientLight(0x404060, 0.5);
            scene.add(ambient);
            const moonLight = new THREE.DirectionalLight(0xaaccff, 0.8);
            moonLight.position.set(10, 20, 10);
            moonLight.castShadow = true;
            scene.add(moonLight);
        }

        function createSnowflakeTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            ctx.strokeStyle = 'white'; ctx.lineWidth = 2;
            ctx.translate(16,16);
            for(let i=0; i<6; i++) {
                ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0, 14); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0,6); ctx.lineTo(4, 10); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0,6); ctx.lineTo(-4, 10); ctx.stroke();
                ctx.rotate(Math.PI/3);
            }
            return new THREE.CanvasTexture(canvas);
        }

        function createSnowSystem() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            for (let i = 0; i < SNOW_COUNT; i++) {
                vertices.push((Math.random() - 0.5) * SNOW_RANGE);
                vertices.push(Math.random() * 15);
                vertices.push((Math.random() - 0.5) * SNOW_RANGE);
                snowSystem.velocities.push({
                    y: -(0.02 + Math.random() * 0.03),
                    x: (Math.random() - 0.5) * 0.02,
                    z: (Math.random() - 0.5) * 0.02
                });
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const material = new THREE.PointsMaterial({
                color: 0xffffff, size: 0.1, map: createSnowflakeTexture(),
                transparent: true, opacity: 0.9, depthWrite: false, blending: THREE.AdditiveBlending
            });
            snowSystem.mesh = new THREE.Points(geometry, material);
            scene.add(snowSystem.mesh);
        }

        function createTree(x, z) {
            const group = new THREE.Group();
            group.position.set(x, 0, z);
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.25, 1, 8), new THREE.MeshStandardMaterial({ color: 0x3d2817 }));
            trunk.position.y = 0.5; group.add(trunk);
            const leafMat = new THREE.MeshStandardMaterial({ color: 0x0f5f13 });
            for(let i=0; i<3; i++) {
                const s = 1.5 - (i * 0.4);
                const cone = new THREE.Mesh(new THREE.ConeGeometry(s, 1.5, 8), leafMat);
                cone.position.y = 1.5 + (i * 0.8);
                group.add(cone);
            }
            scene.add(group);
        }

        function createSanta() {
            santaGroup = new THREE.Group();
            const sleigh = new THREE.Mesh(new THREE.BoxGeometry(1, 0.5, 2), new THREE.MeshStandardMaterial({ color: 0xaa0000 }));
            santaGroup.add(sleigh);
            scene.add(santaGroup);
        }

        function createPresents() {
            const geo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            const cols = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00];
            for(let i=0; i<8; i++) {
                const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: cols[i%4] }));
                mesh.position.set((Math.random()-0.5)*15, 0.2, (Math.random()-0.5)*15);
                mesh.name = "present";
                scene.add(mesh);
                interactableObjects.push(mesh);
            }
        }

        function createMulledWine(x, y, z) {
            const cup = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.08, 0.25, 12), new THREE.MeshStandardMaterial({ color: 0x880000 }));
            cup.position.set(x, y, z);
            const liquid = new THREE.Mesh(new THREE.CircleGeometry(0.09, 12), new THREE.MeshStandardMaterial({ color: 0x330000 }));
            liquid.rotation.x = -Math.PI/2; liquid.position.y = 0.12;
            cup.add(liquid);
            scene.add(cup);
        }

        function createTV(x, y, z) {
            videoElement = document.createElement('video');
            videoElement.crossOrigin = "anonymous"; videoElement.loop = true;
            const tex = new THREE.VideoTexture(videoElement);
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(3, 1.7), new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide }));
            mesh.position.set(x, y, z); mesh.lookAt(0, 1.5, 0); mesh.name = "tv";
            scene.add(mesh);
            interactableObjects.push(mesh);
        }

        function createChristmasLights() {
            const points = new THREE.EllipseCurve(0, 0, 5, 5, 0, 6.28, false, 0).getPoints(40);
            points.forEach((p, i) => {
                if(i%2===0) {
                    const c = new THREE.Color().setHSL(Math.random(), 1, 0.5);
                    const b = new THREE.Mesh(new THREE.SphereGeometry(0.05), new THREE.MeshStandardMaterial({ color: c, emissive: c }));
                    b.position.set(p.x, 2.5 + Math.sin(p.x)*0.5, p.y);
                    scene.add(b);
                    const l = new THREE.PointLight(c, 0.5, 3); l.position.copy(b.position); scene.add(l);
                }
            });
        }

        // --- CONTROLLER LOGIC ---
        
        function setupControllers() {
            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('selectstart', onSelectStart);
            controller1.addEventListener('selectend', onSelectEnd);
            dolly.add(controller1);

            controller2 = renderer.xr.getController(1);
            controller2.addEventListener('selectstart', onSelectStart);
            controller2.addEventListener('selectend', onSelectEnd);
            dolly.add(controller2);

            const factory = new XRControllerModelFactory();
            controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(factory.createControllerModel(controllerGrip1));
            dolly.add(controllerGrip1);

            controllerGrip2 = renderer.xr.getControllerGrip(1);
            controllerGrip2.add(factory.createControllerModel(controllerGrip2));
            dolly.add(controllerGrip2);

            // Ray visual
            const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1)]));
            line.name = 'line'; line.scale.z = 5;
            controller1.add(line.clone()); controller2.add(line.clone());
        }

        const controllerData = { 0: { obj: null, hist: [] }, 1: { obj: null, hist: [] } };

        function onSelectStart(event) {
            const c = event.target;
            const idx = c === controller1 ? 0 : 1;
            
            tempMatrix.identity().extractRotation(c.matrixWorld);
            raycaster.ray.origin.setFromMatrixPosition(c.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
            
            const hits = raycaster.intersectObjects(interactableObjects);
            if (hits.length > 0) {
                const hit = hits[0].object;
                if(hit.name === "tv") { playJingle(); document.getElementById('video-input').click(); return; }
                if(hit.name === "present") { 
                    playJingle(); 
                    scene.remove(hit); 
                    interactableObjects.splice(interactableObjects.indexOf(hit), 1);
                    return; 
                }
            }

            // Spawn Snowball
            const sb = new THREE.Mesh(new THREE.SphereGeometry(0.1, 16, 16), new THREE.MeshStandardMaterial({ color: 0xffffff }));
            c.add(sb);
            controllerData[idx].obj = sb;
            controllerData[idx].hist = [];
        }

        function onSelectEnd(event) {
            const c = event.target;
            const idx = c === controller1 ? 0 : 1;
            const data = controllerData[idx];

            if (data.obj) {
                const sb = data.obj;
                const pos = new THREE.Vector3(); sb.getWorldPosition(pos);
                c.remove(sb); scene.add(sb); sb.position.copy(pos);

                let vel = new THREE.Vector3(0,0,-1).applyQuaternion(c.quaternion).multiplyScalar(5);
                if (data.hist.length >= 2) {
                    const last = data.hist[data.hist.length-1];
                    const prev = data.hist[0];
                    vel.subVectors(last.p, prev.p).multiplyScalar(1000 / (last.t - prev.t));
                }
                thrownSnowballs.push({ mesh: sb, vel: vel, active: true });
                interactableObjects.push(sb); // Make it hittable
                sb.name = "snowball";
                data.obj = null;
            }
        }

        function playJingle() {
            if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const now = audioCtx.currentTime;
            [659, 659, 659].forEach((f, i) => {
                const osc = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                osc.frequency.value = f;
                g.gain.setValueAtTime(0.1, now + i*0.2);
                g.gain.exponentialRampToValueAtTime(0.001, now + i*0.2 + 0.15);
                osc.connect(g); g.connect(audioCtx.destination);
                osc.start(now + i*0.2); osc.stop(now + i*0.2 + 0.2);
            });
        }

        function handleMovement(dt) {
            const s = renderer.xr.getSession();
            if(!s) return;
            for(const src of s.inputSources) {
                if(src.handedness === 'left' && src.gamepad) {
                    const axes = src.gamepad.axes;
                    if(axes.length >= 4) {
                        const x = axes[2], z = axes[3];
                        if(Math.abs(x)>0.1 || Math.abs(z)>0.1) {
                            const speed = 3 * dt;
                            const dir = new THREE.Vector3(); camera.getWorldDirection(dir); dir.y=0; dir.normalize();
                            const right = new THREE.Vector3().crossVectors(dir, new THREE.Vector3(0,1,0));
                            dolly.position.addScaledVector(right, x * speed).addScaledVector(dir, z * speed);
                            createFootprint();
                        }
                    }
                }
            }
        }

        let lastFootprint = 0;
        function createFootprint() {
            if(Date.now() - lastFootprint > 300) {
                const fp = new THREE.Mesh(new THREE.CircleGeometry(0.1,8), new THREE.MeshBasicMaterial({color:0xddddff, transparent:true, opacity:0.3}));
                fp.rotation.x = -Math.PI/2; 
                fp.position.copy(dolly.position).add(camera.position); 
                fp.position.y = 0.02;
                scene.add(fp);
                footprints.push({mesh:fp, age:0});
                lastFootprint = Date.now();
            }
        }

        function updatePhysics(dt) {
            // Santa
            if(santaGroup) {
                const t = Date.now() * 0.0005;
                santaGroup.position.set(Math.cos(t)*20, 15+Math.sin(t*2)*2, Math.sin(t)*20);
                santaGroup.lookAt(0,15,0);
            }

            // Snowballs
            for(const obj of thrownSnowballs) {
                if(!obj.active) continue;
                obj.vel.y -= 9.8 * dt;
                obj.mesh.position.addScaledVector(obj.vel, dt);
                
                // Stack collision (Simplified: check distance to other inactive snowballs)
                for(const other of thrownSnowballs) {
                    if(other === obj || other.active) continue;
                    if(obj.mesh.position.distanceTo(other.mesh.position) < 0.18) {
                        obj.active = false; // Stick to other ball
                        obj.vel.set(0,0,0);
                        break;
                    }
                }

                // Ground collision
                const gy = Math.sin(obj.mesh.position.x*0.1)*0.5 + Math.cos(obj.mesh.position.z*0.1)*0.5;
                if(obj.mesh.position.y < gy + 0.1) {
                    obj.mesh.position.y = gy + 0.1;
                    obj.active = false;
                    obj.vel.set(0,0,0);
                }
            }
        }

        const clock = new THREE.Clock();
        function render() {
            const dt = clock.getDelta();
            handleMovement(dt);
            updatePhysics(dt);

            // Snow animation
            if(snowSystem.mesh) {
                const pos = snowSystem.mesh.geometry.attributes.position.array;
                for(let i=0; i<SNOW_COUNT; i++) {
                    pos[i*3+1] += snowSystem.velocities[i].y;
                    if(pos[i*3+1] < 0) pos[i*3+1] = 15;
                }
                snowSystem.mesh.geometry.attributes.position.needsUpdate = true;
            }

            // Footprint fade
            for(let i=footprints.length-1; i>=0; i--) {
                footprints[i].age += dt;
                footprints[i].mesh.material.opacity = 0.3 - footprints[i].age * 0.1;
                if(footprints[i].age > 3) { scene.remove(footprints[i].mesh); footprints.splice(i,1); }
            }

            // Controllers
            [controller1, controller2].forEach((c, i) => {
                if(controllerData[i].obj) {
                    controllerData[i].hist.push({p:c.position.clone(), t:performance.now()});
                    if(controllerData[i].hist.length>5) controllerData[i].hist.shift();
                }
                // Ray visual update
                tempMatrix.identity().extractRotation(c.matrixWorld);
                raycaster.ray.origin.setFromMatrixPosition(c.matrixWorld);
                raycaster.ray.direction.set(0,0,-1).applyMatrix4(tempMatrix);
                const hits = raycaster.intersectObjects(interactableObjects);
                const line = c.children.find(o=>o.name==='line');
                if(hits.length>0) {
                    line.scale.z = hits[0].distance;
                    cursor.visible = true; cursor.position.copy(hits[0].point);
                } else {
                    line.scale.z = 5; cursor.visible = false;
                }
            });

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>