<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unstoppable Chaos Pendulum</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
            user-select: none;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
            max-width: 320px;
        }
        #kick-msg {
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            color: #ff4444;
            font-size: 2em;
            font-weight: bold;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(255,0,0,0.5);
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            display: none;
        }
        #loader {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #4fa;
            z-index: 999;
            transition: opacity 0.5s;
            font-family: monospace;
            font-size: 1.5em;
        }
        .prologue-overlay {
            position: fixed;
            inset: 0;
            background: radial-gradient(circle at 30% 20%, rgba(102, 224, 255, 0.08), rgba(0, 0, 0, 0.9)), #03060d;
            color: #e7f8ff;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            padding: 4vh 8vw;
            gap: 1.5rem;
            letter-spacing: 0.02em;
            overflow: hidden;
            animation: prologue-fade-in 1.1s ease forwards;
            pointer-events: auto;
        }
        .prologue-title {
            font-size: clamp(1.6rem, 3vw, 2.2rem);
            text-transform: uppercase;
            letter-spacing: 0.18em;
            font-weight: 700;
            text-align: center;
            color: #66e0ff;
            margin: 0;
            transition: transform 0.8s ease, opacity 0.8s ease;
        }
        .prologue-window {
            max-width: 820px;
            width: 100%;
            height: 55vh;
            max-height: 620px;
            overflow: hidden;
            position: relative;
            mask-image: linear-gradient(transparent 0%, #000 14%, #000 86%, transparent 100%);
            -webkit-mask-image: linear-gradient(transparent 0%, #000 14%, #000 86%, transparent 100%);
        }
        .prologue-scroll {
            font-size: clamp(1rem, 2.2vw, 1.2rem);
            line-height: 1.8;
            text-align: justify;
            text-shadow: 0 0 12px rgba(0, 150, 220, 0.18);
            position: absolute;
            inset: 0;
            will-change: transform;
        }
        .prologue-scroll p { margin: 0 0 1.4rem; }
        .prologue-hint {
            font-size: 0.9rem;
            opacity: 0.7;
            text-align: center;
            letter-spacing: 0.08em;
        }
        .prologue-overlay.prologue-fade {
            opacity: 0;
            transition: opacity 0.9s ease;
            pointer-events: none;
        }
        .prologue-overlay.prologue-fade .prologue-title {
            transform: translateY(-50px);
            opacity: 0;
        }
        @keyframes prologue-crawl {
            0% { transform: translate3d(0, 65vh, 0); }
            100% { transform: translate3d(0, -140vh, 0); }
        }
        @keyframes prologue-fade-in {
            from { opacity: 0; }
            to { opacity: 1; }
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js",
                "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>
</head>
<body>
    <div class="prologue-overlay">
        <h1 class="prologue-title">The Demise of the Bongs</h1>
        <div class="prologue-window">
            <div class="prologue-scroll">
                <p>In a derelict megacity research lane, an abandoned gravity experiment was built to harvest kinetic energy through a relentless double pendulum.</p>
                <p>Bio-Organic Newtonian Gatherers (The Bongs) still happily patrol, unaware that their creators have long since moved away from this avenue of research, deeming it an unpopular political advantage, and, of the pendulum’s imminent overload.</p>
                <p>An impact with the pendulum reduces the Bongs into chunks, but, if these chunks manage to remain on the charging strip, they sometimes reboot as sentient “survivor” Bongs, eyeing the path and shuffling forward, less efficient but, still dedicated to their futile cause.</p>
                <p>You step into VR as an observer, watching the experiment burn in endless motion, witnessing unquestioning devotion, unable to stop the inevitable extinction of this lifeform.</p>
                <p></p>
                <p>And you are smiling!</p>
            </div>
        </div>
        <div class="prologue-hint">Prologue will end automatically. Click or tap to skip.</div>
    </div>
    <div id="loader">CALCULATING MASS RATIOS...</div>
    <div id="kick-msg">ENERGY INJECTION!</div>
    <div id="info">
        <strong style="font-size:1.2em; color:#4fa">Unstoppable Chaos</strong><br>
        <div style="margin-top:5px; font-size:0.9em; color:#ccc;">
            - <strong>Low Resistance:</strong> Bobs are 100x denser than before.<br>
            - <strong>Auto-Kick:</strong> System injects energy if motion stops.<br>
            - <strong>Physics:</strong> Zero friction on impacts.<br>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import * as CANNON from 'cannon-es';
        import { GUI } from 'lil-gui';

        // --- Configuration ---
        const params = {
            timeScale: 1.0,
            gravity: -9.81,
            
            // Auto Kick Settings
            enableAutoKick: false,
            minSpeedThreshold: 3.0, // If combined speed is lower than this...
            kickForce: 500, // Amount of force to inject

            // Physics Properties
            pivotHeight: 7.55,
            materialDensity: 100, 
            startAngleDeg: 25,
            
            // Rod 1 (Upper)
            rod1Length: 3.5,
            rod1Radius: 0.15,
            bob1Size: 0.8, 
            // Rod 2 (Lower)
            rod2Length: 3.5,
            rod2Radius: 0.15,
            bob2Size: 0.4284, 

            bobMaterial: 'Gold',

            // Pedestrians
            spawnPedestrians: true,
            spawnRate: 113.62,
            walkSpeed: 3.968,
            meepleMass: 8,
            separationForce: 5.688,
            maxPedestrians: 49,
            maxRagdolls: 40,
            ragdollLife: 5,
            pathVisible: true,
            pathWidth: 8,
            pathLength: 300,
            spawnDistance: 105.04,
            despawnDistance: 105.6,

            kickCooldown: 2000,
            pendulumDamping: 0.001,
            pendulumAngularDamping: 0.001,

            // Skybox controls
            skyboxOffsetY: -32.4,
            skyboxRotationX: 16.2,
            skyboxRotationY: -45.72,
            skyboxRotationZ: -180,
            skyboxScale: 3,

            // VR rig offset along path (Z)
            vrPathOffsetZ: 30,

            reset: () => { createFloor(); createPath(); createPendulumSystem(); }
        };

        const GROUP_FLOOR = 1; 
        const GROUP_PENDULUM = 2;
        const GROUP_PEDESTRIAN = 4;
        const GROUP_RAGDOLL = 8;

        // Globals
        let scene, camera, renderer, controls, xrRig;
        let controller1, controller2, controllerGrip1, controllerGrip2;
        let world;
        let physicsObjects = [];
        let pendulumBodies = []; // bobs for collisions
        let pendulumParts = [];
        let constraints = [];
        let pedestrians = []; 
        let ragdolls = [];    
        let spawnAccumulator = 0;
        let lastKickTime = 0;
        let clock;
        let accumulator = 0;
        const fixedTimeStep = 1 / 60;
        const maxSubSteps = 5;
        
        let cannonMaterials = {};
        let threeMaterials = {};
        let pathPieces = [];
        let floorMesh = null;
        let floorBody = null;
        let groundHeight = 0;
        let cityScene = null;
        
        let raycaster, mouse, mouseConstraint, mouseBody;
        let dragState = null; // { part: 'bob1'|'bob2', plane: THREE.Plane }
        let skyDome = null;
        let skyboxScene = null;
        let pendStateRK4 = null;
        let prevBobPositionsRK4 = [];
        let experienceStarted = false;
        let prologueMusicTimeout = null;

        // --- Audio ---
        const audioState = {
            ctx: null,
            buffers: { prologue: null, main: null },
            sources: { prologue: null, main: null },
            pending: { prologue: false, main: false },
            gains: { main: null }
        };
        let audioPrepared = false;

        function getAudioContext() {
            if(!audioState.ctx) {
                audioState.ctx = new (window.AudioContext || window.webkitAudioContext)();
            }
            return audioState.ctx;
        }

        async function preloadTrack(key, url) {
            if(audioState.buffers[key]) return audioState.buffers[key];
            const ctx = getAudioContext();
            const res = await fetch(url);
            const buf = await res.arrayBuffer();
            audioState.buffers[key] = await ctx.decodeAudioData(buf);
            return audioState.buffers[key];
        }

        function prepareAudio() {
            if(audioPrepared) return;
            audioPrepared = true;
            preloadTrack('prologue', 'Prologue.mp3').catch(err => console.warn('Prologue preload failed', err));
            preloadTrack('main', 'Main.wav').catch(err => console.warn('Main preload failed', err));

            const unlock = () => {
                const ctx = getAudioContext();
                if(ctx.state === 'suspended') ctx.resume();
                if(audioState.pending.prologue) {
                    audioState.pending.prologue = false;
                    playPrologueTrack();
                }
                if(audioState.pending.main) {
                    audioState.pending.main = false;
                    startMainLoop();
                }
            };
            ['pointerdown', 'touchstart', 'keydown'].forEach(evt => {
                window.addEventListener(evt, unlock, { once: true });
            });
        }

        async function playPrologueTrack() {
            if(audioState.sources.prologue) return;
            try {
                const ctx = getAudioContext();
                if(ctx.state === 'suspended') {
                    audioState.pending.prologue = true;
                    return;
                }
                const buffer = await preloadTrack('prologue', 'Prologue.mp3');
                const gain = ctx.createGain();
                gain.gain.setValueAtTime(0.9, ctx.currentTime);
                const source = ctx.createBufferSource();
                source.buffer = buffer;
                source.connect(gain).connect(ctx.destination);
                source.start();
                audioState.sources.prologue = source;
                source.addEventListener('ended', () => {
                    audioState.sources.prologue = null;
                }, { once: true });
            } catch(err) {
                console.warn('Failed to play prologue track', err);
            }
        }

        function stopPrologueTrack() {
            const src = audioState.sources.prologue;
            if(src) {
                try { src.stop(); } catch(e) {}
            }
            audioState.sources.prologue = null;
            audioState.pending.prologue = false;
        }

        async function startMainLoop() {
            if(audioState.sources.main) return;
            try {
                const ctx = getAudioContext();
                if(ctx.state === 'suspended') {
                    audioState.pending.main = true;
                    return;
                }
                const buffer = await preloadTrack('main', 'Main.wav');
                const gain = ctx.createGain();
                gain.gain.setValueAtTime(0.85, ctx.currentTime);
                const source = ctx.createBufferSource();
                source.buffer = buffer;
                source.loop = true;
                source.loopStart = 0;
                source.loopEnd = buffer.duration;
                source.connect(gain).connect(ctx.destination);
                source.start();
                audioState.sources.main = source;
                audioState.gains.main = gain;
            } catch(err) {
                console.warn('Failed to start main loop', err);
            }
        }

        function stopMainLoop() {
            const src = audioState.sources.main;
            if(src) {
                try { src.stop(); } catch(e) {}
            }
            audioState.sources.main = null;
            audioState.pending.main = false;
            audioState.gains.main = null;
        }

        // --- Analytic double pendulum (planar, RK4) ---
        function resetPendulumState() {
            const th = THREE.MathUtils.degToRad(params.startAngleDeg);
            pendStateRK4 = {
                theta1: th,
                theta2: th * 0.9,
                omega1: 0,
                omega2: 0
            };
            prevBobPositionsRK4 = [];
        }

        function pendulumDerivatives(state) {
            const { theta1, theta2, omega1, omega2 } = state;
            const m1 = calculateUnstoppableMass(params.bob1Size, params.materialDensity);
            const m2 = calculateUnstoppableMass(params.bob2Size, params.materialDensity);
            const L1 = params.rod1Length;
            const L2 = params.rod2Length;
            const g = Math.abs(params.gravity);

            // Standard planar double-pendulum equations (angles from vertical)
            const delta = theta1 - theta2;
            const sinD = Math.sin(delta);
            const cosD = Math.cos(delta);

            const denom = 2 * m1 + m2 - m2 * Math.cos(2 * delta);

            const domega1 = (
                -g * (2 * m1 + m2) * Math.sin(theta1)
                - m2 * g * Math.sin(theta1 - 2 * theta2)
                - 2 * m2 * sinD * (omega2 * omega2 * L2 + omega1 * omega1 * L1 * cosD)
            ) / (L1 * denom);

            const domega2 = (
                2 * sinD * (
                    omega1 * omega1 * L1 * (m1 + m2)
                    + g * (m1 + m2) * Math.cos(theta1)
                    + omega2 * omega2 * L2 * m2 * cosD
                )
            ) / (L2 * denom);

            return { dtheta1: omega1, dtheta2: omega2, domega1, domega2 };
        }

        function rk4Step(state, dt) {
            const k1 = pendulumDerivatives(state);
            const s2 = {
                theta1: state.theta1 + k1.dtheta1 * dt * 0.5,
                theta2: state.theta2 + k1.dtheta2 * dt * 0.5,
                omega1: state.omega1 + k1.domega1 * dt * 0.5,
                omega2: state.omega2 + k1.domega2 * dt * 0.5
            };
            const k2 = pendulumDerivatives(s2);
            const s3 = {
                theta1: state.theta1 + k2.dtheta1 * dt * 0.5,
                theta2: state.theta2 + k2.dtheta2 * dt * 0.5,
                omega1: state.omega1 + k2.domega1 * dt * 0.5,
                omega2: state.omega2 + k2.domega2 * dt * 0.5
            };
            const k3 = pendulumDerivatives(s3);
            const s4 = {
                theta1: state.theta1 + k3.dtheta1 * dt,
                theta2: state.theta2 + k3.dtheta2 * dt,
                omega1: state.omega1 + k3.domega1 * dt,
                omega2: state.omega2 + k3.domega2 * dt
            };
            const k4 = pendulumDerivatives(s4);

            return {
                theta1: state.theta1 + (dt / 6) * (k1.dtheta1 + 2 * k2.dtheta1 + 2 * k3.dtheta1 + k4.dtheta1),
                theta2: state.theta2 + (dt / 6) * (k1.dtheta2 + 2 * k2.dtheta2 + 2 * k3.dtheta2 + k4.dtheta2),
                omega1: state.omega1 + (dt / 6) * (k1.domega1 + 2 * k2.domega1 + 2 * k3.domega1 + k4.domega1),
                omega2: state.omega2 + (dt / 6) * (k1.domega2 + 2 * k2.domega2 + 2 * k3.domega2 + k4.domega2)
            };
        }

        function updatePendulum(dt) {
            if(!pendStateRK4) resetPendulumState();
            pendStateRK4 = rk4Step(pendStateRK4, dt);

            const L1 = params.rod1Length;
            const L2 = params.rod2Length;
            const pivot = new THREE.Vector3(0, groundHeight + params.pivotHeight, 0);

            // positions in XY plane, z=0
            const x1 = L1 * Math.sin(pendStateRK4.theta1);
            const y1 = -L1 * Math.cos(pendStateRK4.theta1);
            const x2 = x1 + L2 * Math.sin(pendStateRK4.theta2);
            const y2 = y1 - L2 * Math.cos(pendStateRK4.theta2);

            const bob1Pos = new THREE.Vector3(pivot.x + x1, pivot.y + y1, 0);
            const bob2Pos = new THREE.Vector3(pivot.x + x2, pivot.y + y2, 0);

            // velocities in plane (derivative of positions)
            const vx1 = L1 * pendStateRK4.omega1 * Math.cos(pendStateRK4.theta1);
            const vy1 = L1 * pendStateRK4.omega1 * Math.sin(pendStateRK4.theta1);
            const vx2 = vx1 + L2 * pendStateRK4.omega2 * Math.cos(pendStateRK4.theta2);
            const vy2 = vy1 + L2 * pendStateRK4.omega2 * Math.sin(pendStateRK4.theta2);

            // Handle lower bob vs path/floor bounce/stop
            const floorY = groundHeight;
            const bob2Radius = params.bob2Size;
            const pen = (bob2Pos.y - bob2Radius) - floorY;
            if(pen <= 0 && vy2 < 0) {
                const bounceProfile = (() => {
                    switch(params.bobMaterial) {
                        case 'Gold': return { e: 0.0, damp: 0.2 };
                        case 'Steel': return { e: 0.1, damp: 0.35 };
                        case 'Wood': return { e: 0.25, damp: 0.6 };
                        case 'Rubber': return { e: 0.9, damp: 1.0 };
                        case 'Neon': return { e: 0.5, damp: 0.8 };
                        default: return { e: 0.2, damp: 0.5 };
                    }
                })();

                const vDesiredX = vx2; // keep tangential the same
                const vDesiredY = -vy2 * bounceProfile.e;

                const a11 = L1 * Math.cos(pendStateRK4.theta1);
                const a12 = L2 * Math.cos(pendStateRK4.theta2);
                const a21 = L1 * Math.sin(pendStateRK4.theta1);
                const a22 = L2 * Math.sin(pendStateRK4.theta2);
                const det = a11 * a22 - a12 * a21;
                if(Math.abs(det) > 1e-6) {
                    const invDet = 1 / det;
                    let newOmega1 = ( vDesiredX * a22 - a12 * vDesiredY) * invDet;
                    let newOmega2 = (-vDesiredX * a21 + a11 * vDesiredY) * invDet;

                    newOmega1 *= bounceProfile.damp;
                    newOmega2 *= bounceProfile.damp;

                    pendStateRK4.omega1 = newOmega1;
                    pendStateRK4.omega2 = newOmega2;

                    // clamp to floor
                    bob2Pos.y = floorY + bob2Radius;
                    prevBobPositionsRK4 = [];
                }
            }

            // orientations (rotation about Z)
            const q1 = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), pendStateRK4.theta1);
            const q2 = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), pendStateRK4.theta2);

            // update visuals (place rod groups only; children stay in local space)
            const rod1 = pendulumParts.find(p => p.name === 'rod1');
            const rod2 = pendulumParts.find(p => p.name === 'rod2');

            if(rod1) {
                rod1.mesh.position.copy(pivot);
                rod1.mesh.quaternion.copy(q1);
            }
            if(rod2) {
                rod2.mesh.position.copy(bob1Pos);
                rod2.mesh.quaternion.copy(q2);
            }

            // update physics bodies (kinematic)
            const bobPositions = [bob1Pos, bob2Pos];
            pendulumBodies.forEach((b, i) => {
                const pos = bobPositions[i];
                if(prevBobPositionsRK4[i]) {
                    const vel = pos.clone().sub(prevBobPositionsRK4[i]).multiplyScalar(1 / Math.max(dt, 1e-4));
                    b.velocity.set(vel.x, vel.y, vel.z);
                }
                b.position.set(pos.x, pos.y, pos.z);
                b.quaternion.set(0,0,0,1);
                b.angularVelocity.set(0,0,0);
            });
            prevBobPositionsRK4 = bobPositions;
        }

        function disposeMaterialResource(mat) {
            if(!mat) return;
            if(Array.isArray(mat)) { mat.forEach(disposeMaterialResource); return; }
            if(mat.map) mat.map.dispose?.();
            mat.dispose?.();
        }

        function disposeObject(obj, { disposeMaterial: doMat = true, disposeGeometry: doGeo = true } = {}) {
            if(!obj) return;
            obj.traverse(child => {
                if(doGeo && child.geometry) child.geometry.dispose?.();
                if(doMat && child.material) disposeMaterialResource(child.material);
            });
        }

        // Guard against NaN/Infinity creeping into physics vectors
        function ensureFiniteVec3(vec, fallback = 0, axisFallbacks = null) {
            const fx = axisFallbacks?.x ?? fallback;
            const fy = axisFallbacks?.y ?? fallback;
            const fz = axisFallbacks?.z ?? fallback;
            if(!Number.isFinite(vec.x)) vec.x = fx;
            if(!Number.isFinite(vec.y)) vec.y = fy;
            if(!Number.isFinite(vec.z)) vec.z = fz;
            return vec;
        }

        function squishMesh(mesh, impactNormal = new THREE.Vector3(0,1,0), severity = 1) {
            if(!mesh) return;
            if(mesh.userData.squishTimer) {
                clearTimeout(mesh.userData.squishTimer);
                mesh.userData.squishTimer = null;
            }
            const n = new THREE.Vector3(impactNormal.x, impactNormal.y, impactNormal.z).normalize();
            const amp = THREE.MathUtils.clamp(0.15 + severity * 0.2, 0.15, 0.8);
            const flatten = 1 - amp;
            const stretch = 1 + amp * 0.85;

            // Apply local squash/stretch aligned to world up (approx), and nudge along impact normal
            const origScale = mesh.scale.clone();
            const origPos = mesh.position.clone();
            mesh.scale.set(origScale.x * stretch, origScale.y * flatten, origScale.z * stretch);
            mesh.position.addScaledVector(n, -amp * 0.2);

            mesh.userData.squishTimer = setTimeout(() => {
                mesh.scale.copy(origScale);
                mesh.position.copy(origPos);
                mesh.userData.squishTimer = null;
            }, 220);
        }

        function addEyes(mesh, radius) {
            if(!mesh) return;
            if(mesh.userData.eyes) {
                mesh.remove(mesh.userData.eyes);
                mesh.userData.eyes = null;
            }
            const eyeGroup = new THREE.Group();
            const eyeR = Math.max(radius * 0.2, 0.08);
            const pupilR = eyeR * 0.6;
            const eyeMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2, metalness: 0.05, emissive: 0xffffff, emissiveIntensity: 0.4 });
            const pupilMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.8, metalness: 0.1 });
            const eyeGeom = new THREE.SphereGeometry(eyeR, 12, 12);
            const pupilGeom = new THREE.SphereGeometry(pupilR, 12, 12);
            const offsetY = radius * 0.25;
            const offsetZ = radius * 1.05; // push outside the blob
            const spreadX = radius * 0.32;
            [ -spreadX, spreadX ].forEach(x => {
                const eye = new THREE.Mesh(eyeGeom, eyeMat);
                eye.position.set(x, offsetY, offsetZ);
                const pupil = new THREE.Mesh(pupilGeom, pupilMat);
                pupil.position.set(0, 0, eyeR * 0.65);
                eye.add(pupil);
                eyeGroup.add(eye);
            });

            // simple mouth
            const mouthGeom = new THREE.RingGeometry(Math.max(radius * 0.08, 0.04), Math.max(radius * 0.14, 0.07), 16);
            const mouthMat = new THREE.MeshStandardMaterial({ color: 0x111111, emissive: 0x111111, emissiveIntensity: 0.25, side: THREE.DoubleSide });
            const mouth = new THREE.Mesh(mouthGeom, mouthMat);
            mouth.rotation.x = Math.PI / 2;
            mouth.position.set(0, radius * 0.05, radius * 1.02);
            eyeGroup.add(mouth);

            eyeGroup.renderOrder = 2;
            mesh.add(eyeGroup);
            mesh.userData.eyes = eyeGroup;
        }

        prepareAudio();
        setupPrologue();

        function setupPrologue() {
            const overlay = document.querySelector('.prologue-overlay');
            const info = document.getElementById('info');
            if (info) {
                info.style.opacity = 0;
                info.style.transition = 'opacity 1s ease';
            }
            if (!overlay) {
                startExperience();
                return;
            }
            if(prologueMusicTimeout) clearTimeout(prologueMusicTimeout);
            prologueMusicTimeout = setTimeout(() => {
                if(!experienceStarted) playPrologueTrack();
            }, 5000);
            const crawl = overlay.querySelector('.prologue-scroll');
            const windowEl = overlay.querySelector('.prologue-window');
            overlay.addEventListener('click', startExperience);

            if (crawl && windowEl) {
                // Compute a slower crawl speed based on text height and viewport
                const startY = windowEl.clientHeight * 1.05; // start just below the window
                const endY = -(crawl.scrollHeight + windowEl.clientHeight * 0.15);
                const distance = Math.max(10, startY - endY);
                const pixelsPerSecond = 20; // tuned slower crawl
                const duration = distance / pixelsPerSecond * 1000;

                crawl.style.transform = `translate3d(0, ${startY}px, 0)`;
                const anim = crawl.animate(
                    [
                        { transform: `translate3d(0, ${startY}px, 0)` },
                        { transform: `translate3d(0, ${endY}px, 0)` }
                    ],
                    { duration, easing: 'linear', fill: 'forwards' }
                );
                anim.addEventListener('finish', startExperience, { once: true });

                // Safety net in case animation is interrupted
                setTimeout(startExperience, duration + 5000);
            } else {
                setTimeout(startExperience, 5000);
            }
        }

        function startExperience() {
            if (experienceStarted) return;
            experienceStarted = true;
            if(prologueMusicTimeout) {
                clearTimeout(prologueMusicTimeout);
                prologueMusicTimeout = null;
            }
            const overlay = document.querySelector('.prologue-overlay');
            getAudioContext().resume?.();
            stopPrologueTrack();
            startMainLoop();
            if (overlay) {
                overlay.classList.add('prologue-fade');
                setTimeout(() => overlay.remove(), 950);
            }
            const loader = document.getElementById('loader');
            if (loader) loader.style.opacity = 1;
            init();
            fadeInScene();
        }

        function fadeInScene() {
            requestAnimationFrame(() => {
                const canvas = renderer?.domElement;
                if (canvas) {
                    canvas.style.opacity = 1;
                }
                const info = document.getElementById('info');
                const kick = document.getElementById('kick-msg');
                [info, kick].forEach(el => {
                    if (el) {
                        if (!el.style.transition) el.style.transition = 'opacity 1s ease';
                        el.style.opacity = 1;
                    }
                });
            });
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x202530);
            scene.fog = new THREE.FogExp2(0x202530, 0.008);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            xrRig = new THREE.Group();
            xrRig.add(camera);
            scene.add(xrRig);
            camera.position.set(0, 2, 22);
            setupControllers();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.xr.enabled = true;
            renderer.xr.addEventListener('sessionstart', () => {
                camera.position.set(0, 0, 0);
                camera.rotation.set(0, 0, 0);
                xrRig.position.set(0, 0, params.vrPathOffsetZ);
                xrRig.rotation.set(0, 0, 0);
                updateControllerVisibility(true);
            });
            renderer.xr.addEventListener('sessionend', () => {
                xrRig.position.set(0, 0, 0);
                xrRig.rotation.set(0, 0, 0);
                updateControllerVisibility(false);
            });
            document.body.appendChild(renderer.domElement);
            renderer.domElement.style.opacity = 0;
            renderer.domElement.style.transition = 'opacity 1.2s ease';
            document.body.appendChild(VRButton.createButton(renderer));
            clock = new THREE.Clock();

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 4, 0);
            controls.enableDamping = true;
            controls.enablePan = true;
            controls.enableRotate = true;
            controls.update();

            const ambient = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambient);
            const sun = new THREE.DirectionalLight(0xffffff, 2.0);
            sun.position.set(15, 25, 15);
            sun.castShadow = true;
            sun.shadow.mapSize.set(2048, 2048);
            scene.add(sun);

            // Physics Setup
            world = new CANNON.World();
            world.gravity.set(0, params.gravity, 0);
            world.broadphase = new CANNON.SAPBroadphase(world);
            world.solver.iterations = 50; // High iterations for stable heavy masses
            world.solver.tolerance = 1e-5;

            initMaterials();
            createFloor();
            createPath();
            createPendulumSystem();
            loadSkybox();
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            setupInteraction();
            setupGUI();
            // Start with GUI collapsed
            // (folders also closed individually in setupGUI)
            // gui instance is inside setupGUI, so collapsing happens there.

            document.getElementById('loader').style.opacity = 0;
            setTimeout(() => document.getElementById('loader').remove(), 500);
            renderer.setAnimationLoop(animate);

            window.addEventListener('resize', onWindowResize);
        }

        function initMaterials() {
            cannonMaterials.default = new CANNON.Material('default');
            cannonMaterials.ground = new CANNON.Material('ground');
            cannonMaterials.pedestrian = new CANNON.Material('pedestrian');
            cannonMaterials.ragdoll = new CANNON.Material('ragdoll');

            const register = (m1, m2, opts) => world.addContactMaterial(new CANNON.ContactMaterial(m1, m2, opts));
            
            register(cannonMaterials.ground, cannonMaterials.default, { friction: 0.5, restitution: 0.2 });
            register(cannonMaterials.ground, cannonMaterials.pedestrian, { friction: 0.0, restitution: 0.3 });
            register(cannonMaterials.ground, cannonMaterials.ragdoll, { friction: 0.35, restitution: 0.45 });
            
            // --- CRITICAL CONFIGURATION ---
            // Pendulum vs Pedestrian
            // friction: 0.0 -> Meeple cannot "grab" the bob. It slips right off.
            // restitution: 0.8 -> High bounce. Meeple flies away, preserving Bob's energy.
            register(cannonMaterials.default, cannonMaterials.pedestrian, { friction: 0.0, restitution: 0.95, contactEquationStiffness: 1e8, contactEquationRelaxation: 2 });
            
            register(cannonMaterials.default, cannonMaterials.ragdoll, { friction: 0.0, restitution: 0.92, contactEquationStiffness: 1e7, contactEquationRelaxation: 2 });
            
            threeMaterials.pole = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.5 });
            threeMaterials.joint = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.2, metalness: 0.8 });
            updateBobMaterial(); 
        }

        function updateBobMaterial() {
            const oldBob = threeMaterials.bob;
            const oldRod = threeMaterials.rod;

            let color, metalness, roughness;
            switch(params.bobMaterial) {
                case 'Steel': color = 0xcccccc; metalness = 0.9; roughness = 0.2; break;
                case 'Gold': color = 0xffaa00; metalness = 1.0; roughness = 0.1; break;
                case 'Wood': color = 0x8B4513; metalness = 0.0; roughness = 0.8; break;
                case 'Rubber': color = 0x111111; metalness = 0.1; roughness = 0.9; break;
                case 'Neon': color = 0x00ffcc; metalness = 0.5; roughness = 0.2; break;
            }

            threeMaterials.bob = new THREE.MeshStandardMaterial({ color: color, metalness: metalness, roughness: roughness });
            threeMaterials.rod = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.5, roughness: 0.5 });

            physicsObjects.forEach(obj => {
                if(obj.type === 'bob') obj.mesh.material = threeMaterials.bob;
                if(obj.type === 'rod') obj.mesh.material = threeMaterials.rod;
            });

            if(oldBob && oldBob !== threeMaterials.bob) disposeMaterialResource(oldBob);
            if(oldRod && oldRod !== threeMaterials.rod) disposeMaterialResource(oldRod);
        }

        function createFloor() {
            if(floorMesh) {
                scene.remove(floorMesh);
                disposeObject(floorMesh);
                floorMesh = null;
            }
            if(floorBody) {
                world.removeBody(floorBody);
                floorBody = null;
            }

            const halfW = params.pathWidth / 2;
            const halfL = Math.max(params.pathLength / 2, params.spawnDistance + 2);
            const halfH = 0.25;

            // Narrow collider matching the path only; outside this, actors fall.
            floorBody = new CANNON.Body({ mass: 0, material: cannonMaterials.ground, collisionFilterGroup: GROUP_FLOOR });
            floorBody.addShape(new CANNON.Box(new CANNON.Vec3(halfW, halfH, halfL)));
            floorBody.position.set(0, groundHeight - halfH, 0);
            world.addBody(floorBody);
        }

        async function loadCityRuins() {
            const loader = new GLTFLoader();
            loader.register(() => {
                return {
                    name: 'KHR_materials_pbrSpecularGlossiness',
                    beforeRoot() {},
                    afterRoot() {}
                };
            });
            return new Promise((resolve, reject) => {
                loader.load('city_ruins_1.glb', (gltf) => {
                    cityScene = gltf.scene;
                    const box = new THREE.Box3().setFromObject(cityScene);
                    const center = new THREE.Vector3();
                    box.getCenter(center);
                    const offset = new THREE.Vector3(-center.x, -box.min.y, -center.z);
                    cityScene.position.add(offset);
                    cityScene.traverse(obj => {
                        if(obj.isMesh) {
                            const g = obj.geometry;
                            if(g) {
                                if(!g.boundingSphere) g.computeBoundingSphere();
                                if(!g.boundingBox) g.computeBoundingBox();
                                const size = new THREE.Vector3();
                                g.boundingBox.getSize(size);
                                const r = g.boundingSphere ? g.boundingSphere.radius : 0;
                                if((r < 1.0 || size.length() < 3.0) || /sky|Sky|SKY|sphere/i.test(obj.name)) {
                                    obj.visible = false; // hide tiny embedded sky/placeholder spheres
                                    return;
                                }
                            }
                            obj.castShadow = true; 
                            obj.receiveShadow = true; 
                        }
                    });
                    scene.add(cityScene);
                    groundHeight = 0;
                    createFloor();
                    createPath();
                    createPendulumSystem();
                    loadSkybox(true);
                    resolve();
                }, undefined, reject);
            });
        }

        function createPath() {
            pathPieces.forEach(p => {
                scene.remove(p);
                disposeObject(p);
            });
            pathPieces = [];
            if(!params.pathVisible) return;

            const pathLength = params.pathLength;
            const base = new THREE.Mesh(
                new THREE.PlaneGeometry(params.pathWidth, pathLength),
                new THREE.MeshStandardMaterial({
                    color: 0x0f1f30,
                    roughness: 0.5,
                    metalness: 0.05,
                    transparent: true,
                    opacity: 0.92,
                    emissive: 0x0a1624
                })
            );
            base.rotation.x = -Math.PI/2;
            base.position.y = groundHeight + 0.021;
            base.receiveShadow = true;
            scene.add(base);
            pathPieces.push(base);

            const stripeMat = new THREE.MeshStandardMaterial({ color: 0xffe066, emissive: 0x332200, roughness: 0.3 });
            const centerStripe = new THREE.Mesh(new THREE.PlaneGeometry(0.25, pathLength), stripeMat);
            centerStripe.rotation.x = -Math.PI/2;
            centerStripe.position.set(0, groundHeight + 0.024, 0);
            centerStripe.receiveShadow = false;
            scene.add(centerStripe);
            pathPieces.push(centerStripe);

            const edgeMat = new THREE.MeshStandardMaterial({ color: 0x0b141f, roughness: 0.8 });
            const edgeOffset = params.pathWidth / 2 + 0.15;
            const edgeGeo = new THREE.PlaneGeometry(0.18, pathLength);
            const edgeMesh = new THREE.InstancedMesh(edgeGeo, edgeMat, 2);
            const edgeMatrix = new THREE.Matrix4();
            const edgeQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(-Math.PI/2, 0, 0));
            edgeMatrix.compose(new THREE.Vector3(-edgeOffset, groundHeight + 0.023, 0), edgeQuat, new THREE.Vector3(1,1,1));
            edgeMesh.setMatrixAt(0, edgeMatrix);
            edgeMatrix.compose(new THREE.Vector3(edgeOffset, groundHeight + 0.023, 0), edgeQuat, new THREE.Vector3(1,1,1));
            edgeMesh.setMatrixAt(1, edgeMatrix);
            edgeMesh.instanceMatrix.needsUpdate = true;
            scene.add(edgeMesh);
            pathPieces.push(edgeMesh);
        }

        function createSkyDome() {
            if(skyDome) {
                scene.remove(skyDome);
                skyDome.geometry.dispose();
                skyDome.material.dispose();
                skyDome = null;
            }
            const skyGeo = new THREE.SphereGeometry(250, 48, 32);
            const skyMat = new THREE.MeshBasicMaterial({
                color: 0x0c141f,
                side: THREE.BackSide,
                fog: true
            });
            skyDome = new THREE.Mesh(skyGeo, skyMat);
            skyDome.position.set(0, groundHeight - 10, 0);
            scene.add(skyDome);
        }

        function loadSkybox(repositionOnly = false) {
            if(repositionOnly && skyboxScene) {
                skyboxScene.position.set(0, groundHeight + params.skyboxOffsetY, 0);
                skyboxScene.rotation.set(
                    THREE.MathUtils.degToRad(params.skyboxRotationX),
                    THREE.MathUtils.degToRad(params.skyboxRotationY),
                    THREE.MathUtils.degToRad(params.skyboxRotationZ)
                );
                skyboxScene.scale.setScalar(params.skyboxScale);
                return;
            }
            if(skyboxScene) {
                scene.remove(skyboxScene);
                skyboxScene.geometry?.dispose?.();
                if(skyboxScene.material?.map) skyboxScene.material.map.dispose();
                skyboxScene.material?.dispose?.();
                skyboxScene = null;
            }
            const texLoader = new THREE.TextureLoader().setPath('Skybox/textures/');
            texLoader.load('Scene_-_Root_diffuse.jpeg', (tex) => {
                tex.colorSpace = THREE.SRGBColorSpace;
                tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
                tex.repeat.set(1, 1);
                tex.needsUpdate = true;
                tex.mapping = THREE.EquirectangularReflectionMapping;
                scene.background = tex;
                scene.environment = tex;

                const geo = new THREE.SphereGeometry(260 * params.skyboxScale, 64, 48);
                const mat = new THREE.MeshBasicMaterial({
                    map: tex,
                    side: THREE.BackSide,
                    depthWrite: false,
                    fog: false,
                    color: 0xffffff
                });
                skyboxScene = new THREE.Mesh(geo, mat);
                skyboxScene.position.set(0, groundHeight + params.skyboxOffsetY, 0);
                skyboxScene.rotation.set(
                    THREE.MathUtils.degToRad(params.skyboxRotationX),
                    THREE.MathUtils.degToRad(params.skyboxRotationY),
                    THREE.MathUtils.degToRad(params.skyboxRotationZ)
                );
                skyboxScene.frustumCulled = false;
                skyboxScene.renderOrder = -1;
                scene.add(skyboxScene);
                if(skyDome) { scene.remove(skyDome); skyDome = null; }
            }, undefined, (err) => {
                console.warn('Skybox texture load failed, using procedural dome', err);
                createSkyDome();
            });
        }

        // --- Pendulum System ---

        function calculateUnstoppableMass(radius, density) {
            // Normal Volume calculation
            const volume = (4/3) * Math.PI * Math.pow(radius, 3);
            
            // SUPER DENSITY MULTIPLIER
            // We multiply by 100 internally. 
            // This makes the Bob effectively weigh tons, while meeples weigh 5kg.
            // A 5000kg object does not slow down when hitting a 5kg object.
            return volume * density * 100;
        }

        function cleanPendulum() {
            pendulumParts.forEach(p => {
                if(p.mesh) {
                    scene.remove(p.mesh);
                    disposeObject(p.mesh, { disposeMaterial: false });
                }
                if(p.body) world.removeBody(p.body);
            });
            constraints.forEach(c => world.removeConstraint(c));
            physicsObjects = physicsObjects.filter(o => o.group !== 'pendulum');
            pendulumParts = [];
            pendulumBodies = [];
            constraints = [];
        }

        function createPendulumSystem() {
            cleanPendulum();
            // Kinematic, analytic double pendulum (driven by solver)
            const body1 = new CANNON.Body({
                mass: 0,
                type: CANNON.Body.KINEMATIC,
                material: cannonMaterials.default,
                collisionFilterGroup: GROUP_PENDULUM,
                collisionFilterMask: GROUP_PEDESTRIAN | GROUP_RAGDOLL
            });
            body1.addShape(new CANNON.Sphere(params.bob1Size));
            world.addBody(body1);
            pendulumBodies.push(body1);

            const body2 = new CANNON.Body({
                mass: 0,
                type: CANNON.Body.KINEMATIC,
                material: cannonMaterials.default,
                collisionFilterGroup: GROUP_PENDULUM,
                collisionFilterMask: GROUP_PEDESTRIAN | GROUP_RAGDOLL
            });
            body2.addShape(new CANNON.Sphere(params.bob2Size));
            world.addBody(body2);
            pendulumBodies.push(body2);

            // Visuals
            const group1 = new THREE.Group();
            const vRod1 = new THREE.Mesh(new THREE.CylinderGeometry(params.rod1Radius, params.rod1Radius, params.rod1Length, 32), threeMaterials.rod);
            vRod1.position.y = -params.rod1Length/2;
            const vBob1 = new THREE.Mesh(new THREE.SphereGeometry(params.bob1Size, 48, 48), threeMaterials.bob);
            vBob1.position.y = -params.rod1Length;
            group1.add(vRod1); group1.add(vBob1);
            group1.castShadow = true;
            scene.add(group1);

            const group2 = new THREE.Group();
            const vRod2 = new THREE.Mesh(new THREE.CylinderGeometry(params.rod2Radius, params.rod2Radius, params.rod2Length, 32), threeMaterials.rod);
            vRod2.position.y = -params.rod2Length/2;
            const vBob2 = new THREE.Mesh(new THREE.SphereGeometry(params.bob2Size, 48, 48), threeMaterials.bob);
            vBob2.position.y = -params.rod2Length;
            group2.add(vRod2); group2.add(vBob2);
            group2.castShadow = true;
            scene.add(group2);

            physicsObjects.push({ mesh: group1, body: body1, group: 'pendulum', type: 'rod' });
            physicsObjects.push({ mesh: vBob1, body: null, group: 'pendulum', type: 'bob' });
            physicsObjects.push({ mesh: group2, body: body2, group: 'pendulum', type: 'rod' });
            physicsObjects.push({ mesh: vBob2, body: null, group: 'pendulum', type: 'bob' });
            pendulumParts.push({ mesh: group1, body: body1, name: 'rod1' });
            pendulumParts.push({ mesh: vBob1, body: null, name: 'bob1' });
            pendulumParts.push({ mesh: group2, body: body2, name: 'rod2' });
            pendulumParts.push({ mesh: vBob2, body: null, name: 'bob2' });

            resetPendulumState();
        }

        // --- Meeple System ---

        function spawnPedestrian() {
            if(pedestrians.length >= params.maxPedestrians) return;

            const range = Math.min(params.spawnDistance, Math.max(params.pathLength / 2 - 4, 10));
            const startZ = Math.random() > 0.5 ? range : -range;
            const direction = startZ > 0 ? -1 : 1;
            const laneHalf = Math.max(params.pathWidth * 0.45, 0.75);
            const laneX = THREE.MathUtils.randFloatSpread(laneHalf * 2);
            const goalZ = startZ > 0 ? -params.despawnDistance : params.despawnDistance;

            const radius = 0.75;
            const mass = params.meepleMass;

            const body = new CANNON.Body({
                mass: mass,
                material: cannonMaterials.pedestrian,
                fixedRotation: false,
                collisionFilterGroup: GROUP_PEDESTRIAN,
                collisionFilterMask: GROUP_FLOOR | GROUP_PENDULUM | GROUP_PEDESTRIAN | GROUP_RAGDOLL
            });
            body.allowSleep = false;
            body.linearDamping = 0.06;
            body.angularDamping = 0.1;
            body.addShape(new CANNON.Sphere(radius));

            const baseSpeed = params.walkSpeed; // keep steady pace; lateral forces handled separately
            body.position.set(laneX, groundHeight + radius, startZ);
            body.velocity.z = direction * baseSpeed;
            body.wakeUp();
            world.addBody(body);

            const mesh = createMeepleMesh();
            scene.add(mesh);

            const p = {
                mesh: mesh,
                body: body,
                direction: direction,
                baseSpeed: baseSpeed,
                offset: Math.random() * 100,
                sidePhase: Math.random() * Math.PI * 2,
                color: mesh.userData.color,
                goalZ,
                isDead: false,
                needsRemoval: false
            };

            body.addEventListener("collide", (e) => {
                if(p.isDead) return;
                
                if(e.body.collisionFilterGroup === GROUP_PENDULUM) {
                    const pendulumBody = e.body;
                    const preservedVel = new CANNON.Vec3().copy(pendulumBody.velocity);
                    const preservedAngVel = new CANNON.Vec3().copy(pendulumBody.angularVelocity);

                    const contact = e.contact;
                    const contactPoint = new CANNON.Vec3();
                    if(contact.bi === body) contact.ri.vadd(contact.bi.position, contactPoint);
                    else contact.rj.vadd(contact.bj.position, contactPoint);
                    
                    let zone = 'torso';
                    if(contactPoint.y > 1.3) zone = 'head';
                    else if(contactPoint.y < 0.6) zone = 'legs';

                    const impactNormal = new CANNON.Vec3();
                    if(contact.bi === body) contact.ni.negate(impactNormal);
                    else impactNormal.copy(contact.ni);

                    const relPointPendulum = new CANNON.Vec3();
                    contactPoint.vsub(pendulumBody.position, relPointPendulum);
                    const angularComponent = new CANNON.Vec3();
                    pendulumBody.angularVelocity.cross(relPointPendulum, angularComponent);
                    const bobPointVelocity = new CANNON.Vec3();
                    pendulumBody.velocity.vadd(angularComponent, bobPointVelocity);

                    const relativeVel = new CANNON.Vec3();
                    bobPointVelocity.vsub(body.velocity, relativeVel);
                    const relSpeed = relativeVel.length();
                    const normalSpeed = Math.max(relativeVel.dot(impactNormal), 0);
                    const tangentialSpeed = Math.sqrt(Math.max(relSpeed*relSpeed - normalSpeed*normalSpeed, 0));
                    const severity = normalSpeed + tangentialSpeed * 0.35;

                    const hitPointLocal = contact.bi === body ? contact.ri : contact.rj;

                    // quick squish visual proportional to impact
                    squishMesh(p.mesh, impactNormal, severity);

                    if (severity > 5 || relSpeed > 7) {
                        p.isDead = true;
                        spawnRagdoll(p, body.velocity, relativeVel, impactNormal, zone, true, severity);
                    } else if (severity > 2.2) {
                        p.isDead = true;
                        spawnRagdoll(p, body.velocity, relativeVel, impactNormal, zone, false, severity);
                    } else {
                        const shove = new CANNON.Vec3();
                        const shoveStrength = Math.max(2, normalSpeed * 6 + tangentialSpeed * 2);
                        impactNormal.scale(shoveStrength, shove);
                        body.applyImpulse(shove, hitPointLocal);
                    }

                    pendulumBody.velocity.copy(preservedVel);
                    pendulumBody.angularVelocity.copy(preservedAngVel);

                    if (p.isDead) {
                        p.needsRemoval = true;
                    }
                }
            });

            pedestrians.push(p);
        }

        function createMeepleMesh() {
            const group = new THREE.Group();
            const color = new THREE.Color().setHSL(Math.random(), 0.7, 0.45);
            group.userData.color = color;
            group.userData.squishTimer = null;

            const matBlob = new THREE.MeshStandardMaterial({ color: color, roughness: 0.6, metalness: 0.05 });
            const blob = new THREE.Mesh(new THREE.SphereGeometry(0.75, 32, 28), matBlob);
            blob.castShadow = true;
            group.add(blob);
            addEyes(blob, 0.75);
            group.userData.blob = blob;
            return group;
        }

        function updatePedestrians(dt, time) {
            if(params.spawnPedestrians) {
                const interval = Math.max(params.spawnRate / 60, 0.01);
                spawnAccumulator += dt;
                while(spawnAccumulator >= interval) {
                    spawnPedestrian();
                    spawnAccumulator -= interval;
                }
            } else {
                spawnAccumulator = 0;
            }

            for(let i = pedestrians.length - 1; i >= 0; i--) {
                const p = pedestrians[i];
                if(p.isDead || p.needsRemoval) {
                    world.removeBody(p.body);
                    scene.remove(p.mesh);
                    disposeObject(p.mesh);
                    pedestrians.splice(i, 1);
                    continue;
                }

                const radius = p.body.shapes?.[0]?.radius ?? 0.75;

                let sepX = 0, sepZ = 0;
                let aheadStrafe = 0;
                for(let other of pedestrians) {
                    if(other === p) continue;
                    const dx = p.body.position.x - other.body.position.x;
                    const dz = p.body.position.z - other.body.position.z;
                    const dSq = dx*dx + dz*dz;
                    if(dSq < 2.0) {
                        if(dSq > 1e-6) {
                            const d = Math.sqrt(dSq);
                            sepX += dx / d;
                            sepZ += dz / d;
                        } else {
                            // perfect overlap – add jitter instead of dividing by zero
                            sepX += (Math.random() - 0.5) * 0.6;
                            sepZ += (Math.random() - 0.5) * 0.6;
                        }
                        if(Math.sign(dz) === p.direction && Math.abs(dx) < 0.8 && Math.abs(dz) < 4) {
                            aheadStrafe += dx >= 0 ? 1 : -1; // sidestep to avoid following jam
                        }
                    }
                }

                const wander = Math.sin(time * 0.7 + p.sidePhase) * Math.max(params.pathWidth * 0.08, 0.6);
                const dirToGoal = Math.sign(p.goalZ - p.body.position.z) || p.direction;
                p.direction = dirToGoal;
                const desiredZ = (dirToGoal * p.baseSpeed) + (sepZ * 0.15);
                // force forward motion; keep a minimum speed
                const minSpeed = p.baseSpeed * 0.5;
                let targetZVel = desiredZ;
                if(Math.abs(targetZVel) < minSpeed) targetZVel = p.direction * minSpeed;
                p.body.velocity.z = targetZVel;

                const boundary = Math.max(params.pathWidth * 0.5 - 0.3, 1.0);
                let boundaryPush = 0;
                if(p.body.position.x > boundary) boundaryPush = -2.5;
                else if(p.body.position.x < -boundary) boundaryPush = 2.5;

                const desiredX = (sepX * params.separationForce) + wander + aheadStrafe * 1.4 + boundaryPush;
                p.body.velocity.x += (desiredX - p.body.velocity.x) * 0.3;
                ensureFiniteVec3(p.body.velocity);
                ensureFiniteVec3(p.body.position, 0, { y: groundHeight + radius });
                p.body.wakeUp();

                p.mesh.position.copy(p.body.position);
                const planarSpeed = Math.sqrt(p.body.velocity.x * p.body.velocity.x + p.body.velocity.z * p.body.velocity.z);
                const animRate = THREE.MathUtils.clamp(planarSpeed / Math.max(0.1, p.baseSpeed), 0.5, 2.5);
                const cycle = Math.sin(time * 9 * animRate + p.offset);
                const vy = p.body.velocity.y;
                const bounceStretch = 1 + THREE.MathUtils.clamp(Math.abs(vy) * 0.25, 0, 0.4);
                const bounceSquish = 1 / bounceStretch;
                const walkStretch = 1 + Math.max(0, Math.sin(time * 4 + p.offset) * 0.05);
                const walkSquish = 1 - Math.abs(cycle) * 0.12;
                const sx = walkStretch * bounceStretch;
                const sy = walkSquish * bounceSquish;
                p.mesh.scale.set(sx, sy, sx);
                p.mesh.rotation.y = Math.atan2(p.body.velocity.x, p.body.velocity.z);

                if(Math.abs(p.body.position.z) > params.despawnDistance || Math.abs(p.body.position.x) > params.pathWidth * 1.6) {
                    world.removeBody(p.body);
                    scene.remove(p.mesh);
                    disposeObject(p.mesh);
                    pedestrians.splice(i, 1);
                }
            }
        }

        function removeRagdollAt(index) {
            const r = ragdolls[index];
            if(!r) return;
            r.bodies.forEach(b => world.removeBody(b));
            r.cons.forEach(c => world.removeConstraint(c));
            scene.remove(r.group);
            disposeObject(r.group, { disposeMaterial: false });
            if(r.materials) {
                const seen = new Set();
                r.materials.forEach(m => {
                    if(!m || seen.has(m)) return;
                    disposeMaterialResource(m);
                    seen.add(m);
                });
            }
            ragdolls.splice(index, 1);
        }

        function spawnRagdoll(p, initialVel, impactVel, contactNormal, zone, isHighEnergy, impactSeverity = null) {
            if(ragdolls.length >= params.maxRagdolls) removeRagdollAt(0);
            const group = new THREE.Group();
            scene.add(group);

            const bodies = [];
            const visuals = [];
            const pos = p.body.position;
            const materials = [];

            const blobMat = new THREE.MeshStandardMaterial({ color: p.color, roughness: 0.4, metalness: 0.08 });
            materials.push(blobMat);

            const totalMass = Math.max(p.body?.mass || params.meepleMass, 0.1);
            const baseRadius = 0.75;
            const baseVolume = (4/3) * Math.PI * Math.pow(baseRadius, 3);
            const density = totalMass / baseVolume; // keep density consistent when fragmenting

            const impactStrength = Math.max(impactSeverity ?? impactVel.length(), 0);
            const sNorm = THREE.MathUtils.clamp((impactStrength - 4.0) / 10.0 + (isHighEnergy ? 0.08 : 0), 0, 1);
            const breakSeverity = sNorm * sNorm * sNorm; // harsher ramp; low speeds stay near zero
            const minChunks = 2;
            const maxChunks = 64;
            const count = Math.max(minChunks, Math.round(THREE.MathUtils.lerp(minChunks, maxChunks, breakSeverity)));

            // Allocate mass shares that sum to totalMass
            const weights = [];
            const weightPower = THREE.MathUtils.lerp(2.4, 0.35, breakSeverity);
            for(let i = 0; i < count; i++) {
                const w = Math.pow(Math.random(), weightPower);
                weights.push(w);
            }
            const wSum = weights.reduce((a,b) => a + b, 0.0001);
            const masses = weights.map(w => (w / wSum) * totalMass);

            const makeBlob = (radius, mass, ox, oy, oz, impulseScale) => {
                const body = new CANNON.Body({
                    mass: mass,
                    material: cannonMaterials.ragdoll,
                    collisionFilterGroup: GROUP_RAGDOLL,
                    collisionFilterMask: GROUP_FLOOR | GROUP_PENDULUM | GROUP_RAGDOLL | GROUP_PEDESTRIAN
                });
                body.allowSleep = false;
                body.linearDamping = 0.05;
                body.angularDamping = 0.18;
                body.addShape(new CANNON.Sphere(radius));
                body.position.set(pos.x + ox, pos.y + oy, pos.z + oz);
                body.velocity.copy(initialVel);
                world.addBody(body);
                bodies.push(body);

                const mesh = new THREE.Mesh(new THREE.SphereGeometry(radius, 18, 14), blobMat);
                mesh.castShadow = true;
                group.add(mesh);
                visuals.push({ mesh, body, impulseScale, radius, survivor: false, survivorTimer: 0, wanderTimer: 0, forwardDirZ: null, forwardQuat: null });
            };

            for(let i = 0; i < count; i++) {
                const theta = Math.random() * Math.PI * 2;
                const spread = THREE.MathUtils.lerp(0.12, 0.4, breakSeverity);
                const ox = Math.cos(theta) * spread * Math.random();
                const oz = Math.sin(theta) * spread * Math.random();
                const oy = 0.1 + Math.random() * 0.2;
                const impulseScale = THREE.MathUtils.lerp(0.4, 1.2, breakSeverity) * (0.7 + Math.random() * 0.4);

                const mass = masses[i];
                const radius = Math.cbrt((3 * mass) / (4 * Math.PI * density));
                makeBlob(radius, mass, ox, oy, oz, impulseScale);
            }

            // Launch them outward based on impact
            const baseDir = new CANNON.Vec3(
                impactVel.x || contactNormal.x || (Math.random() - 0.5),
                Math.abs(impactVel.y) + 1.0,
                impactVel.z || contactNormal.z || (Math.random() - 0.5)
            );
            baseDir.normalize();
            visuals.forEach(v => {
                const massShare = v.body.mass / totalMass;
                const energyScale = THREE.MathUtils.lerp(0.25, 1.2, breakSeverity);
                const impulseMag = (isHighEnergy ? 8 : 4) * v.impulseScale * (count > 10 ? 0.7 : 1) * (0.3 + massShare * 0.9) * energyScale;
                const impulse = new CANNON.Vec3(baseDir.x, baseDir.y, baseDir.z).scale(impulseMag);
                v.body.applyImpulse(impulse, new CANNON.Vec3(0, 0, 0));
            });

            ragdolls.push({ group, visuals, bodies, cons: [], life: params.ragdollLife, materials, survivor: false });
        }

        // --- Logic: Auto Kicker ---
        
        function kickPendulum(forceMultiplier = 1) {
            if(!pendStateRK4) resetPendulumState();
            const kick = params.kickForce * 0.0005 * forceMultiplier;
            const dir = (Math.random() > 0.5 ? 1 : -1);
            pendStateRK4.omega2 += kick * dir;
            pendStateRK4.omega1 += kick * -dir * 0.5;
            lastKickTime = performance.now();
            showKickMessage();
        }

        function checkPendulumEnergy() {
            if(!params.enableAutoKick) return;
            if(pendulumBodies.length < 2) return;
            if(!pendStateRK4) resetPendulumState();

            const time = performance.now();
            if(time - lastKickTime < params.kickCooldown) return; // Cooldown

            const v1 = Math.abs(pendStateRK4.omega1) * params.rod1Length;
            const v2 = Math.abs(pendStateRK4.omega2) * params.rod2Length;
            const totalSpeed = v1 + v2;

            if (totalSpeed < params.minSpeedThreshold) {
                kickPendulum();
            }
        }

        function showKickMessage() {
            // Disabled overlay message per request
        }

        // --- UI & Interaction ---

        function setupGUI() {
            const gui = new GUI({ title: 'Chaos Settings' });
            gui.close();
            
            const fKick = gui.addFolder('Auto Kicker');
            fKick.add(params, 'enableAutoKick').name('Enable Kicker');
            fKick.add(params, 'minSpeedThreshold', 0.5, 10.0).name('Kick if Speed <');
            fKick.add(params, 'kickForce', 100, 2000).name('Kick Force');
            fKick.add(params, 'kickCooldown', 500, 5000).name('Cooldown (ms)');
            fKick.add({ kick: () => kickPendulum(1.2) }, 'kick').name('Kick Now');
            fKick.close();

            const fPole = gui.addFolder('Pole & Material');
            fPole.add(params, 'pivotHeight', 2, 14).name('Pivot Height').onChange(params.reset);
            fPole.add(params, 'startAngleDeg', 0, 80).name('Start Angle').onChange(params.reset);
            fPole.add(params, 'materialDensity', 10, 500).name('Density (Multiplier)').onChange(params.reset);
            fPole.add(params, 'bobMaterial', ['Steel', 'Wood', 'Rubber', 'Gold', 'Neon']).name('Type').onChange(updateBobMaterial);
            fPole.add(params, 'timeScale', 0.1, 2.0).name('Time Scale');
            fPole.add(params, 'pendulumDamping', 0, 0.02).name('Linear Damping').onChange(params.reset);
            fPole.add(params, 'pendulumAngularDamping', 0, 0.02).name('Angular Damping').onChange(params.reset);
            fPole.add(params, 'reset').name('Rebuild World');
            fPole.close();

            const fRod1 = gui.addFolder('Upper Pendulum');
            fRod1.add(params, 'rod1Length', 1, 6).name('Rod Length').onChange(params.reset);
            fRod1.add(params, 'bob1Size', 0.2, 2.0).name('Bob Radius').onChange(params.reset);
            fRod1.close();

            const fRod2 = gui.addFolder('Lower Pendulum');
            fRod2.add(params, 'rod2Length', 1, 6).name('Rod Length').onChange(params.reset);
            fRod2.add(params, 'bob2Size', 0.2, 2.0).name('Bob Radius').onChange(params.reset);
            fRod2.close();
            
            const fPed = gui.addFolder('Pedestrians');
            fPed.add(params, 'spawnPedestrians');
            fPed.add(params, 'spawnRate', 10, 200).name('Spawn Delay');
            fPed.add(params, 'walkSpeed', 1, 5).name('Walk Speed');
            fPed.add(params, 'separationForce', 1, 10).name('Separation');
            fPed.add(params, 'meepleMass', 1, 8).name('Meeple Mass');
            fPed.add(params, 'maxPedestrians', 10, 250).name('Max Pedestrians').step(1);
            fPed.add(params, 'spawnDistance', 40, 300).name('Spawn Distance').onChange(createFloor);
            fPed.add(params, 'despawnDistance', 60, 360).name('Despawn Distance');
            fPed.add(params, 'maxRagdolls', 5, 120).name('Max Ragdolls').step(1);
            fPed.add(params, 'ragdollLife', 1, 12).name('Ragdoll Life (s)');
            fPed.close();

            const fPath = gui.addFolder('Path');
            fPath.add(params, 'pathVisible').name('Show Path').onChange(createPath);
            fPath.add(params, 'pathWidth', 4, 14).name('Path Width').onChange(() => { createFloor(); createPath(); });
            fPath.add(params, 'pathLength', 80, 400).name('Path Length').onChange(() => { createFloor(); createPath(); });
            fPath.close();

            const fSky = gui.addFolder('Skybox');
            fSky.add(params, 'skyboxOffsetY', -50, 50).name('Offset Y').onChange(() => loadSkybox(true));
            fSky.add(params, 'skyboxRotationX', -180, 180).name('Rotation X').onChange(() => loadSkybox(true));
            fSky.add(params, 'skyboxRotationY', -180, 180).name('Rotation Y').onChange(() => loadSkybox(true));
            fSky.add(params, 'skyboxRotationZ', -180, 180).name('Rotation Z').onChange(() => loadSkybox(true));
            fSky.add(params, 'skyboxScale', 0.2, 3).name('Scale').onChange(() => loadSkybox(true));
            fSky.close();
        }

        function setupInteraction() {
            const shape = new CANNON.Sphere(0.1);
            mouseBody = new CANNON.Body({ mass: 0, type: CANNON.Body.KINEMATIC, collisionFilterGroup: 0 });
            mouseBody.addShape(shape);
            world.addBody(mouseBody);

            window.addEventListener('mousedown', (e) => {
                if(renderer.xr.isPresenting) return;
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);

                const hitsPend = raycaster.intersectObjects(pendulumParts.map(p => p.mesh).filter(Boolean), true);
                if(hitsPend.length > 0) {
                    const targetName = findPendulumPartName(hitsPend[0].object);
                    if(targetName === 'bob1' || targetName === 'bob2') {
                        controls.enabled = false;
                        dragState = { part: targetName, plane: new THREE.Plane(new THREE.Vector3(0,0,1), 0) };
                        updatePendulumFromDrag(raycaster.ray, dragState.part, dragState.plane);
                        return;
                    }
                }

                const interactables = [];
                physicsObjects.forEach(o => interactables.push(o.mesh));
                ragdolls.forEach(r => r.visuals.forEach(v => interactables.push(v.mesh)));

                const hitsOther = raycaster.intersectObjects(interactables, true);

                if(hitsOther.length > 0) {
                    const hit = hitsOther[0];
                    let body = null;
                    
                    const pObj = physicsObjects.find(o => o.mesh === hit.object || o.mesh === hit.object.parent);
                    if(pObj) body = pObj.body;

                    if(!body) {
                        for(let r of ragdolls) {
                            for(let v of r.visuals) {
                                if(v.mesh === hit.object) { body = v.body; break; }
                            }
                        }
                    }

                    if(body) {
                        controls.enabled = false;
                        mouseConstraint = new CANNON.PointToPointConstraint(body, body.pointToLocalFrame(new CANNON.Vec3(hit.point.x, hit.point.y, hit.point.z)), mouseBody, new CANNON.Vec3(0,0,0), 5e4);
                        world.addConstraint(mouseConstraint);
                    }
                }
            });

            window.addEventListener('mousemove', (e) => {
                if(mouseConstraint) {
                    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                    raycaster.setFromCamera(mouse, camera);
                    const z = mouseBody.position.z;
                    const pos = new THREE.Vector3();
                    pos.copy(raycaster.ray.origin).add(raycaster.ray.direction.multiplyScalar((z - raycaster.ray.origin.z) / raycaster.ray.direction.z));
                    mouseBody.position.set(pos.x, pos.y, z);
                } else if(dragState) {
                    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                    raycaster.setFromCamera(mouse, camera);
                    updatePendulumFromDrag(raycaster.ray, dragState.part, dragState.plane);
                }
            });

            window.addEventListener('mouseup', () => {
                controls.enabled = true;
                if(mouseConstraint) {
                    world.removeConstraint(mouseConstraint);
                    mouseConstraint = null;
                }
                dragState = null;
            });
        }

        function findPendulumPartName(obj) {
            let current = obj;
            while(current) {
                const part = pendulumParts.find(p => p.mesh === current);
                if(part && part.name) return part.name;
                current = current.parent;
            }
            return null;
        }

        function solvePlanarIK(target) {
            const pivot = new THREE.Vector3(0, groundHeight + params.pivotHeight, 0);
            const dx = target.x - pivot.x;
            const dy = target.y - pivot.y;

            // clamp to reachable radius
            const L1 = params.rod1Length;
            const L2 = params.rod2Length;
            const r = Math.sqrt(dx*dx + dy*dy);
            const maxR = Math.max(1e-4, L1 + L2 - 1e-4);
            const minR = Math.max(1e-4, Math.abs(L1 - L2) + 1e-4);
            let scale = 1;
            if(r > maxR) scale = maxR / r;
            else if(r < minR) scale = minR / r;
            const rx = dx * scale;
            const ry = dy * scale;

            // angles from vertical; phi is target angle from vertical down
            const phi = Math.atan2(rx, -ry);

            const c2 = THREE.MathUtils.clamp((rx*rx + ry*ry - L1*L1 - L2*L2) / (2 * L1 * L2), -1, 1);
            const s2 = Math.sqrt(Math.max(0, 1 - c2*c2)); // elbow-out
            const theta2Rel = Math.atan2(s2, c2);
            const theta1 = phi - Math.atan2(L2 * s2, L1 + L2 * c2);
            const theta2 = theta1 + theta2Rel;
            return { theta1, theta2 };
        }

        function updatePendulumFromDrag(ray, part, plane) {
            const hitPoint = new THREE.Vector3();
            if(!ray.intersectPlane(plane, hitPoint)) return;
            if(!pendStateRK4) resetPendulumState();

            const pivot = new THREE.Vector3(0, groundHeight + params.pivotHeight, 0);
            const setThetaFromPoint = (base, point) => {
                const dx = point.x - base.x;
                const dy = point.y - base.y;
                return Math.atan2(dx, -dy); // angle from vertical
            };

            if(part === 'bob1') {
                pendStateRK4.theta1 = setThetaFromPoint(pivot, hitPoint);
                pendStateRK4.omega1 = 0;
                pendStateRK4.omega2 = 0;
            } else if(part === 'bob2') {
                const ik = solvePlanarIK(hitPoint);
                pendStateRK4.theta1 = ik.theta1;
                pendStateRK4.theta2 = ik.theta2;
                pendStateRK4.omega1 = 0;
                pendStateRK4.omega2 = 0;
            }

            prevBobPositionsRK4 = [];
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function setupControllers() {
            const controllerModelFactory = new XRControllerModelFactory();
            controller1 = renderer.xr.getController(0);
            controller2 = renderer.xr.getController(1);
            [controller1, controller2].forEach(ctrl => {
                if (!ctrl) return;
                const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]);
                const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: 0x66e0ff }));
                line.name = 'laser';
                line.scale.z = 0;
                ctrl.add(line);
                xrRig.add(ctrl);
            });
            controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip2 = renderer.xr.getControllerGrip(1);
            if (controllerGrip1) {
                controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
                xrRig.add(controllerGrip1);
            }
            if (controllerGrip2) {
                controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
                xrRig.add(controllerGrip2);
            }
            updateControllerVisibility(false);
        }

        function updateControllerVisibility(visible) {
            [controller1, controller2, controllerGrip1, controllerGrip2].forEach(ctrl => {
                if (ctrl) ctrl.visible = visible;
            });
        }

        function animate() {
            const delta = Math.min(clock.getDelta() * params.timeScale, 0.1);
            accumulator = Math.min(accumulator + delta, fixedTimeStep * maxSubSteps);
            while(accumulator >= fixedTimeStep) {
                world.step(fixedTimeStep);
                accumulator -= fixedTimeStep;
            }

            // Pendulum step (analytic)
            updatePendulum(delta);
            checkPendulumEnergy();

            // Sync only non-pendulum visuals from physics; pendulum visuals are driven analytically
            for(let o of physicsObjects) {
                if(o.group === 'pendulum') continue;
                if(o.body && o.mesh) {
                    o.mesh.position.copy(o.body.position);
                    o.mesh.quaternion.copy(o.body.quaternion);
                }
            }

            for(let i = ragdolls.length - 1; i >= 0; i--) {
                const r = ragdolls[i];
                let anySurvivor = false;

                for(const v of r.visuals) {
                    const b = v.body;
                    if(!b) continue;
                    const radius = b.shapes?.[0]?.radius ?? v.radius ?? 0.2;
                    ensureFiniteVec3(b.position, 0, { y: groundHeight + radius });
                    ensureFiniteVec3(b.velocity);
                    ensureFiniteVec3(b.angularVelocity);
                    const onPath = (b.position.y - radius) <= groundHeight + 0.12;
                    const slow = b.velocity.length() <= 1.2;

                    if(onPath && slow) v.survivorTimer += delta;
                    else v.survivorTimer = Math.max(0, v.survivorTimer - delta * 0.4);

                    if(!v.survivor && v.survivorTimer > 0.5) {
                        v.survivor = true;
                        // align movement to current eye facing; default to +Z if ambiguous
                        const facing = new THREE.Vector3(0, 0, 1).applyQuaternion(v.mesh.quaternion);
                        let dirZ = Math.sign(facing.z);
                        if(dirZ === 0) dirZ = Math.sign(b.velocity.z);
                        if(dirZ === 0) dirZ = (Math.random() > 0.5 ? 1 : -1);
                        v.forwardDirZ = dirZ;
                        v.forwardQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), dirZ > 0 ? 0 : Math.PI);
                        v.wanderTimer = 0;
                        addEyes(v.mesh, v.radius || 0.25);
                        b.linearDamping = 0.12;
                        b.angularDamping = 0.5;
                        b.wakeUp();
                    }

                    if(v.survivor) {
                        anySurvivor = true;
                        if(b.sleepState !== 0) b.wakeUp();
                        const boundary = Math.max(params.pathWidth * 0.5 - 0.3, 1.0);
                        let boundaryPush = 0;
                        if(b.position.x > boundary) boundaryPush = -2.0;
                        else if(b.position.x < -boundary) boundaryPush = 2.0;
                        const targetSpeed = params.walkSpeed * 0.9;
                        const tx = boundaryPush * 0.25;
                        const tz = (v.forwardDirZ || 1) * targetSpeed;
                        b.velocity.x += (tx - b.velocity.x) * 0.22;
                        b.velocity.z += (tz - b.velocity.z) * 0.22;
                        b.angularVelocity.set(0, 0, 0);
                        if(v.forwardQuat) b.quaternion.copy(v.forwardQuat);
                        else b.quaternion.set(0, 0, 0, 1);
                        b.position.y = Math.max(b.position.y, groundHeight + radius);

                        if(Math.abs(b.position.z) > params.despawnDistance || Math.abs(b.position.x) > params.pathWidth * 1.6) {
                            r.life = 0;
                        }
                    } else if(onPath) {
                        r.life = Math.max(r.life, params.ragdollLife); // pause decay while on path
                    }

                    v.mesh.position.copy(b.position);
                    v.mesh.quaternion.copy(b.quaternion);
                }

                if(anySurvivor) {
                    r.life = Math.max(r.life - delta * 0.05, params.ragdollLife); // slow decay
                } else {
                    r.life -= delta;
                }

                if(r.life <= 0) {
                    removeRagdollAt(i);
                }
            }

            updatePedestrians(delta, clock.elapsedTime);

            if(!renderer.xr.isPresenting) controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
