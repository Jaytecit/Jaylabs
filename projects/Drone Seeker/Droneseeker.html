<!DOCTYPE html>
<html>
  <head>
    <title>VR Spaceship - Advanced Combat</title>
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-environment-component@1.3.3/dist/aframe-environment-component.min.js"></script>
  </head>
  <body>
    <script>
      // =========================================================
      // 1. AUDIO SYSTEM
      // =========================================================
      AFRAME.registerSystem('game-audio', {
        init: function() {
          this.context = new (window.AudioContext || window.webkitAudioContext)();
          this.engineOsc = null;
          this.engineGain = null;
          this.setupEngineSound();
        },
        setupEngineSound: function() {
          if (this.context.state === 'suspended') this.context.resume();
          this.engineOsc = this.context.createOscillator();
          this.engineGain = this.context.createGain();
          this.engineOsc.type = 'sawtooth';
          this.engineOsc.frequency.value = 50;
          this.engineGain.gain.value = 0.05; 
          this.engineOsc.connect(this.engineGain);
          this.engineGain.connect(this.context.destination);
          this.engineOsc.start();
        },
        playLaser: function(isEnemy) {
          if (this.context.state === 'suspended') this.context.resume();
          let osc = this.context.createOscillator();
          let gain = this.context.createGain();
          osc.connect(gain);
          gain.connect(this.context.destination);
          if (isEnemy) {
            osc.type = 'square';
            osc.frequency.setValueAtTime(300, this.context.currentTime); 
            osc.frequency.linearRampToValueAtTime(100, this.context.currentTime + 0.3);
            gain.gain.setValueAtTime(0.05, this.context.currentTime);
            gain.gain.linearRampToValueAtTime(0, this.context.currentTime + 0.3);
            osc.start();
            osc.stop(this.context.currentTime + 0.3);
          } else {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(800, this.context.currentTime);
            osc.frequency.exponentialRampToValueAtTime(200, this.context.currentTime + 0.15);
            gain.gain.setValueAtTime(0.1, this.context.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.15);
            osc.start();
            osc.stop(this.context.currentTime + 0.15);
          }
        },
        playExplosion: function() {
          if (this.context.state === 'suspended') this.context.resume();
          let bufferSize = this.context.sampleRate * 0.5; 
          let buffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
          let data = buffer.getChannelData(0);
          for(let i=0; i<bufferSize; i++) data[i] = Math.random() * 2 - 1;
          let noise = this.context.createBufferSource();
          noise.buffer = buffer;
          let gain = this.context.createGain();
          gain.gain.setValueAtTime(0.2, this.context.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, this.context.currentTime + 0.5);
          noise.connect(gain);
          gain.connect(this.context.destination);
          noise.start();
        },
        playImpact: function() {
          if (this.context.state === 'suspended') this.context.resume();
          let osc = this.context.createOscillator();
          let gain = this.context.createGain();
          osc.connect(gain);
          gain.connect(this.context.destination);
          osc.type = 'triangle';
          osc.frequency.setValueAtTime(100, this.context.currentTime);
          osc.frequency.linearRampToValueAtTime(50, this.context.currentTime + 0.1);
          gain.gain.setValueAtTime(0.3, this.context.currentTime);
          gain.gain.linearRampToValueAtTime(0, this.context.currentTime + 0.1);
          osc.start();
          osc.stop(this.context.currentTime + 0.1);
        }
      });

      // =========================================================
      // 2. GAME MANAGER
      // =========================================================
      AFRAME.registerSystem('game-manager', {
        init: function() {
          this.score = 0;
          this.wave = 1;
          this.enemiesRemaining = 0;
          this.isSpawning = false;
          this.playerHealth = 100;
          this.gameOver = false;
          this.lastHitTime = 0;
          this.leftText = null;
          this.rightText = null;
          this.navArrow = null; 
          this.ship = null;
        },
        registerUI: function(left, right, arrow, ship) {
          this.leftText = left;
          this.rightText = right;
          this.navArrow = arrow;
          this.ship = ship;
        },
        tick: function(t, dt) {
          if (this.gameOver || !this.ship) return;
          // Shield Regen
          if (t - this.lastHitTime > 5000 && this.playerHealth < 100) {
            this.playerHealth += 0.05 * (dt/16);
            if(this.playerHealth > 100) this.playerHealth = 100;
          }
          // Radar Logic
          let enemies = document.querySelectorAll('.enemy-hitbox');
          let closestDist = 9999;
          let closestEnemy = null;
          let shipPos = this.ship.object3D.position;
          enemies.forEach(el => {
            let dist = el.object3D.position.distanceTo(shipPos);
            if (dist < closestDist) { closestDist = dist; closestEnemy = el; }
          });
          this.updateHUD(closestEnemy, closestDist);
        },
        updateHUD: function(closestEnemy, dist) {
          // LEFT HUD
          if (this.leftText) {
            let vTrack = "---";
            if (closestEnemy) {
               let localPos = closestEnemy.object3D.position.clone();
               this.ship.object3D.worldToLocal(localPos);
               if (localPos.y > 5) vTrack = "▲ UP";
               else if (localPos.y < -5) vTrack = "▼ DWN";
               else vTrack = "► LEVEL";
            }
            let healthInt = Math.floor(this.playerHealth);
            let color = healthInt < 30 ? "#FF0000" : "#00FF00";
            this.leftText.setAttribute('color', color);
            this.leftText.setAttribute('value', `SHIELD: ${healthInt}%\nSCORE: ${this.score}\nV-TRACK: ${vTrack}`);
          }
          // RIGHT HUD
          if (this.rightText) {
             let proxMsg = "CLEAR";
             let distDisplay = "----";
             if (closestEnemy) {
               distDisplay = Math.floor(dist) + "m";
               if (dist < 40) proxMsg = "!DANGER!";
               else if (dist < 100) proxMsg = "WARNING";
               else proxMsg = "TRACKING";
             }
             this.rightText.setAttribute('value', `WAVE: ${this.wave}\nPROX: ${proxMsg}\nDIST: ${distDisplay}`);
          }
          // NAVIGATION ARROW
          if (this.navArrow) {
            if (closestEnemy) {
              this.navArrow.object3D.visible = true;
              this.navArrow.object3D.lookAt(closestEnemy.object3D.position);
            } else {
              this.navArrow.object3D.visible = false;
            }
          }
        },
        enemyDestroyed: function(points) {
          if(this.gameOver) return;
          this.score += points;
          this.enemiesRemaining--;
          if (this.enemiesRemaining <= 0 && !this.isSpawning) this.startNextWave();
        },
        startNextWave: function() {
          this.isSpawning = true;
          if(this.rightText) this.rightText.setAttribute('value', "WAVE COMPLETE\nRECHARGING...");
          setTimeout(() => { this.wave++; this.spawnWave(); }, 3000);
        },
        spawnWave: function() {
          if(this.gameOver) return;
          let enemyCount = 3 + Math.floor(this.wave * 1.5); 
          this.enemiesRemaining = enemyCount;
          let spawner = this.el.components['drone-spawner'];
          if(spawner) spawner.spawnBatch(enemyCount, this.wave);
          this.isSpawning = false;
        },
        playerHit: function(damage) {
          if(this.gameOver) return;
          this.playerHealth -= damage;
          this.lastHitTime = performance.now();
          
          let damageOverlay = document.getElementById('damage-overlay');
          damageOverlay.setAttribute('visible', true);
          damageOverlay.setAttribute('opacity', 0.8);
          setTimeout(() => {
             if(!this.gameOver) {
                 damageOverlay.setAttribute('opacity', 0);
                 setTimeout(() => { damageOverlay.setAttribute('visible', false); }, 200);
             }
          }, 200);

          if (this.playerHealth <= 0) this.endGame();
        },
        endGame: function() {
          this.gameOver = true;
          let text = document.createElement('a-text');
          text.setAttribute('value', 'SYSTEM FAILURE');
          text.setAttribute('color', 'red');
          text.setAttribute('align', 'center');
          text.setAttribute('position', '0 0 -2');
          text.setAttribute('scale', '2 2 2');
          document.querySelector('[camera]').appendChild(text);
          let audioSys = this.el.sceneEl.systems['game-audio'];
          if(audioSys.engineGain) audioSys.engineGain.gain.linearRampToValueAtTime(0, audioSys.context.currentTime + 1);
        }
      });

      // =========================================================
      // 3. SHIP CONTROLS
      // =========================================================
      AFRAME.registerComponent('ship-controls', {
        schema: {
          accel: { type: 'number', default: 0.005 },      
          maxSpeed: { type: 'number', default: 5.0 },    
          turnSpeed: { type: 'number', default: 0.00012 },
          rollSpeed: { type: 'number', default: 0.02 },  
          rotDrag: { type: 'number', default: 0.98 }      
        },
        init: function () {
          this.leftHand = document.getElementById('leftHand');
          this.rightHand = document.getElementById('rightHand');
          this.rotVel = { x: 0, y: 0, z: 0 }; 
          this.forwardSpeed = this.data.maxSpeed * 0.06; 
        },
        tick: function (time, timeDelta) {
          if(this.el.sceneEl.systems['game-manager'].gameOver) return;
          if (this.leftHand) {
            let controls = this.leftHand.components['tracked-controls'];
            if (controls && controls.axis && controls.axis.length >= 4) {
              let inputYaw = controls.axis[2]; 
              let inputPitch = controls.axis[3]; 
              if (Math.abs(inputYaw) < 0.1) inputYaw = 0;
              if (Math.abs(inputPitch) < 0.1) inputPitch = 0;
              this.rotVel.x += inputPitch * this.data.turnSpeed;
              this.rotVel.y += (-inputYaw) * this.data.turnSpeed;
            }
          }
          let leftGrip = this.isGripDown(this.leftHand) ? 1 : 0;
          let rightGrip = this.isGripDown(this.rightHand) ? 1 : 0;
          if (leftGrip) this.rotVel.z += this.data.rollSpeed * 0.1;
          if (rightGrip) this.rotVel.z -= this.data.rollSpeed * 0.1;

          this.rotVel.x *= this.data.rotDrag;
          this.rotVel.y *= this.data.rotDrag;
          this.rotVel.z *= 0.95;

          let targetSpeed = this.data.maxSpeed * 0.06; 
          if (this.rightHand) {
            let controls = this.rightHand.components['tracked-controls'];
            if (controls && controls.axis && controls.axis.length >= 4) {
              let inputThrust = controls.axis[3]; 
              if (inputThrust < -0.5) targetSpeed = this.data.maxSpeed; 
              else if (inputThrust > 0.5) targetSpeed = this.data.maxSpeed * -0.05; 
            }
          }
          this.forwardSpeed += (targetSpeed - this.forwardSpeed) * this.data.accel;

          let audioSys = this.el.sceneEl.systems['game-audio'];
          if (audioSys && audioSys.engineOsc) {
              let baseFreq = 50 + (this.forwardSpeed * 20);
              audioSys.engineOsc.frequency.setTargetAtTime(baseFreq, audioSys.context.currentTime, 0.1);
          }
          this.el.object3D.rotateX(this.rotVel.x);
          this.el.object3D.rotateY(this.rotVel.y);
          this.el.object3D.rotateZ(this.rotVel.z); 
          this.el.object3D.translateZ(-this.forwardSpeed);
        },
        isGripDown: function(hand) {
            if (!hand) return false;
            let controls = hand.components['tracked-controls'];
            if (!controls || !controls.buttons) return false;
            let btn = controls.buttons[1];
            return btn && btn.value > 0.5;
        }
      });

      // =========================================================
      // 4. NEW AI
      // =========================================================
      AFRAME.registerComponent('enemy-drone', {
        schema: { wave: { type: 'number', default: 1 } },
        init: function() {
          this.ship = document.querySelector('#ship-rig');
          this.el.classList.add('enemy-hitbox'); 
          
          let difficulty = Math.min(10, this.data.wave);
          this.maxSpeed = 0.5 + (difficulty * 0.1); 
          this.agility = 0.015 + (difficulty * 0.003); 
          this.fireRate = Math.max(40, 120 - (difficulty * 5)); 
          this.fireCooldown = Math.random() * 100;
          this.accuracyError = Math.max(2, 10 - difficulty); 
          
          this.targetOffset = new THREE.Vector3(0,0,0);
          this.pickNewTarget();
        },
        pickNewTarget: function() {
           this.targetOffset.set(
              (Math.random() - 0.5) * 100, 
              (Math.random() - 0.5) * 60,  
              -30 - (Math.random() * 50)   
           );
           this.decisionTimer = 100 + Math.random() * 200; 
        },
        tick: function(time, timeDelta) {
          if (!this.ship) return;
          let shipObj = this.ship.object3D;
          let myObj = this.el.object3D;

          // LEASH
          let dist = myObj.position.distanceTo(shipObj.position);
          if (dist > 350) {
              this.targetOffset.set(0, 0, 0); 
              this.decisionTimer = 20; 
          } else {
              this.decisionTimer--;
              if (this.decisionTimer <= 0) this.pickNewTarget();
          }

          // Movement
          let dest = this.targetOffset.clone();
          dest.applyQuaternion(shipObj.quaternion);
          dest.add(shipObj.position);

          let desiredRot = new THREE.Quaternion();
          let lookMatrix = new THREE.Matrix4().lookAt(myObj.position, dest, new THREE.Vector3(0,1,0));
          desiredRot.setFromRotationMatrix(lookMatrix);
          
          myObj.quaternion.slerp(desiredRot, this.agility);
          myObj.translateZ(this.maxSpeed);

          // Combat
          if (dist < 150) {
             let toPlayer = shipObj.position.clone().sub(myObj.position).normalize();
             let forward = new THREE.Vector3(0,0,1).applyQuaternion(myObj.quaternion);
             let angle = toPlayer.angleTo(forward);

             if (angle < 0.8) {
                this.fireCooldown--;
                if (this.fireCooldown <= 0) {
                   this.fire(shipObj.position);
                   this.fireCooldown = this.fireRate + Math.random() * 20;
                }
             }
          }
        },
        fire: function(playerPos) {
          let scene = document.querySelector('a-scene');
          let laser = document.createElement('a-entity');
          laser.setAttribute('geometry', 'primitive: sphere; radius: 0.2');
          laser.setAttribute('material', 'color: #FF0000; emissive: #FF0000; emissiveIntensity: 5');
          laser.object3D.position.copy(this.el.object3D.position);
          
          let spread = new THREE.Vector3(
             (Math.random()-0.5) * this.accuracyError,
             (Math.random()-0.5) * this.accuracyError,
             (Math.random()-0.5) * this.accuracyError
          );
          let aimedPos = playerPos.clone().add(spread);
          
          laser.object3D.lookAt(aimedPos);
          laser.setAttribute('enemy-laser', '');
          scene.appendChild(laser);
          this.el.sceneEl.systems['game-audio'].playLaser(true);
        },
        hit: function() {
          let scene = document.querySelector('a-scene');
          let explosion = document.createElement('a-entity');
          explosion.setAttribute('position', this.el.object3D.position);
          explosion.setAttribute('explosion-effect', '');
          scene.appendChild(explosion);
          this.el.sceneEl.systems['game-audio'].playExplosion();
          this.el.sceneEl.systems['game-manager'].enemyDestroyed(100);
          if(this.el.parentNode) this.el.parentNode.removeChild(this.el);
        }
      });

      AFRAME.registerComponent('enemy-laser', {
        init: function() {
           this.speed = 1.0; 
           this.ship = document.querySelector('#ship-rig');
        },
        tick: function() {
           this.el.object3D.translateZ(this.speed);
           if (this.ship.object3D.position.distanceTo(this.el.object3D.position) > 300) {
              if(this.el.parentNode) this.el.parentNode.removeChild(this.el);
              return;
           }
           if (this.el.object3D.position.distanceTo(this.ship.object3D.position) < 2.5) { 
              this.el.sceneEl.systems['game-manager'].playerHit(10);
              this.el.sceneEl.systems['game-audio'].playImpact();
              if(this.el.parentNode) this.el.parentNode.removeChild(this.el);
           }
        }
      });

      // =========================================================
      // 5. SPAWNER
      // =========================================================
      AFRAME.registerComponent('drone-spawner', {
        init: function() {
          this.ship = document.querySelector('#ship-rig');
          this.el.sceneEl.systems['game-manager'].spawnWave();
        },
        spawnBatch: function(count, waveNumber) {
          let scene = document.querySelector('a-scene');
          let shipPos = this.ship.object3D.position;
          for(let i=0; i<count; i++) {
            let parent = document.createElement('a-entity');
            parent.setAttribute('enemy-drone', `wave: ${waveNumber}`);
            let visual = document.createElement('a-entity');
            visual.setAttribute('gltf-model', '#drone-asset');
            visual.setAttribute('scale', '0.002 0.002 0.002');
            visual.setAttribute('rotation', '0 -90 0');
            let light = document.createElement('a-entity');
            light.setAttribute('geometry', 'primitive: sphere; radius: 1.0'); 
            light.setAttribute('material', 'color: orange; emissive: orange; emissiveIntensity: 2');
            light.setAttribute('position', '0 0 1'); 
            visual.appendChild(light);
            parent.appendChild(visual);
            let angle = Math.random() * Math.PI * 2;
            let dist = 200 + Math.random() * 100;
            parent.object3D.position.set(shipPos.x + Math.cos(angle) * dist, shipPos.y + (Math.random() - 0.5) * 50, shipPos.z + Math.sin(angle) * dist);
            scene.appendChild(parent);
          }
        }
      });

      // =========================================================
      // 6. PLAYER WEAPONS
      // =========================================================
      AFRAME.registerComponent('laser-shooter', {
        init: function () {
          this.el.addEventListener('triggerdown', this.shoot.bind(this));
          this.ship = document.querySelector('#ship-rig'); 
        },
        shoot: function () {
          if(this.el.sceneEl.systems['game-manager'].gameOver) return;
          this.fireLaser(0.8);  
          this.fireLaser(-0.8); 
          this.el.sceneEl.systems['game-audio'].playLaser(false);
        },
        fireLaser: function(xOffset) {
          let scene = document.querySelector('a-scene');
          let laser = document.createElement('a-entity');
          laser.setAttribute('geometry', 'primitive: cylinder; height: 3; radius: 0.05');
          laser.setAttribute('material', 'color: #00FF00; emissive: #00FF00; emissiveIntensity: 3');
          laser.object3D.position.copy(this.ship.object3D.position);
          laser.object3D.quaternion.copy(this.ship.object3D.quaternion);
          laser.object3D.rotateX(-Math.PI / 2); 
          laser.object3D.translateY(1.0); 
          laser.object3D.translateX(xOffset); 
          laser.setAttribute('laser-move', '');
          scene.appendChild(laser);
          let flash = document.createElement('a-entity');
          flash.setAttribute('geometry', 'primitive: plane; width: 0.5; height: 0.5');
          flash.setAttribute('material', 'color: #AAFF00; shader: flat; transparent: true; opacity: 1; side: double');
          flash.object3D.position.copy(this.ship.object3D.position);
          flash.object3D.quaternion.copy(this.ship.object3D.quaternion);
          flash.object3D.translateZ(-2.5); 
          flash.object3D.translateX(xOffset);
          flash.object3D.translateY(-1.0);
          flash.setAttribute('animation', 'property: opacity; to: 0; dur: 100; easing: linear');
          scene.appendChild(flash);
          setTimeout(() => { if(flash.parentNode) flash.parentNode.removeChild(flash); }, 100);
        }
      });

      AFRAME.registerComponent('laser-move', {
        tick: function () {
          this.el.object3D.translateY(4.0); 
          let enemies = document.querySelectorAll('.enemy-hitbox');
          let laserPos = this.el.object3D.position;
          for (let i = 0; i < enemies.length; i++) {
             let enemyParent = enemies[i];
             if (laserPos.distanceTo(enemyParent.object3D.position) < 4.0) {
                enemyParent.components['enemy-drone'].hit(); 
                this.el.parentNode.removeChild(this.el); 
                return; 
             }
          }
          let shipPos = document.querySelector('#ship-rig').object3D.position;
          if (this.el.object3D.position.distanceTo(shipPos) > 800) {
            if(this.el.parentNode) this.el.parentNode.removeChild(this.el);
          }
        }
      });

      // =========================================================
      // 7. FX
      // =========================================================
      AFRAME.registerComponent('explosion-effect', {
        init: function() {
          let flash = document.createElement('a-sphere');
          flash.setAttribute('radius', 1);
          flash.setAttribute('color', 'white');
          flash.setAttribute('shader', 'flat');
          flash.setAttribute('opacity', 1);
          this.el.appendChild(flash);
          this.flashEl = flash;
          this.particles = [];
          for(let i=0; i<15; i++) {
             let part = document.createElement('a-sphere');
             part.setAttribute('radius', 0.2 + Math.random() * 0.4);
             part.setAttribute('color', Math.random() > 0.5 ? '#FF4400' : '#FFFF00'); 
             part.setAttribute('shader', 'flat');
             this.el.appendChild(part);
             this.particles.push({el: part, dir: { x: (Math.random()-0.5)*0.8, y: (Math.random()-0.5)*0.8, z: (Math.random()-0.5)*0.8 }});
          }
          this.life = 40; 
        },
        tick: function() {
          this.life--;
          if (this.life <= 0) { this.el.parentNode.removeChild(this.el); return; }
          if (this.flashEl) {
             let s = this.flashEl.object3D.scale.x + 0.5;
             this.flashEl.object3D.scale.set(s,s,s);
             this.flashEl.setAttribute('opacity', this.life / 40); 
          }
          for(let p of this.particles) {
             p.el.object3D.position.x += p.dir.x;
             p.el.object3D.position.y += p.dir.y;
             p.el.object3D.position.z += p.dir.z;
             let s = p.el.object3D.scale.x * 0.9; 
             p.el.object3D.scale.set(s,s,s);
          }
        }
      });
      
      AFRAME.registerComponent('camera-shaker', {
        init: function() {
          this.intensity = 0;
          this.originalPos = this.el.object3D.position.clone();
        },
        shake: function(amount) { this.intensity = amount; },
        tick: function() {
          if (this.intensity > 0) {
            let rx = (Math.random() - 0.5) * this.intensity;
            let ry = (Math.random() - 0.5) * this.intensity;
            let rz = (Math.random() - 0.5) * this.intensity;
            this.el.object3D.position.set(this.originalPos.x + rx, this.originalPos.y + ry, this.originalPos.z + rz);
            this.intensity *= 0.9;
            if(this.intensity < 0.01) { this.intensity = 0; this.el.object3D.position.copy(this.originalPos); }
          }
        }
      });

      AFRAME.registerComponent('hud-binder', {
        init: function() {
          let scoreEl = document.querySelector('#hud-display-left');
          let waveEl = document.querySelector('#hud-display-right');
          let arrowEl = document.querySelector('#nav-arrow-wrapper');
          let ship = document.querySelector('#ship-rig');
          this.el.sceneEl.systems['game-manager'].registerUI(scoreEl, waveEl, arrowEl, ship);
        }
      });

      AFRAME.registerComponent('infinite-star-field', {
        init: function() {
          this.stars = [];
          this.ship = document.querySelector('#ship-rig');
          for(let i=0; i<600; i++) {
            let star = document.createElement('a-sphere');
            let pos = this.randomPos(500);
            star.setAttribute('position', pos);
            star.setAttribute('radius', Math.random() * 0.3 + 0.05);
            star.setAttribute('color', 'white');
            star.setAttribute('shader', 'flat');
            this.el.appendChild(star);
            this.stars.push(star);
          }
        },
        randomPos: function(radius) {
            let x = (Math.random() - 0.5) * 2 * radius; let y = (Math.random() - 0.5) * 2 * radius; let z = (Math.random() - 0.5) * 2 * radius;
            return {x, y, z};
        },
        tick: function() {
          let shipPos = this.ship.object3D.position;
          for (let star of this.stars) {
             let dist = star.object3D.position.distanceTo(shipPos);
             if (dist > 400) {
                let offset = this.randomPos(350); 
                star.object3D.position.set(shipPos.x + offset.x, shipPos.y + offset.y, shipPos.z + offset.z);
             }
           }
        }
      });

      AFRAME.registerComponent('planet-system', {
        init: function() {
          this.planets = [];
          this.ship = document.querySelector('#ship-rig');
          let colors = ['#FF4444', '#4444FF', '#AA8822'];
          for(let i=0; i<3; i++) {
            let planet = document.createElement('a-sphere');
            let pos = this.randomPos(2000, 4000);
            planet.setAttribute('position', pos);
            planet.setAttribute('radius', Math.random() * 300 + 100); 
            planet.setAttribute('color', colors[i]);
            planet.setAttribute('roughness', 1);
            this.el.appendChild(planet);
            this.planets.push(planet);
          }
        },
        randomPos: function(min, max) {
            let dirX = (Math.random() - 0.5); let dirY = (Math.random() - 0.5); let dirZ = (Math.random() - 0.5);
            let len = Math.sqrt(dirX*dirX + dirY*dirY + dirZ*dirZ);
            let dist = min + Math.random() * (max - min);
            return { x: (dirX / len) * dist, y: (dirY / len) * dist, z: (dirZ / len) * dist };
        },
        tick: function() {
           let shipPos = this.ship.object3D.position;
           for(let planet of this.planets) {
             if(planet.object3D.position.distanceTo(shipPos) > 5000) {
                let offset = this.randomPos(2000, 4000);
                planet.object3D.position.set(shipPos.x + offset.x, shipPos.y + offset.y, shipPos.z + offset.z);
             }
           }
        }
      });
    </script>

    <a-scene background="color: #000000" drone-spawner hud-binder renderer="useLegacyLights: false">
      <a-assets>
        <a-asset-item id="cockpit-asset" src="cockpit.glb"></a-asset-item>
        <a-asset-item id="drone-asset" src="drone.glb"></a-asset-item>
      </a-assets>

      <a-entity infinite-star-field></a-entity>
      <a-entity planet-system></a-entity>
      <a-light type="ambient" color="#888"></a-light>
      <a-light type="directional" position="0.5 1 0" intensity="0.8" color="#FFFFAA"></a-light>
      
      <a-entity id="ship-rig" position="0 0 0" ship-controls>

        <a-entity id="cam-wrapper" camera-shaker>
          <a-entity camera position="0 0 0" look-controls="pointerLockEnabled: false">
            <a-entity id="damage-overlay" 
                      geometry="primitive: plane; width: 4; height: 4" 
                      material="color: #FF0000; transparent: true; opacity: 0; shader: flat; depthTest: false; depthWrite: false" 
                      position="0 0 -0.1"
                      visible="false"></a-entity>
          </a-entity>
        </a-entity>

        <a-entity 
          gltf-model="#cockpit-asset" 
          position="-0.045 -2.993 -1.567" 
          rotation="0 180 0" 
          scale="1.479 1.479 1.479">
        </a-entity>

        <a-text id="hud-display-left" 
                value="INIT..." 
                font="sourcecodepro" 
                color="#00FF00" 
                width="4"
                scale="0.1 0.1 0.1" 
                position="-0.347 0.522 -0.693" 
                rotation="-25 10 -1"
                align="center">
        </a-text>

        <a-text id="hud-display-right" 
                value="SCANNING..." 
                font="sourcecodepro" 
                color="#00FF00" 
                width="4"
                scale="0.1 0.1 0.1" 
                position="0.258 0.526 -0.689" 
                rotation="-25 -10 1"
                align="center">
        </a-text>

        <!-- Center: 3D HOLOGRAPHIC NAV ARROW (Fixed Rotation) -->
        <a-entity id="nav-arrow-wrapper" position="-0.045 0.774 -0.671" visible="false">
            <!-- Rotated 90 on X so Top (+Y) points to Back (+Z) and Base (-Y) points to Forward (-Z) -->
            <!-- Wait, lookAt points -Z (Forward) to target. -->
            <!-- If we want Tip to point to target, Tip needs to be at -Z -->
            <!-- Tip is +Y. Rotate X -90 => +Y becomes -Z. -->
            <!-- User said -90 was wrong (Fat end pointing). That implies Base was at -Z. -->
            <!-- So we try 90. +Y becomes +Z. -Y becomes -Z. Base points to target? -->
            <!-- Actually, let's just rotate 90 0 0 as requested to flip it. -->
            <a-cone id="nav-arrow-geo" 
                    radius-bottom="0.05" radius-top="0" height="0.2" 
                    material="color: #00FFFF; opacity: 0.8; transparent: true; shader: flat; depthTest: false"
                    rotation="90 0 0">
            </a-cone>
        </a-entity>

        <a-entity id="leftHand" oculus-touch-controls="hand: left; model: false"></a-entity>
        <a-entity id="rightHand" oculus-touch-controls="hand: right; model: false" laser-shooter></a-entity>
        
      </a-entity>
    </a-scene>
  </body>
</html>