<!DOCTYPE html>
<html>
  <head>
    <title>VR Spaceship - Advanced Combat</title>
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-environment-component@1.3.3/dist/aframe-environment-component.min.js"></script>
  </head>
  <body>
    <script>
      // =========================================================
      // 1. AUDIO SYSTEM
      // =========================================================
      AFRAME.registerSystem('game-audio', {
        init: function() {
          this.context = new (window.AudioContext || window.webkitAudioContext)();
          this.engineOsc = null;
          this.engineGain = null;
          this.setupEngineSound();
        },
        setupEngineSound: function() {
          if (this.context.state === 'suspended') this.context.resume();
          this.engineOsc = this.context.createOscillator();
          this.engineGain = this.context.createGain();
          this.engineOsc.type = 'sawtooth';
          this.engineOsc.frequency.value = 50;
          this.engineGain.gain.value = 0.05; 
          this.engineOsc.connect(this.engineGain);
          this.engineGain.connect(this.context.destination);
          this.engineOsc.start();
        },
        playLaser: function(isEnemy) {
          if (this.context.state === 'suspended') this.context.resume();
          let osc = this.context.createOscillator();
          let gain = this.context.createGain();
          osc.connect(gain);
          gain.connect(this.context.destination);
          if (isEnemy) {
            osc.type = 'square';
            osc.frequency.setValueAtTime(300, this.context.currentTime); 
            osc.frequency.linearRampToValueAtTime(100, this.context.currentTime + 0.3);
            gain.gain.setValueAtTime(0.05, this.context.currentTime);
            gain.gain.linearRampToValueAtTime(0, this.context.currentTime + 0.3);
            osc.start();
            osc.stop(this.context.currentTime + 0.3);
          } else {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(800, this.context.currentTime);
            osc.frequency.exponentialRampToValueAtTime(200, this.context.currentTime + 0.15);
            gain.gain.setValueAtTime(0.1, this.context.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.15);
            osc.start();
            osc.stop(this.context.currentTime + 0.15);
          }
        },
        playExplosion: function() {
          if (this.context.state === 'suspended') this.context.resume();
          let now = this.context.currentTime;
          // Noise burst with a lowpass sweep for crunch
          let bufferSize = this.context.sampleRate * 0.6; 
          let buffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
          let data = buffer.getChannelData(0);
          for(let i=0; i<bufferSize; i++) data[i] = Math.random() * 2 - 1;
          let noise = this.context.createBufferSource();
          noise.buffer = buffer;
          let noiseFilter = this.context.createBiquadFilter();
          noiseFilter.type = 'lowpass';
          noiseFilter.frequency.setValueAtTime(900, now);
          noiseFilter.frequency.exponentialRampToValueAtTime(220, now + 0.5);
          let noiseGain = this.context.createGain();
          noiseGain.gain.setValueAtTime(0.35, now);
          noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
          noise.connect(noiseFilter);
          noiseFilter.connect(noiseGain);
          noiseGain.connect(this.context.destination);
          // Low thump for body
          let thump = this.context.createOscillator();
          let thumpGain = this.context.createGain();
          thump.type = 'sawtooth';
          thump.frequency.setValueAtTime(120, now);
          thump.frequency.exponentialRampToValueAtTime(40, now + 0.5);
          thumpGain.gain.setValueAtTime(0.3, now);
          thumpGain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
          thump.connect(thumpGain);
          thumpGain.connect(this.context.destination);
          noise.start(now);
          noise.stop(now + 0.6);
          thump.start(now);
          thump.stop(now + 0.6);
        },
        playImpact: function() {
          if (this.context.state === 'suspended') this.context.resume();
          let osc = this.context.createOscillator();
          let gain = this.context.createGain();
          osc.connect(gain);
          gain.connect(this.context.destination);
          osc.type = 'triangle';
          osc.frequency.setValueAtTime(100, this.context.currentTime);
          osc.frequency.linearRampToValueAtTime(50, this.context.currentTime + 0.1);
          gain.gain.setValueAtTime(0.3, this.context.currentTime);
          gain.gain.linearRampToValueAtTime(0, this.context.currentTime + 0.1);
          osc.start();
          osc.stop(this.context.currentTime + 0.1);
        }
      });

      // =========================================================
      // 2. GAME MANAGER
      // =========================================================
      AFRAME.registerSystem('game-manager', {
        init: function() {
          this.score = 0;
          this.wave = 1;
          this.enemiesRemaining = 0;
          this.isSpawning = false;
          this.playerHealth = 100;
          this.gameOver = false;
          this.lastHitTime = 0;
          this.leftText = null;
          this.rightText = null;
          this.navArrow = null; 
          this.powerArrow = null;
          this.ship = null;
          this.restartHandler = null;
        },
        registerUI: function(left, right, arrow, ship, powerArrow) {
          this.leftText = left;
          this.rightText = right;
          this.navArrow = arrow;
          this.powerArrow = powerArrow;
          this.ship = ship;
        },
        tick: function(t, dt) {
          if (this.gameOver || !this.ship) return;
          // Shield Regen
          if (t - this.lastHitTime > 5000 && this.playerHealth < 100) {
            this.playerHealth += 0.05 * (dt/16);
            if(this.playerHealth > 100) this.playerHealth = 100;
          }
          // Radar Logic
          let enemies = document.querySelectorAll('.enemy-hitbox');
          let closestDist = 9999;
          let closestEnemy = null;
          let shipPos = this.ship.object3D.position;
          let closestPowerup = null;
          let closestPowerDist = 9999;
          enemies.forEach(el => {
            let dist = el.object3D.position.distanceTo(shipPos);
            if (dist < closestDist) { closestDist = dist; closestEnemy = el; }
          });
          let powerups = document.querySelectorAll('.powerup-item');
          powerups.forEach(el => {
            let dist = el.object3D.position.distanceTo(shipPos);
            if (dist < closestPowerDist) { closestPowerDist = dist; closestPowerup = el; }
          });
          this.updateHUD(closestEnemy, closestDist, closestPowerup);
        },
        updateHUD: function(closestEnemy, dist, closestPowerup) {
          // LEFT HUD
          if (this.leftText) {
            let vTrack = "---";
            if (closestEnemy) {
               let localPos = closestEnemy.object3D.position.clone();
               this.ship.object3D.worldToLocal(localPos);
               if (localPos.y > 5) vTrack = "?-? UP";
               else if (localPos.y < -5) vTrack = "?-? DWN";
               else vTrack = "?-? LEVEL";
            }
            let shipSpeed = 0;
            if (this.ship && this.ship.components['ship-controls']) {
               shipSpeed = this.ship.components['ship-controls'].forwardSpeed || 0;
            }
            let weaponLine = "WPN: ---";
            let rightHand = document.getElementById('rightHand');
            if (rightHand && rightHand.components['laser-shooter']) {
               let shooter = rightHand.components['laser-shooter'];
               let type = (shooter.currentWeapon || 'pulse').toUpperCase();
               let lvl = (shooter.weaponLevels && shooter.weaponLevels[shooter.currentWeapon]) || 1;
               weaponLine = `WPN: ${type} L${lvl}`;
            }
            let healthInt = Math.floor(this.playerHealth);
            let color = healthInt < 30 ? "#FF0000" : "#00FF00";
            this.leftText.setAttribute('color', color);
            this.leftText.setAttribute('value', `SHIELD: ${healthInt}%\nSCORE: ${this.score}\nSPEED: ${shipSpeed.toFixed(2)}\n${weaponLine}\nV-TRACK: ${vTrack}`);
          }
          // RIGHT HUD
          if (this.rightText) {
             let proxMsg = "CLEAR";
             let distDisplay = "----";
             let enemiesLeft = this.enemiesRemaining;
             let waveState = this.isSpawning ? "RECHARGING" : "ENGAGED";
             if (closestEnemy) {
               distDisplay = Math.floor(dist) + "m";
               if (dist < 40) proxMsg = "!DANGER!";
               else if (dist < 100) proxMsg = "WARNING";
               else proxMsg = "TRACKING";
             }
             this.rightText.setAttribute('value', `WAVE: ${this.wave}\n(${waveState})\nPROX: ${proxMsg}\nDIST: ${distDisplay}\nENM: ${enemiesLeft}`);
          }
          // NAVIGATION ARROW
          if (this.navArrow) {
            if (closestEnemy) {
              this.navArrow.object3D.visible = true;
              this.navArrow.object3D.lookAt(closestEnemy.object3D.position);
            } else {
              this.navArrow.object3D.visible = false;
            }
          }
          // POWERUP ARROW
          if (this.powerArrow) {
            if (closestPowerup) {
              this.powerArrow.object3D.visible = true;
              this.powerArrow.object3D.lookAt(closestPowerup.object3D.position);
            } else {
              this.powerArrow.object3D.visible = false;
            }
          }
        },
        enemyDestroyed: function(points, position) {
          if(this.gameOver) return;
          this.score += points;
          this.enemiesRemaining--;
          // 20% chance to spawn a powerup at the destroyed enemy location
          if (position && Math.random() < 0.2) {
            let powerSpawner = this.el.components['powerup-spawner'];
            if (powerSpawner && powerSpawner.spawnPowerupAt) {
              powerSpawner.spawnPowerupAt(position);
            }
          }
          if (this.enemiesRemaining <= 0 && !this.isSpawning) this.startNextWave();
        },
        startNextWave: function() {
          this.isSpawning = true;
          if(this.rightText) this.rightText.setAttribute('value', "WAVE COMPLETE\nRECHARGING...");
          setTimeout(() => { this.wave++; this.spawnWave(); }, 3000);
        },
        spawnWave: function() {
          if(this.gameOver) return;
          let enemyCount = 3 + Math.floor(this.wave * 1.5); 
          this.enemiesRemaining = enemyCount;
          let spawner = this.el.components['drone-spawner'];
          if(spawner) spawner.spawnBatch(enemyCount, this.wave);
          this.isSpawning = false;
        },
        playerHit: function(damage) {
          if(this.gameOver) return;
          this.playerHealth -= damage;
          this.lastHitTime = performance.now();

          if (this.playerHealth <= 0) this.endGame();
        },
        endGame: function() {
          this.gameOver = true;
          let text = document.createElement('a-text');
          text.setAttribute('value', 'SYSTEM FAILURE');
          text.setAttribute('color', 'red');
          text.setAttribute('align', 'center');
          text.setAttribute('position', '0 0 -2');
          text.setAttribute('scale', '2 2 2');
          document.querySelector('[camera]').appendChild(text);
          let prompt = document.createElement('a-text');
          prompt.setAttribute('value', 'Press trigger to restart');
          prompt.setAttribute('color', '#FFFFFF');
          prompt.setAttribute('align', 'center');
          prompt.setAttribute('position', '0 -0.5 -2');
          prompt.setAttribute('scale', '1 1 1');
          document.querySelector('[camera]').appendChild(prompt);
          this.restartHandler = () => { window.location.reload(); };
          window.addEventListener('triggerdown', this.restartHandler, { once: true });
          window.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') this.restartHandler();
          }, { once: true });
          let audioSys = this.el.sceneEl.systems['game-audio'];
          if(audioSys.engineGain) audioSys.engineGain.gain.linearRampToValueAtTime(0, audioSys.context.currentTime + 1);
        }
      });

      // =========================================================
      // 3. SHIP CONTROLS
      // =========================================================
      AFRAME.registerComponent('ship-controls', {
        schema: {
          accel: { type: 'number', default: 0.001 },      
          maxSpeed: { type: 'number', default: 5.0 },    
          turnSpeed: { type: 'number', default: 0.00018 },
          rollSpeed: { type: 'number', default: 0.015 },  
          rotDrag: { type: 'number', default: 0.982 }      
        },
        init: function () {
          this.leftHand = document.getElementById('leftHand');
          this.rightHand = document.getElementById('rightHand');
          this.rotVel = { x: 0, y: 0, z: 0 }; 
          this.forwardSpeed = this.data.maxSpeed * 0.06; 
        },
        tick: function (time, timeDelta) {
          if(this.el.sceneEl.systems['game-manager'].gameOver) return;
          if (this.leftHand) {
            let controls = this.leftHand.components['tracked-controls'];
            if (controls && controls.axis && controls.axis.length >= 4) {
              let inputYaw = controls.axis[2]; 
              let inputPitch = controls.axis[3]; 
              if (Math.abs(inputYaw) < 0.1) inputYaw = 0;
              if (Math.abs(inputPitch) < 0.1) inputPitch = 0;
              this.rotVel.x += inputPitch * this.data.turnSpeed;
              this.rotVel.y += (-inputYaw) * this.data.turnSpeed;
            }
          }
          let rollInput = this.getRollInput();
          if (Math.abs(rollInput) > 0.05) {
            this.rotVel.z += rollInput * this.data.rollSpeed;
          }

          this.rotVel.x *= this.data.rotDrag;
          this.rotVel.y *= this.data.rotDrag;
          this.rotVel.z *= this.data.rotDrag;
          this.rotVel.z = THREE.MathUtils.clamp(this.rotVel.z, -0.05, 0.05);

          let targetSpeed = this.data.maxSpeed * 0.03; 
          if (this.rightHand) {
            let controls = this.rightHand.components['tracked-controls'];
            if (controls && controls.axis && controls.axis.length >= 4) {
              let inputThrust = controls.axis[3]; 
              if (inputThrust < -0.5) targetSpeed = this.data.maxSpeed; 
              else if (inputThrust > 0.5) targetSpeed = this.data.maxSpeed * -0.1; 
            }
          }
          this.forwardSpeed += (targetSpeed - this.forwardSpeed) * this.data.accel;

          let audioSys = this.el.sceneEl.systems['game-audio'];
          if (audioSys && audioSys.engineOsc) {
              let baseFreq = 50 + (this.forwardSpeed * 20);
              audioSys.engineOsc.frequency.setTargetAtTime(baseFreq, audioSys.context.currentTime, 0.1);
          }
          this.el.object3D.rotateX(this.rotVel.x);
          this.el.object3D.rotateY(this.rotVel.y);
          this.el.object3D.rotateZ(this.rotVel.z); 
          this.el.object3D.translateZ(-this.forwardSpeed);
        },
        getGripValue: function(hand) {
            if (!hand) return 0;
            let controls = hand.components['tracked-controls'];
            let values = [];
            if (controls && controls.buttons) {
              [1,2].forEach(idx => {
                let btn = controls.buttons[idx];
                if (btn) values.push(btn.value || (btn.pressed ? 1 : 0));
              });
            }
            // Quest 3 grip fallback via gamepad (oculus-touch-controls)
            let oculus = hand.components['oculus-touch-controls'];
            if (oculus && oculus.controller && oculus.controller.gamepad && oculus.controller.gamepad.buttons) {
              let gp = oculus.controller.gamepad.buttons;
              [1,2].forEach(idx => {
                let btn = gp[idx];
                if (btn) values.push(btn.value || (btn.pressed ? 1 : 0));
              });
            }
            return values.length ? Math.max(...values) : 0;
        },
        getRollInput: function() {
            let left = this.getGripValue(this.leftHand);
            let right = this.getGripValue(this.rightHand);
            return (left - right);
        }
      });

      // =========================================================
      // 4. NEW AI
      // =========================================================
      AFRAME.registerComponent('enemy-drone', {
        schema: { wave: { type: 'number', default: 1 } },
        init: function() {
          this.ship = document.querySelector('#ship-rig');
          this.el.classList.add('enemy-hitbox'); 
          
          let difficulty = Math.max(1, this.data.wave);
          let growth = difficulty - 1; // incremental per wave
          // Base abilities start below the player but scale up slightly each wave
          this.maxSpeed = 0.5 + (growth * 0.05); // forward thrust potential (frame scaled)
          this.accel = 0.01 + (growth * 0.003); // how quickly velocity chases desired vector
          this.turnRate = 0.03 + (growth * 0.004); // rotational agility for slerp
          this.driftDamping = 0.14; // how much velocity bleeds off (keeps some slide)
          this.maxSpeed = Math.min(this.maxSpeed, 3.5); // allow late waves to overtake player pace
          this.accel = Math.min(this.accel, 0.08);
          this.turnRate = Math.min(this.turnRate, 0.5);

          this.fireRate = Math.max(40, 120 - (difficulty * 5)); 
          this.fireCooldown = Math.random() * 100;
          this.accuracyError = Math.max(0.6, 8 - difficulty * 0.35); 
          
          this.targetOffset = new THREE.Vector3(0,0,0);
          this.pickNewTarget();
          this.vel = new THREE.Vector3(); // carries drift
        },
        pickNewTarget: function() {
           this.targetOffset.set(
              (Math.random() - 0.5) * 60,   // lateral strafe near player
              (Math.random() - 0.5) * 40,   // small vertical offset
              (Math.random() * 40) - 10     // slight lead/lag instead of fleeing
           );
           this.decisionTimer = 100 + Math.random() * 200; 
        },
        tick: function(time, timeDelta) {
          if (!this.ship) return;
          let shipObj = this.ship.object3D;
          let myObj = this.el.object3D;
          let dt = timeDelta || 16;
          let frameScale = dt / 16.666;

          // LEASH
          let dist = myObj.position.distanceTo(shipObj.position);
          if (dist > 450) {
              this.targetOffset.set(0, 0, 0); 
              this.decisionTimer = 20; 
          } else {
              this.decisionTimer--;
              if (this.decisionTimer <= 0) this.pickNewTarget();
          }

          // Movement
          let dest = this.targetOffset.clone();
          dest.applyQuaternion(shipObj.quaternion);
          dest.add(shipObj.position);

          // Turn toward the target with limited agility
          let desiredRot = new THREE.Quaternion();
          let lookMatrix = new THREE.Matrix4().lookAt(myObj.position, dest, new THREE.Vector3(0,1,0));
          desiredRot.setFromRotationMatrix(lookMatrix);
          let turnLerp = Math.min(this.turnRate * frameScale, 0.35);
          myObj.quaternion.slerp(desiredRot, turnLerp);

          // Drift-aware velocity blend toward facing direction (-Z is the lookAt forward in three.js)
          let forward = new THREE.Vector3(0,0,-1).applyQuaternion(myObj.quaternion);
          let desiredVel = forward.multiplyScalar(this.maxSpeed);
          let accelLerp = Math.min(this.accel * frameScale, 0.6);
          this.vel.lerp(desiredVel, accelLerp);
          // bleed a little speed but keep slide
          this.vel.multiplyScalar(1 - this.driftDamping * frameScale);
          myObj.position.addScaledVector(this.vel, frameScale);

          // Combat
          if (dist < 350) {
             let toPlayer = shipObj.position.clone().sub(myObj.position).normalize();
             let forward = new THREE.Vector3(0,0,-1).applyQuaternion(myObj.quaternion);
             let angle = toPlayer.angleTo(forward);

             if (angle < 0.6) {
                this.fireCooldown--;
                if (this.fireCooldown <= 0) {
                   this.fire(shipObj.position);
                   this.fireCooldown = this.fireRate + Math.random() * 20;
                }
             }
          }
        },
        fire: function(playerPos) {
          let scene = document.querySelector('a-scene');
          let laser = document.createElement('a-entity');
          laser.setAttribute('geometry', 'primitive: sphere; radius: 0.2');
          laser.setAttribute('material', 'color: #FF0000; emissive: #FF0000; emissiveIntensity: 5');
          laser.object3D.position.copy(this.el.object3D.position);
          
          let spread = new THREE.Vector3(
             (Math.random()-0.5) * this.accuracyError,
             (Math.random()-0.5) * this.accuracyError,
             (Math.random()-0.5) * this.accuracyError
          );
          let aimedPos = playerPos.clone().add(spread);
          
          laser.object3D.lookAt(aimedPos);
          laser.setAttribute('enemy-laser', '');
          scene.appendChild(laser);
          this.el.sceneEl.systems['game-audio'].playLaser(true);
        },
        hit: function() {
          let scene = document.querySelector('a-scene');
          let explosion = document.createElement('a-entity');
          explosion.setAttribute('position', this.el.object3D.position);
          explosion.setAttribute('explosion-effect', '');
          scene.appendChild(explosion);
          this.el.sceneEl.systems['game-audio'].playExplosion();
          this.el.sceneEl.systems['game-manager'].enemyDestroyed(100, this.el.object3D.position.clone());
          if(this.el.parentNode) this.el.parentNode.removeChild(this.el);
        }
      });

      AFRAME.registerComponent('enemy-laser', {
        init: function() {
           this.speed = 1.0; 
           this.ship = document.querySelector('#ship-rig');
        },
       tick: function() {
           // laser was aimed with lookAt; advance along local +Z toward the aimed point
           this.el.object3D.translateZ(this.speed);
           if (this.ship.object3D.position.distanceTo(this.el.object3D.position) > 300) {
              if(this.el.parentNode) this.el.parentNode.removeChild(this.el);
              return;
           }
           if (this.el.object3D.position.distanceTo(this.ship.object3D.position) < 2.5) { 
              this.el.sceneEl.systems['game-manager'].playerHit(10);
              this.el.sceneEl.systems['game-audio'].playImpact();
              if(this.el.parentNode) this.el.parentNode.removeChild(this.el);
           }
        }
      });

      // =========================================================
      // 5. SPAWNER
      // =========================================================
      AFRAME.registerComponent('drone-spawner', {
        init: function() {
          this.ship = document.querySelector('#ship-rig');
          this.el.sceneEl.systems['game-manager'].spawnWave();
        },
        spawnBatch: function(count, waveNumber) {
          let scene = document.querySelector('a-scene');
          let shipPos = this.ship.object3D.position;
          for(let i=0; i<count; i++) {
            let parent = document.createElement('a-entity');
            parent.setAttribute('enemy-drone', `wave: ${waveNumber}`);
            let visual = document.createElement('a-entity');
            visual.setAttribute('gltf-model', '#drone-asset');
            visual.setAttribute('scale', '0.002 0.002 0.002');
            // Align the model so its nose matches parent -Z (lookAt forward). Flipping Y fixes "backwards" visuals.
            visual.setAttribute('rotation', '0 90 0');
            let light = document.createElement('a-entity');
            light.setAttribute('geometry', 'primitive: sphere; radius: 1.0'); 
            light.setAttribute('material', 'color: orange; emissive: orange; emissiveIntensity: 2');
            light.setAttribute('position', '0 0 1'); 
            visual.appendChild(light);
            parent.appendChild(visual);
            let angle = Math.random() * Math.PI * 2;
            let dist = 800 + Math.random() * 100;
            parent.object3D.position.set(shipPos.x + Math.cos(angle) * dist, shipPos.y + (Math.random() - 0.5) * 50, shipPos.z + Math.sin(angle) * dist);
            scene.appendChild(parent);
          }
        }
      });

      // =========================================================
      // 6. PLAYER WEAPONS
      // =========================================================
      AFRAME.registerComponent('laser-shooter', {
        init: function () {
          this.el.addEventListener('triggerdown', this.shoot.bind(this));
          this.ship = document.querySelector('#ship-rig'); 
          this.weaponLevels = { pulse: 1, spread: 1, mine: 1 };
          this.currentWeapon = 'pulse';
          this.maxLevel = 5;
          this.applyPower = this.applyPower.bind(this);
          this.el.sceneEl.addEventListener('weapon-powerup-collected', this.applyPower);
        },
        remove: function() {
          if (this.el && this.el.sceneEl) {
            this.el.sceneEl.removeEventListener('weapon-powerup-collected', this.applyPower);
          }
        },
        shoot: function () {
          if(this.el.sceneEl.systems['game-manager'].gameOver) return;
          if (this.currentWeapon === 'pulse') this.firePulse();
          else if (this.currentWeapon === 'spread') this.fireSpread();
          else if (this.currentWeapon === 'mine') this.fireMine();
          this.el.sceneEl.systems['game-audio'].playLaser(false);
        },
        applyPower: function (evt) {
          let type = (evt && evt.detail && evt.detail.type) || 'pulse';
          if (!this.weaponLevels[type]) this.weaponLevels[type] = 1;
          if (this.currentWeapon !== type) {
            this.currentWeapon = type; // switch weapon, no upgrade
          } else {
            this.weaponLevels[type] = Math.min(this.maxLevel, this.weaponLevels[type] + 1);
          }
        },
        firePulse: function() {
          let lvl = this.weaponLevels.pulse || 1;
          let patterns = [
            [-0.8, 0.8],
            [-0.9, 0, 0.9],
            [-1.2, -0.6, 0.6, 1.2],
            [-1.4, -0.7, 0, 0.7, 1.4],
            [-1.6, -0.9, -0.2, 0.2, 0.9, 1.6]
          ];
          let offsets = patterns[Math.min(patterns.length - 1, lvl - 1)];
          offsets.forEach(o => this.fireLaser({ xOffset: o, color: '#00FF00', radius: 0.05, height: 3, speed: 4.5 }));
          this.makeFlash(0, '#AAFF00');
        },
        fireSpread: function() {
          let lvl = this.weaponLevels.spread || 1;
          let pellets = 5 + Math.min(lvl - 1, 4); // 5..9
          let maxSpread = THREE.MathUtils.degToRad(8 + lvl * 3); // wider with level
          let angles = [];
          if (pellets === 1) angles = [0];
          else {
            for (let i = 0; i < pellets; i++) {
              let t = (i / (pellets - 1)) * 2 - 1; // -1..1
              angles.push(t * maxSpread);
            }
          }
          angles.forEach(a => this.fireLaser({ xOffset: 0, yaw: a, color: '#FF6600', radius: 0.08, height: 3.2, speed: 4.8, emissiveIntensity: 5 }));
          this.makeFlash(0, '#FF6600');
        },
        fireMine: function() {
          let lvl = this.weaponLevels.mine || 1;
          let count = Math.min(lvl, 5); // 1..5
          let baseRadius = 3 + (lvl - 1) * 1.2;
          let spreadAngle = THREE.MathUtils.degToRad(12 + lvl * 2);
          let angles = [];
          for (let i = 0; i < count; i++) {
            let t = (count === 1) ? 0 : (i / (count - 1)) * 2 - 1;
            angles.push(t * spreadAngle * 0.5);
          }
          angles.forEach(a => this.fireMineEntity(a, baseRadius));
          this.makeFlash(0, '#66CCFF');
        },
        fireMineEntity: function(yaw, triggerRadius) {
          let scene = document.querySelector('a-scene');
          let mine = document.createElement('a-entity');
          mine.setAttribute('proximity-mine', `triggerRadius: ${triggerRadius}`);
          mine.object3D.position.copy(this.ship.object3D.position);
          mine.object3D.quaternion.copy(this.ship.object3D.quaternion);
          mine.object3D.rotateY(yaw || 0);
          mine.object3D.translateZ(-2.5);
          mine.object3D.translateY(-0.5);
          scene.appendChild(mine);
        },
        fireLaser: function(opts) {
          let scene = document.querySelector('a-scene');
          let laser = document.createElement('a-entity');
          let radius = opts.radius || 0.05;
          let height = opts.height || 3;
          let color = opts.color || '#00FF00';
          let emissiveIntensity = opts.emissiveIntensity || 3;
          laser.setAttribute('geometry', `primitive: cylinder; height: ${height}; radius: ${radius}`);
          laser.setAttribute('material', `color: ${color}; emissive: ${color}; emissiveIntensity: ${emissiveIntensity}`);
          laser.object3D.position.copy(this.ship.object3D.position);
          laser.object3D.quaternion.copy(this.ship.object3D.quaternion);
          laser.object3D.rotateX(-Math.PI / 2); 
          laser.object3D.translateY(1.0); 
          laser.object3D.translateX(opts.xOffset || 0); 
          if (opts.yaw) laser.object3D.rotateY(opts.yaw);
          let speed = opts.speed || 4.0;
          let maxDist = opts.maxDist || 800;
          laser.setAttribute('laser-move', `speed: ${speed}; maxDist: ${maxDist}`);
          scene.appendChild(laser);
        },
        makeFlash: function(xOffset, color) {
          let scene = document.querySelector('a-scene');
          let flash = document.createElement('a-entity');
          flash.setAttribute('geometry', 'primitive: plane; width: 0.5; height: 0.5');
          flash.setAttribute('material', `color: ${color}; shader: flat; transparent: true; opacity: 1; side: double`);
          flash.object3D.position.copy(this.ship.object3D.position);
          flash.object3D.quaternion.copy(this.ship.object3D.quaternion);
          flash.object3D.translateZ(-2.5); 
          flash.object3D.translateX(xOffset || 0);
          flash.object3D.translateY(-1.0);
          flash.setAttribute('animation', 'property: opacity; to: 0; dur: 100; easing: linear');
          scene.appendChild(flash);
          setTimeout(() => { if(flash.parentNode) flash.parentNode.removeChild(flash); }, 120);
        }
      });

      AFRAME.registerComponent('laser-move', {
        schema: {
          speed: { type: 'number', default: 4 },
          maxDist: { type: 'number', default: 800 }
        },
        tick: function () {
          this.el.object3D.translateY(this.data.speed); 
          let enemies = document.querySelectorAll('.enemy-hitbox');
          let laserPos = this.el.object3D.position;
          for (let i = 0; i < enemies.length; i++) {
             let enemyParent = enemies[i];
             if (laserPos.distanceTo(enemyParent.object3D.position) < 4.0) {
                enemyParent.components['enemy-drone'].hit(); 
                this.el.parentNode.removeChild(this.el); 
                return; 
             }
          }
          let shipPos = document.querySelector('#ship-rig').object3D.position;
          if (this.el.object3D.position.distanceTo(shipPos) > this.data.maxDist) {
            if(this.el.parentNode) this.el.parentNode.removeChild(this.el);
          }
        }
      });

      AFRAME.registerComponent('proximity-mine', {
        schema: {
          speed: { type: 'number', default: 1.5 },
          maxDist: { type: 'number', default: 600 },
          triggerRadius: { type: 'number', default: 4 },
          fuse: { type: 'number', default: 9000 }
        },
        init: function() {
          this.start = performance.now();
          this.triggered = false;
          let core = document.createElement('a-sphere');
          core.setAttribute('radius', 0.25);
          core.setAttribute('color', '#66CCFF');
          core.setAttribute('shader', 'flat');
          core.setAttribute('emissive', '#66CCFF');
          core.setAttribute('emissiveIntensity', 2);
          this.el.appendChild(core);
          let ring = document.createElement('a-torus');
          ring.setAttribute('radius', 0.45);
          ring.setAttribute('radius-tubular', 0.05);
          ring.setAttribute('material', 'color: #66CCFF; emissive: #66CCFF; emissiveIntensity: 1.4; shader: flat; opacity: 0.8; transparent: true');
          ring.setAttribute('rotation', '0 0 0');
          this.el.appendChild(ring);
        },
        tick: function(time, timeDelta) {
          if (this.triggered) return;
          let dt = (timeDelta || 16);
          this.el.object3D.translateZ(-this.data.speed); // drift forward
          if (performance.now() - this.start > this.data.fuse) {
            this.detonate();
            return;
          }
          let shipPos = document.querySelector('#ship-rig').object3D.position;
          if (this.el.object3D.position.distanceTo(shipPos) > this.data.maxDist) {
            if(this.el.parentNode) this.el.parentNode.removeChild(this.el);
            return;
          }
          let enemies = document.querySelectorAll('.enemy-hitbox');
          let minePos = this.el.object3D.position;
          for (let i = 0; i < enemies.length; i++) {
             let enemyParent = enemies[i];
             if (minePos.distanceTo(enemyParent.object3D.position) < this.data.triggerRadius) {
                this.detonate();
                return;
             }
          }
        },
        detonate: function() {
          if (this.triggered) return;
          this.triggered = true;
          let scene = this.el.sceneEl;
          let minePos = this.el.object3D.position.clone();
          let explosion = document.createElement('a-entity');
          explosion.setAttribute('position', minePos);
          explosion.setAttribute('explosion-effect', '');
          scene.appendChild(explosion);
          // damage nearby enemies
          let enemies = document.querySelectorAll('.enemy-hitbox');
          enemies.forEach(enemy => {
            if (minePos.distanceTo(enemy.object3D.position) < this.data.triggerRadius + 0.5) {
              enemy.components['enemy-drone'].hit();
            }
          });
          if(this.el.parentNode) this.el.parentNode.removeChild(this.el);
        }
      });

      // =========================================================
      // 7. FX
      // =========================================================
      AFRAME.registerComponent('explosion-effect', {
        init: function() {
          // Core flash
          this.flashEl = document.createElement('a-sphere');
          this.flashEl.setAttribute('radius', 1);
          this.flashEl.setAttribute('color', '#FFA640');
          this.flashEl.setAttribute('shader', 'flat');
          this.flashEl.setAttribute('opacity', 1);
          this.el.appendChild(this.flashEl);
          // Shockwave ring
          this.shockEl = document.createElement('a-ring');
          this.shockEl.setAttribute('radius-inner', 0.3);
          this.shockEl.setAttribute('radius-outer', 0.35);
          this.shockEl.setAttribute('material', 'color: #FFDD88; shader: flat; transparent: true; opacity: 0.9; side: double');
          this.shockEl.setAttribute('rotation', '90 0 0');
          this.el.appendChild(this.shockEl);
          // Embers
          this.particles = [];
          let colors = ['#FF6600', '#FFAA00', '#FFDD55', '#FFFFFF'];
          for(let i=0; i<30; i++) {
             let part = document.createElement('a-sphere');
             part.setAttribute('radius', 0.15 + Math.random() * 0.3);
             part.setAttribute('color', colors[Math.floor(Math.random()*colors.length)]);
             part.setAttribute('shader', 'flat');
             this.el.appendChild(part);
             this.particles.push({
               el: part,
               dir: { x: (Math.random()-0.5)*1.2, y: (Math.random()-0.3)*1.4, z: (Math.random()-0.5)*1.2 }
             });
          }
          // Light burst
          this.lightEl = document.createElement('a-entity');
          this.lightEl.setAttribute('light', 'type: point; color: #FFAA55; intensity: 2; distance: 12; decay: 2');
          this.el.appendChild(this.lightEl);
          this.shockOpacity = 0.9;
          this.life = 60; 
        },
        tick: function() {
          this.life--;
          if (this.life <= 0) { if(this.el.parentNode) this.el.parentNode.removeChild(this.el); return; }
          let lifeNorm = this.life / 60;
          if (this.flashEl) {
             let s = this.flashEl.object3D.scale.x + 0.45;
             this.flashEl.object3D.scale.set(s,s,s);
             this.flashEl.setAttribute('opacity', Math.max(0, lifeNorm));
          }
          if (this.shockEl) {
             this.shockEl.object3D.scale.multiplyScalar(1.05);
             this.shockOpacity = Math.max(0, this.shockOpacity - 0.02);
             this.shockEl.setAttribute('material', `color: #FFDD88; shader: flat; transparent: true; opacity: ${this.shockOpacity}; side: double`);
          }
          for(let p of this.particles) {
             p.el.object3D.position.x += p.dir.x;
             p.el.object3D.position.y += p.dir.y;
             p.el.object3D.position.z += p.dir.z;
             p.dir.x *= 0.92; p.dir.y *= 0.92; p.dir.z *= 0.92;
             let s = p.el.object3D.scale.x * 0.9; 
             p.el.object3D.scale.set(s,s,s);
             if (s < 0.02 && p.el.parentNode) p.el.parentNode.removeChild(p.el);
          }
          if (this.lightEl) {
             let intensity = Math.max(0, 2 * lifeNorm);
             this.lightEl.setAttribute('light', `type: point; color: #FFAA55; intensity: ${intensity}; distance: 12; decay: 2`);
          }
        }
      });

      // =========================================================
      // 8. POWERUPS
      // =========================================================
      AFRAME.registerComponent('weapon-powerup', {
        schema: { type: { type: 'string', default: 'pulse' } },
        init: function() {
          this.ship = document.querySelector('#ship-rig');
          this.el.classList.add('powerup-item');
          this.baseY = this.el.object3D.position.y;
          let colors = { pulse: '#00FF66', spread: '#FFAA00', mine: '#66CCFF' };
          let labels = { pulse: 'PULSE', spread: 'SPREAD', mine: 'MINE' };
          let color = colors[this.data.type] || '#00FF66';
          let label = labels[this.data.type] || 'PULSE';
          let core = document.createElement('a-entity');
          core.setAttribute('geometry', 'primitive: icosahedron; radius: 0.35');
          core.setAttribute('material', `color: ${color}; emissive: ${color}; emissiveIntensity: 1.8; shader: flat`);
          this.el.appendChild(core);
          let ring = document.createElement('a-torus');
          ring.setAttribute('radius', '0.5');
          ring.setAttribute('radius-tubular', '0.03');
          ring.setAttribute('material', `color: ${color}; emissive: ${color}; emissiveIntensity: 1.2; shader: flat; opacity: 0.9; transparent: true`);
          ring.setAttribute('rotation', '90 0 0');
          this.el.appendChild(ring);
          let text = document.createElement('a-text');
          text.setAttribute('value', label);
          text.setAttribute('align', 'center');
          text.setAttribute('color', '#FFFFFF');
          text.setAttribute('width', '1.8');
          text.setAttribute('position', '0 -0.6 0');
          text.setAttribute('shader', 'msdf');
          this.el.appendChild(text);
        },
        tick: function(time, timeDelta) {
          let obj = this.el.object3D;
          obj.rotation.y += 0.0025 * (timeDelta || 16);
          obj.position.y = this.baseY + Math.sin(time * 0.002) * 0.5;
          if (!this.ship || !this.ship.object3D) return;
          if (this.ship.object3D.position.distanceTo(obj.position) < 3.0) {
            this.el.sceneEl.emit('weapon-powerup-collected', { type: this.data.type });
            if(this.el.parentNode) this.el.parentNode.removeChild(this.el);
          }
        }
      });

      AFRAME.registerComponent('powerup-spawner', {
        init: function() {
          this.ship = document.querySelector('#ship-rig');
        },
        spawnPowerupAt: function(position, type) {
          if (!this.ship) return;
          let scene = this.el.sceneEl;
          let types = ['pulse', 'spread', 'mine'];
          let chosen = type || types[Math.floor(Math.random() * types.length)];
          let p = document.createElement('a-entity');
          p.setAttribute('weapon-powerup', `type: ${chosen}`);
          let pos = position.clone ? position.clone() : position;
          pos.x += (Math.random() - 0.5) * 6;
          pos.y += (Math.random() - 0.5) * 6;
          pos.z += (Math.random() - 0.5) * 6;
          p.object3D.position.copy(pos);
          scene.appendChild(p);
        }
      });
      
      AFRAME.registerComponent('hud-binder', {
        init: function() {
          let scoreEl = document.querySelector('#hud-display-left');
          let waveEl = document.querySelector('#hud-display-right');
          let arrowEl = document.querySelector('#nav-arrow-wrapper');
          let powerArrowEl = document.querySelector('#power-arrow-wrapper');
          let ship = document.querySelector('#ship-rig');
          this.el.sceneEl.systems['game-manager'].registerUI(scoreEl, waveEl, arrowEl, ship, powerArrowEl);
        }
      });

      AFRAME.registerComponent('infinite-star-field', {
        init: function() {
          this.stars = [];
          this.ship = document.querySelector('#ship-rig');
          for(let i=0; i<600; i++) {
            let star = document.createElement('a-sphere');
            let pos = this.randomPos(500);
            star.setAttribute('position', pos);
            star.setAttribute('radius', Math.random() * 0.3 + 0.05);
            star.setAttribute('color', 'white');
            star.setAttribute('shader', 'flat');
            this.el.appendChild(star);
            this.stars.push(star);
          }
        },
        randomPos: function(radius) {
            let x = (Math.random() - 0.5) * 2 * radius; let y = (Math.random() - 0.5) * 2 * radius; let z = (Math.random() - 0.5) * 2 * radius;
            return {x, y, z};
        },
        tick: function() {
          let shipPos = this.ship.object3D.position;
          for (let star of this.stars) {
             let dist = star.object3D.position.distanceTo(shipPos);
             if (dist > 400) {
                let offset = this.randomPos(350); 
                star.object3D.position.set(shipPos.x + offset.x, shipPos.y + offset.y, shipPos.z + offset.z);
             }
           }
        }
      });

      AFRAME.registerComponent('planet-system', {
        init: function() {
          this.planets = [];
          this.ship = document.querySelector('#ship-rig');
          let colors = ['#FF4444', '#4444FF', '#AA8822'];
          for(let i=0; i<3; i++) {
            let planet = document.createElement('a-sphere');
            let pos = this.randomPos(2000, 4000);
            planet.setAttribute('position', pos);
            planet.setAttribute('radius', Math.random() * 300 + 100); 
            planet.setAttribute('color', colors[i]);
            planet.setAttribute('roughness', 1);
            this.el.appendChild(planet);
            this.planets.push(planet);
          }
        },
        randomPos: function(min, max) {
            let dirX = (Math.random() - 0.5); let dirY = (Math.random() - 0.5); let dirZ = (Math.random() - 0.5);
            let len = Math.sqrt(dirX*dirX + dirY*dirY + dirZ*dirZ);
            let dist = min + Math.random() * (max - min);
            return { x: (dirX / len) * dist, y: (dirY / len) * dist, z: (dirZ / len) * dist };
        },
        tick: function() {
           let shipPos = this.ship.object3D.position;
           for(let planet of this.planets) {
             if(planet.object3D.position.distanceTo(shipPos) > 5000) {
                let offset = this.randomPos(2000, 4000);
                planet.object3D.position.set(shipPos.x + offset.x, shipPos.y + offset.y, shipPos.z + offset.z);
             }
           }
        }
      });
    </script>

    <a-scene background="color: #000000" drone-spawner hud-binder powerup-spawner renderer="useLegacyLights: false">
      <a-assets>
        <a-asset-item id="cockpit-asset" src="cockpit.glb"></a-asset-item>
        <a-asset-item id="drone-asset" src="drone.glb"></a-asset-item>
      </a-assets>

      <a-entity infinite-star-field></a-entity>
      <a-entity planet-system></a-entity>
      <a-light type="ambient" color="#888"></a-light>
      <a-light type="directional" position="0.5 1 0" intensity="0.8" color="#FFFFAA"></a-light>
      
      <a-entity id="ship-rig" position="0 0 0" ship-controls>
        <!-- Seated camera inside cockpit; follows the rig -->
        <a-entity id="pilot-camera"
                  camera="userHeight: 0"
                  look-controls="pointerLockEnabled: false"
                  wasd-controls="enabled: false"
                  position="0 0 0">
        </a-entity>

        <a-entity 
          gltf-model="#cockpit-asset" 
          position="-0.045 -2.993 -1.567" 
          rotation="0 180 0" 
          scale="1.479 1.479 1.479">
        </a-entity>

        <a-text id="hud-display-left" 
                value="INIT..." 
                font="sourcecodepro" 
                color="#00FF00" 
                width="4"
                scale="0.08 0.08 0.08" 
                position="-0.347 0.522 -0.693" 
                rotation="-25 10 1"
                align="center">
        </a-text>

        <a-text id="hud-display-right" 
                value="SCANNING..." 
                font="sourcecodepro" 
                color="#00FF00" 
                width="4"
                scale="0.08 0.08 0.08" 
                position="0.258 0.526 -0.689" 
                rotation="-25 -10 -1"
                align="center">
        </a-text>

        <!-- Center: 3D HOLOGRAPHIC NAV ARROW (Fixed Rotation) -->
        <a-entity id="nav-arrow-wrapper" position="-0.045 0.774 -0.671" visible="false">
            <a-cone id="nav-arrow-geo" 
                    radius-bottom="0.05" radius-top="0" height="0.2" 
                    material="color: #00FFFF; opacity: 0.8; transparent: true; shader: flat; depthTest: false"
                    rotation="90 0 0">
            </a-cone>
        </a-entity>
        <a-entity id="power-arrow-wrapper" position="-0.045 0.774 -0.671" visible="false">
            <a-cone 
                    radius-bottom="0.03" radius-top="0" height="0.12" 
                    material="color: #00FF66; opacity: 0.9; transparent: true; shader: flat; depthTest: false"
                    rotation="90 0 0">
            </a-cone>
        </a-entity>

        <a-entity id="leftHand" oculus-touch-controls="hand: left; model: false"></a-entity>
        <a-entity id="rightHand" oculus-touch-controls="hand: right; model: false" laser-shooter></a-entity>
        
      </a-entity>
    </a-scene>
  </body>
</html>
