<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebXR Curling</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Crect width='32' height='32' rx='6' fill='%230b192d'/%3E%3Ccircle cx='16' cy='16' r='11' fill='%234de1ff'/%3E%3Ccircle cx='16' cy='16' r='6' fill='%23040912'/%3E%3C/svg%3E">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Barlow+Condensed:wght@600;700&family=Inter:wght@500;600&display=swap');
    :root {
      --panel-bg: rgba(6, 10, 18, 0.9);
      --accent: #4de1ff;
      --danger: #ff6584;
      --text: #e9f2ff;
      --muted: #9fb4cc;
      --surface: rgba(255, 255, 255, 0.04);
      --shadow: 0 12px 36px rgba(0, 0, 0, 0.6);
      --player: #ff6b8b;
      --ai: #ffd84d;
      font-family: "Barlow Condensed", "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
    }
    * { box-sizing: border-box; }
    body { margin: 0; overflow: hidden; background: #040912; color: var(--text); }
    .muted { color: var(--muted); }
    #hud {
      position: absolute;
      top: 14px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, rgba(6,12,22,0.95), rgba(12,26,44,0.92));
      padding: 14px 16px 12px;
      border-radius: 14px;
      box-shadow: var(--shadow);
      border: 1px solid rgba(255,255,255,0.12);
      min-width: min(92vw, 940px);
      z-index: 10;
      pointer-events: none;
      line-height: 1.4;
      backdrop-filter: blur(8px);
      color: var(--text);
    }
    #hud .hud-header { display: flex; align-items: flex-start; justify-content: space-between; gap: 12px; }
    #hud .title { font-size: 24px; margin: 0; font-weight: 700; letter-spacing: 0.06em; text-transform: uppercase; }
    #hud .subtitle { color: var(--muted); font-size: 13px; letter-spacing: 0.04em; margin-top: 2px; }
    #hud .hud-right { display: flex; align-items: center; gap: 8px; }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      letter-spacing: 0.04em;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      text-transform: uppercase;
    }
    .pill.live { background: rgba(77,225,255,0.15); border-color: rgba(77,225,255,0.45); color: var(--accent); }
    .pill.accent { background: rgba(255,107,139,0.2); border-color: rgba(255,107,139,0.5); color: var(--text); }
    .hud-scoreboard {
      margin-top: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      background: var(--surface);
      overflow: hidden;
      --end-count: 8;
    }
    .hud-row {
      display: grid;
      grid-template-columns: 150px minmax(0,1fr) 68px 160px;
      align-items: center;
      padding: 8px 12px;
      gap: 10px;
    }
    .hud-row-head {
      background: rgba(255,255,255,0.04);
      color: var(--muted);
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    .hud-row.team { position: relative; }
    .hud-row.team.active {
      background: linear-gradient(90deg, rgba(77,225,255,0.09), rgba(255,255,255,0));
      box-shadow: inset 0 0 0 1px rgba(77,225,255,0.08);
    }
    .team-name {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 16px;
      letter-spacing: 0.04em;
      font-weight: 700;
      text-transform: uppercase;
    }
    .team-name .tag {
      width: 26px;
      height: 26px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 700;
      background: rgba(255,255,255,0.08);
    }
    .team-name .tag.player { background: rgba(255,107,139,0.22); color: #ffe6ee; }
    .team-name .tag.ai { background: rgba(255,216,77,0.24); color: #1a1202; }
    .team-name .next { font-size: 11px; color: var(--muted); letter-spacing: 0.08em; }
    .ends-grid {
      display: grid;
      grid-template-columns: repeat(var(--end-count, 8), minmax(0, 1fr));
      gap: 4px;
      align-items: center;
    }
    .end-cell {
      text-align: center;
      padding: 6px 4px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 700;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
    }
    .end-cell.head { font-weight: 600; color: var(--muted); background: rgba(255,255,255,0.02); }
    .end-cell.active { border-color: rgba(77,225,255,0.6); color: var(--text); box-shadow: 0 0 0 1px rgba(77,225,255,0.15) inset; }
    .total-box {
      text-align: center;
      font-size: 20px;
      font-weight: 800;
      letter-spacing: 0.06em;
    }
    .stone-track {
      display: flex;
      gap: 6px;
      justify-content: flex-start;
      flex-wrap: wrap;
    }
    .pip {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: rgba(255,255,255,0.09);
      border: 1px solid rgba(255,255,255,0.15);
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.35);
    }
    .pip.used { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.08); opacity: 0.45; }
    .pip.active { box-shadow: 0 0 0 2px rgba(77,225,255,0.35), 0 0 8px rgba(77,225,255,0.6); border-color: rgba(77,225,255,0.6); }
    .pip.player { background: radial-gradient(circle at 30% 30%, #ffdce8, #ff6b8b); }
    .pip.ai { background: radial-gradient(circle at 30% 30%, #fff4cc, #f3c228); }
    .hud-footer {
      margin-top: 10px;
      border-top: 1px solid rgba(255,255,255,0.08);
      padding-top: 8px;
      display: grid;
      gap: 4px;
      font-size: 13px;
      color: var(--muted);
    }
    #statusLabel { color: var(--text); font-weight: 500; letter-spacing: 0.02em; }
    #scoreLabel { font-weight: 700; color: var(--text); }
    #uiPanel {
      position: absolute;
      top: 50%;
      right: 16px;
      transform: translateY(-50%);
      background: var(--panel-bg);
      padding: 14px;
      border-radius: 12px;
      box-shadow: var(--shadow);
      width: 320px;
      max-height: calc(100% - 32px);
      overflow-y: auto;
      border: 1px solid rgba(255,255,255,0.08);
      display: none;
      z-index: 20;
    }
    #uiPanel h3 { margin: 4px 0 8px; color: var(--accent); }
    .control { margin-bottom: 10px; }
    .control label { display: flex; justify-content: space-between; font-size: 12px; color: var(--muted); }
    .control input[type="range"],
    .control input[type="number"] {
      width: 100%;
      margin-top: 4px;
    }
    .control .value { color: var(--text); font-weight: 600; }
    .section { margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,0.05); }
    #toast {
      position: absolute;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      padding: 8px 12px;
      border-radius: 20px;
      color: var(--text);
      font-size: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: var(--shadow);
      z-index: 11;
    }
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 12px;
      height: 12px;
      margin-left: -6px;
      margin-top: -6px;
      border: 2px solid rgba(255,255,255,0.5);
      border-radius: 50%;
      pointer-events: none;
      display: none;
      z-index: 9;
    }
    #miniMap {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 220px;
      height: 220px;
      background: rgba(4, 9, 18, 0.9);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      box-shadow: var(--shadow);
      z-index: 9;
    }
    #endOverlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.6);
      z-index: 30;
    }
    #endOverlay .card {
      background: var(--panel-bg);
      padding: 16px;
      border-radius: 12px;
      box-shadow: var(--shadow);
      min-width: 320px;
      border: 1px solid rgba(255,255,255,0.12);
      color: var(--text);
    }
    #endOverlay h3 { margin: 0 0 8px; color: var(--accent); }
    #endOverlay .actions { display: flex; gap: 8px; margin-top: 12px; }
    #endOverlay button {
      flex: 1;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.15);
      background: #13334c;
      color: var(--text);
      cursor: pointer;
    }
    #endOverlay button.primary { background: #1f7fff; color: #fff; }
  </style>
</head>
<body>
  <div id="hud" aria-live="polite">
    <div class="hud-header">
      <div>
        <div class="title">Jaylabs Amatuer Championships</div>
        <div class="subtitle">Sheet A | Coats vs Ardro</div>
      </div>
      <div class="hud-right">
        <span class="pill live" id="endLabel">End 1 of 8</span>
        <span class="pill accent" id="turnLabel">Coats to deliver</span>
      </div>
    </div>

    <div class="hud-scoreboard">
      <div class="hud-row hud-row-head">
        <div class="team-name muted">Team</div>
        <div class="ends-grid" id="endColumns"></div>
        <div class="total-box muted">Total</div>
        <div class="stone-track muted">Stones</div>
      </div>
      <div class="hud-row team" data-team="player">
        <div class="team-name">
          <span class="tag player">C</span>
          <span class="name">Coats</span>
        </div>
        <div class="ends-grid" id="playerEnds"></div>
        <div class="total-box" id="playerTotal">0</div>
        <div class="stone-track" id="playerStonesTrack"></div>
      </div>
      <div class="hud-row team" data-team="ai">
        <div class="team-name">
          <span class="tag ai">A</span>
          <span class="name">Ardro</span>
        </div>
        <div class="ends-grid" id="aiEnds"></div>
        <div class="total-box" id="aiTotal">0</div>
        <div class="stone-track" id="aiStonesTrack"></div>
      </div>
    </div>

    <div class="hud-footer">
      <div id="scoreLabel">Totals: Coats 0 | Ardro 0</div>
      <div id="stonesLabel" class="muted">Stones remaining (Coats / Ardro): 0 / 0</div>
      <div id="statusLabel">Grip to pick up and release to throw. Press B to open tuning UI.</div>
    </div>
  </div>
  <div id="crosshair"></div>
  <canvas id="miniMap" width="220" height="220"></canvas>
  <div id="uiPanel">
    <h3>Runtime Controls</h3>
    <div id="uiContent"></div>
  </div>
  <div id="toast">Right controller B toggles tuning UI. Keyboard fallback: press U.</div>
  <div id="endOverlay">
    <div class="card">
      <h3 id="endTitle"></h3>
      <div id="endBody" class="muted"></div>
      <div id="endScores" style="margin-top:8px;"></div>
      <div class="actions">
        <button id="nextEndBtn" class="primary">Next End</button>
        <button id="playAgainBtn">Play Again</button>
        <button id="quitBtn">Quit</button>
      </div>
    </div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.164.1/build/three.module.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'https://unpkg.com/three@0.164.1/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.164.1/examples/jsm/loaders/GLTFLoader.js';
    import { RGBELoader } from 'https://unpkg.com/three@0.164.1/examples/jsm/loaders/RGBELoader.js';
    import { XRButton } from 'https://unpkg.com/three@0.164.1/examples/jsm/webxr/XRButton.js';
    import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#0b192d');
    const playerRig = new THREE.Group();
    scene.add(playerRig);
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(0, 4, 8);
    playerRig.add(camera);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.xr.enabled = true;
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);
    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    pmremGenerator.compileEquirectangularShader();

    // Strip unsupported XR optional features (notably "layers") to avoid noisy console warnings on platforms
    // that don't implement them yet.
    (function patchXRSessionRequests() {
      const xr = navigator.xr;
      if (!xr || xr.__patchedForLayers) return;
      const sanitizeInit = (init = {}) => {
        const optional = Array.isArray(init.optionalFeatures) ? init.optionalFeatures.filter(f => f !== 'layers') : [];
        const required = Array.isArray(init.requiredFeatures) ? init.requiredFeatures : [];
        return { ...init, optionalFeatures: optional, requiredFeatures: required };
      };
      const wrap = (key) => {
        if (!xr[key]) return;
        const original = xr[key].bind(xr);
        xr[key] = (mode, init) => original(mode, sanitizeInit(init));
      };
      wrap('requestSession');
      wrap('offerSession');
      xr.__patchedForLayers = true;
    })();

    document.body.appendChild(XRButton.createButton(renderer, { optionalFeatures: ['local-floor', 'bounded-floor'] }));

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 0.5, 0);
    controls.update();

    const hemi = new THREE.HemisphereLight(0xffffff, 0x223344, 0.9);
    scene.add(hemi);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
    dirLight.position.set(6, 10, 3);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(2048, 2048);
    scene.add(dirLight);
    const arenaLight = new THREE.PointLight(0xc4e1ff, 0.6, 80, 1.5);
    arenaLight.position.set(0, 15, 0);
    scene.add(arenaLight);

    const params = {
      sheetLength: 44.5, // meters (146 ft)
      sheetWidth: 4.75,  // meters (max regulation width)
      houseRadius: 1.83, // meters (12 ft diameter outer ring)
      stoneRadius: 1.0,
      stoneHeight: 1.44,
      stoneScale: 0.02, // physics wrap scale
      visualStoneScale: 0.2, // fixed visual scale
      aiStoneScaleFactor: 10,
      stoneMass: 25,
      friction: 0.00003,
      restitution: 0.4,
      iceDrag: 0.00002,
      spinDrag: 3,
      iceCurl: 6.0,
      spinCurl: 0.1,
      throwPower: 6.5,
      pushSpeed: 7,
      pushDirectionDeg: 0,
      pushSpin: 0,
      motionPowerScale: 1.7,
      twistSpinScale: 0.001,
      useControllerAim: true,
      aiAccuracy: 0.4,
      aiWeightBias: 0.8,
      environmentTheme: 'domed'
    };
    const stoneColors = {
      player: { albedo: '#f3a5bb', emissive: '#f1c7d4', emissiveIntensity: 0.16 },
      ai: { albedo: '#ffd84d', emissive: '#ffd84d', emissiveIntensity: 0.24 }
    };
    const eventName = 'Jaylabs Amatuer Championships';
    const teamNames = { player: 'Coats', ai: 'Ardro' };
    const teamLabel = (team) => teamNames[team] || team;
    const matchupLabel = `${teamNames.player} vs ${teamNames.ai}`;

    const clampSpinDrag = (value) => THREE.MathUtils.clamp(value, 0, 4);
    const maxPhysicsSpinDamping = 0.8;
    const physicsSpinDamping = (value) => THREE.MathUtils.clamp(value, 0, maxPhysicsSpinDamping);
    const extraSpinDrag = (value) => Math.max(0, clampSpinDrag(value) - maxPhysicsSpinDamping);
    const stoneVisualRotation = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 2);
    const environmentModes = ['passendorf', 'rink', 'off'];
    let environmentModeIndex = 0;
    let currentEnvironmentMode = environmentModes[environmentModeIndex];
    const environmentMaps = {
      passendorf: { env: null, background: null },
      rink: { env: null, background: null }
    };
    let environmentBaseBackground = scene.background.clone();
    let iceTexture = null;

    const hud = {
      turn: document.getElementById('turnLabel'),
      stones: document.getElementById('stonesLabel'),
      score: document.getElementById('scoreLabel'),
      status: document.getElementById('statusLabel'),
      end: document.getElementById('endLabel'),
      endColumns: document.getElementById('endColumns'),
      playerEnds: document.getElementById('playerEnds'),
      aiEnds: document.getElementById('aiEnds'),
      playerStones: document.getElementById('playerStonesTrack'),
      aiStones: document.getElementById('aiStonesTrack'),
      playerTotal: document.getElementById('playerTotal'),
      aiTotal: document.getElementById('aiTotal'),
      scoreboard: document.querySelector('.hud-scoreboard'),
      rows: {
        player: document.querySelector('.hud-row[data-team="player"]'),
        ai: document.querySelector('.hud-row[data-team="ai"]')
      }
    };
    const hudTitle = document.querySelector('#hud .title');
    const hudSubtitle = document.querySelector('#hud .subtitle');
    const hudTeamLabels = {
      player: document.querySelector('.hud-row[data-team="player"] .name'),
      ai: document.querySelector('.hud-row[data-team="ai"] .name')
    };
    if (hudTitle) hudTitle.textContent = eventName;
    if (hudSubtitle) hudSubtitle.textContent = `Sheet A | ${matchupLabel}`;
    if (hudTeamLabels.player) hudTeamLabels.player.textContent = teamNames.player;
    if (hudTeamLabels.ai) hudTeamLabels.ai.textContent = teamNames.ai;

    const uiPanel = document.getElementById('uiPanel');
    const crosshair = document.getElementById('crosshair');
    const uiContent = document.getElementById('uiContent');
    const toast = document.getElementById('toast');
    const miniMap = document.getElementById('miniMap');
    const miniCtx = miniMap.getContext('2d');
    const endOverlay = document.getElementById('endOverlay');
    const endTitle = document.getElementById('endTitle');
    const endBody = document.getElementById('endBody');
    const endScores = document.getElementById('endScores');
    const nextEndBtn = document.getElementById('nextEndBtn');
    const playAgainBtn = document.getElementById('playAgainBtn');
    const quitBtn = document.getElementById('quitBtn');

    let uiVisible = false;
    let bButtonState = false;
    const hudCanvas = document.createElement('canvas');
    hudCanvas.width = 512;
    hudCanvas.height = 256;
    const hudCtx = hudCanvas.getContext('2d');
    let hudTexture = null;
    let hudMesh = null;
    let miniMapTexture = null;
    let miniMapMesh = null;
    const panelGroup = new THREE.Group();
    scene.add(panelGroup);
    const pointerLines = [];
    const raycasters = [new THREE.Raycaster(), new THREE.Raycaster()];
    const vrPrompt = { group: null, buttons: [] };
    const crowdData = { headMesh: null, torsoMesh: null, material: null, torsoMaterial: null, cheer: 0, lights: [], targets: [], jitter: [] };
    const audio = {
      ctx: null,
      ready: false,
      buffers: {},
      ambience: null,
      slideBuffers: {},
      hasGesture: false
    };

    const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.82, 0) });
    world.broadphase = new CANNON.SAPBroadphase(world);
    world.allowSleep = true;

    const iceMaterial = new CANNON.Material('ice');
    const stoneMaterial = new CANNON.Material('stone');
    const contact = new CANNON.ContactMaterial(iceMaterial, stoneMaterial, {
      friction: params.friction,
      restitution: params.restitution
    });
    world.addContactMaterial(contact);

    let groundBody;
    let wallBodies = [];
    let sheetMesh;
    const houseRings = [];
    const lines = [];

    let housePositionZ = -params.sheetLength / 2 + 4.875; // 4.875m buffer from sheet end to house center (real sheet proportions)
    const loader = new GLTFLoader();
    const rgbeLoader = new RGBELoader();
    const textureLoader = new THREE.TextureLoader();
    let playerStoneTemplate = null;
    let aiStoneTemplate = null;

    const stones = [];
    const gameState = {
      stonesPerTeam: 5,
      thrown: { player: 0, ai: 0 },
      currentTeam: 'player',
      activeStone: null,
      scores: { player: 0, ai: 0 },
      endScores: [],
      currentEnd: 1,
      totalEnds: 8,
      waitingForNextEnd: false,
      gameOver: false,
      inEnd: true
    };

    const controller1 = renderer.xr.getController(0);
    const controller2 = renderer.xr.getController(1);
    playerRig.add(controller1);
    playerRig.add(controller2);

    const controllerGrip1 = renderer.xr.getControllerGrip(0);
    const controllerGrip2 = renderer.xr.getControllerGrip(1);
    playerRig.add(controllerGrip1);
    playerRig.add(controllerGrip2);

    const aimArrow = createAimArrow();
    scene.add(aimArrow);
    const envGroup = new THREE.Group();
    scene.add(envGroup);
    let skyDome = null;
    const wrapHelpers = new THREE.Group();
    wrapHelpers.visible = false;
    scene.add(wrapHelpers);

    const controllerState = new Map(); // tracks world velocity for throw release
    const grabState = { stone: null, controller: null };
    nextEndBtn.addEventListener('click', handleNextEnd);
    playAgainBtn.addEventListener('click', resetGame);
    quitBtn.addEventListener('click', handleQuit);

    initUI();
    uiPanel.style.display = 'none';
    initSheet();
    buildEnvironment();
    buildVRPanels();
    loadEnvironmentMaps();
    updateRigPosition();
    loadStones().then(() => {
      startTurn('player');
    });
    setupAudioUnlock();

    controller1.addEventListener('selectstart', () => handlePlayerThrow(controller1));
    controller2.addEventListener('selectstart', () => handlePlayerThrow(controller2));
    controller1.addEventListener('squeezestart', () => beginGrab(controller1));
    controller2.addEventListener('squeezestart', () => beginGrab(controller2));
    controller1.addEventListener('squeezeend', () => endGrab(controller1));
    controller2.addEventListener('squeezeend', () => endGrab(controller2));

    window.addEventListener('resize', onWindowResize);
    window.addEventListener('keydown', (e) => {
      const key = e.key.toLowerCase();
      if (key === 'u') toggleUI();
      if (key === 't') handlePlayerThrow(null);
      if (key === 'r') resetEnd();
      if (key === 'o') cycleEnvironmentMode();
      startAudio(true);
    });

    function initSheet() {
      if (sheetMesh) scene.remove(sheetMesh);
      lines.forEach(l => scene.remove(l));
      lines.length = 0;
      houseRings.forEach(r => scene.remove(r));
      houseRings.length = 0;

      const sheetGeo = new THREE.PlaneGeometry(params.sheetWidth, params.sheetLength);
      const sheetMat = new THREE.MeshPhongMaterial({ color: '#9cd6ff', transparent: true, opacity: 0.95 });
      sheetMesh = new THREE.Mesh(sheetGeo, sheetMat);
      sheetMesh.rotation.x = -Math.PI / 2;
      sheetMesh.receiveShadow = true;
      scene.add(sheetMesh);

      housePositionZ = -params.sheetLength / 2 + 4.875; // real sheet leaves ~4.875m from end board to house center
      buildHouseRings();
      buildLines();
      rebuildPhysicsSurface();
    }

    function buildHouseRings() {
      const standardOuter = 1.83; // 12 ft outer ring radius
      const scale = params.houseRadius / standardOuter;
      const rings = [
        { outer: 1.83 * scale, inner: 1.22 * scale, color: '#1d68ff' }, // blue 12' to 8'
        { outer: 1.22 * scale, inner: 0.61 * scale, color: '#ffffff' }, // white 8' to 4'
        { outer: 0.61 * scale, inner: 0.1525 * scale, color: '#c82b41' } // red 4' to button
      ];

      rings.forEach((cfg, idx) => {
        const geo = new THREE.RingGeometry(cfg.inner, cfg.outer, 64);
        const mat = new THREE.MeshBasicMaterial({ color: cfg.color, side: THREE.DoubleSide, transparent: true, opacity: 0.9 });
        const ring = new THREE.Mesh(geo, mat);
        ring.rotation.x = -Math.PI / 2;
        ring.position.z = housePositionZ;
        ring.position.y = 0.001 * (idx + 1);
        scene.add(ring);
        houseRings.push(ring);
      });

      const buttonGeo = new THREE.CircleGeometry(0.1525 * scale, 48); // 1 ft diameter
      const buttonMat = new THREE.MeshBasicMaterial({ color: '#f7d80b', side: THREE.DoubleSide, transparent: true, opacity: 0.95 });
      const button = new THREE.Mesh(buttonGeo, buttonMat);
      button.rotation.x = -Math.PI / 2;
      button.position.z = housePositionZ;
      button.position.y = 0.001 * (rings.length + 1);
      scene.add(button);
      houseRings.push(button);
    }

    function buildLines() {
      const lineMat = new THREE.MeshBasicMaterial({ color: '#ffffff' });
      const teeZ = housePositionZ;
      const hogDistance = 6.4016; // 21 ft from tee line
      const backOffset = 1.829;   // 6 ft behind tee
      const hackOffset = 3.66;    // 12 ft behind tee

      const addLine = (zPos, color = '#ffffff', width = params.sheetWidth, thickness = 0.05) => {
        const geo = new THREE.PlaneGeometry(width, thickness);
        const mat = new THREE.MeshBasicMaterial({ color, side: THREE.DoubleSide });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.rotation.x = -Math.PI / 2;
        mesh.position.z = zPos;
        mesh.position.y = 0.002;
        scene.add(mesh);
        lines.push(mesh);
      };

      // Centre line (full length)
      const centerGeo = new THREE.PlaneGeometry(0.06, params.sheetLength);
      const centerMesh = new THREE.Mesh(centerGeo, lineMat);
      centerMesh.rotation.x = -Math.PI / 2;
      centerMesh.position.set(0, 0.0015, 0);
      scene.add(centerMesh);
      lines.push(centerMesh);

      // Hog line (delivery side for single-house setup)
      addLine(teeZ + hogDistance, '#d22', params.sheetWidth);

      // Tee line at house center
      addLine(teeZ, '#ffffff', params.sheetWidth * 0.8);

      // Back line behind house
      addLine(teeZ - backOffset, '#ffffff', params.sheetWidth * 0.7);

      // Hack marks (twin)
      const hackWidth = 0.18;
      const hackLength = 0.6;
      [-0.15, 0.15].forEach((xOffset) => {
        const geo = new THREE.PlaneGeometry(hackWidth, hackLength);
        const mat = new THREE.MeshBasicMaterial({ color: '#111', side: THREE.DoubleSide });
        const hack = new THREE.Mesh(geo, mat);
        hack.rotation.x = -Math.PI / 2;
        hack.position.set(xOffset, 0.0025, teeZ - hackOffset);
        scene.add(hack);
        lines.push(hack);
      });
    }

    function rebuildPhysicsSurface() {
      if (groundBody) world.removeBody(groundBody);
      wallBodies.forEach(w => world.removeBody(w));
      wallBodies = [];

      groundBody = new CANNON.Body({ mass: 0, material: iceMaterial });
      groundBody.addShape(new CANNON.Plane());
      groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
      world.addBody(groundBody);

      const wrapHeight = stoneDimsFor('player').height * 1.1;
      const wallHalfHeight = Math.max(0.05, wrapHeight / 2);
      const wallShape = (w, h, d) => new CANNON.Box(new CANNON.Vec3(w, h, d));
      const sideOffset = params.sheetWidth / 2;
      const lengthHalf = params.sheetLength / 2;
      const side1 = new CANNON.Body({ mass: 0, material: iceMaterial, position: new CANNON.Vec3(sideOffset, wallHalfHeight, 0) });
      side1.addShape(wallShape(0.05, wallHalfHeight, lengthHalf));
      const side2 = new CANNON.Body({ mass: 0, material: iceMaterial, position: new CANNON.Vec3(-sideOffset, wallHalfHeight, 0) });
      side2.addShape(wallShape(0.05, wallHalfHeight, lengthHalf));
      const back = new CANNON.Body({ mass: 0, material: iceMaterial, position: new CANNON.Vec3(0, wallHalfHeight, -lengthHalf) });
      back.addShape(wallShape(params.sheetWidth / 2, wallHalfHeight, 0.05));
      const front = new CANNON.Body({ mass: 0, material: iceMaterial, position: new CANNON.Vec3(0, wallHalfHeight, lengthHalf) });
      front.addShape(wallShape(params.sheetWidth / 2, wallHalfHeight, 0.05));
      wallBodies.push(side1, side2, back, front);
      wallBodies.forEach(w => {
        w.collisionResponse = true;
        world.addBody(w);
      });
      rebuildWrapHelpers(wallHalfHeight, sideOffset, lengthHalf);
    }

    function rebuildWrapHelpers(wallHalfHeight, sideOffset, lengthHalf) {
      if (!wrapHelpers) return;
      wrapHelpers.clear();
      const hw = sideOffset;
      const hl = lengthHalf;
      const y = wallHalfHeight * 2;
      const baseCorners = [
        new THREE.Vector3(-hw, 0.01, -hl),
        new THREE.Vector3(hw, 0.01, -hl),
        new THREE.Vector3(hw, 0.01, hl),
        new THREE.Vector3(-hw, 0.01, hl)
      ];
      const topCorners = baseCorners.map(c => c.clone().setY(y));
      const pts = [];
      for (let i = 0; i < 4; i++) {
        const next = (i + 1) % 4;
        pts.push(baseCorners[i], baseCorners[next]);
        pts.push(topCorners[i], topCorners[next]);
        pts.push(baseCorners[i], topCorners[i]);
      }
      const geo = new THREE.BufferGeometry().setFromPoints(pts);
      const mat = new THREE.LineBasicMaterial({
        color: 0x4de1ff,
        transparent: true,
        opacity: 0.7,
        depthTest: false
      });
      const lines = new THREE.LineSegments(geo, mat);
      lines.renderOrder = 10;
      wrapHelpers.add(lines);
    }

    async function loadStones() {
      const yellow = await loader.loadAsync('curlyellow.glb');
      aiStoneTemplate = cloneWithTint(yellow.scene, stoneColors.ai);
      playerStoneTemplate = cloneWithTint(yellow.scene, stoneColors.player);
      aiStoneTemplate.rotation.y = Math.PI / 2;
      playerStoneTemplate.rotation.y = Math.PI / 2;
      [playerStoneTemplate, aiStoneTemplate].forEach((root) => {
        root.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });
      });
    }

    function cloneWithTint(root, tint) {
      const clone = root.clone(true);
      applyStoneTint(clone, tint);
      return clone;
    }

    function applyStoneTint(root, tint) {
      const config = typeof tint === 'string' ? { albedo: tint, emissive: tint } : (tint || {});
      const baseColor = new THREE.Color(config.albedo || config.color || '#ffffff');
      const emissiveColor = new THREE.Color(config.emissive || config.albedo || config.color || '#ffffff');
      const emissiveIntensity = config.emissiveIntensity ?? 0.25;
      root.traverse((child) => {
        if (child.isMesh && child.material) {
          const paintMaterial = (material) => {
            const mat = material.clone();
            if (mat.color) mat.color.copy(baseColor);
            if (mat.emissive) {
              mat.emissive.copy(emissiveColor);
              mat.emissiveIntensity = emissiveIntensity;
            }
            return mat;
          };
          child.material = Array.isArray(child.material) ? child.material.map(paintMaterial) : paintMaterial(child.material);
        }
      });
    }

    function stoneScaleFor(team) {
      return params.stoneScale * params.aiStoneScaleFactor;
    }

    function stoneDimsFor(team) {
      const scale = stoneScaleFor(team);
      return {
        radius: params.stoneRadius * scale,
        height: params.stoneHeight * scale
      };
    }

    function createStoneMesh(team) {
      const base = team === 'player' ? playerStoneTemplate : aiStoneTemplate;
      const mesh = base.clone(true);
      mesh.scale.setScalar(params.visualStoneScale);
      mesh.rotation.y = Math.PI / 2;
      return mesh;
    }

    function makeStoneBody(team) {
      const dims = stoneDimsFor(team);
      const spinDamping = physicsSpinDamping(params.spinDrag);
      const body = new CANNON.Body({
        mass: params.stoneMass,
        material: stoneMaterial,
        linearDamping: params.iceDrag,
        angularDamping: spinDamping
      });
      body.angularFactor.set(0, 1, 0); // allow spin only around up-axis
      body.linearFactor.set(1, 0, 1); // lock vertical translation
      const shape = new CANNON.Cylinder(dims.radius, dims.radius, dims.height, 20);
      body.addShape(shape);
      body.sleepSpeedLimit = 0.05;
      body.sleepTimeLimit = 1.2;
      return body;
    }

    function getSpawnZ() {
      return params.sheetLength / 2 - 2;
    }

    function spawnStone(team) {
      if (!playerStoneTemplate || !aiStoneTemplate) return;
      const mesh = createStoneMesh(team);
      const body = makeStoneBody(team);
      const dims = stoneDimsFor(team);
      const spawnZ = getSpawnZ();
      body.position.set(0, dims.height / 2, spawnZ);
      mesh.position.copy(body.position);
      mesh.castShadow = true;
      const stone = { team, mesh, body, spin: 0, thrown: false, debug: null };
      stone.debug = createPhysicsDebugMesh(team);
      stone.debug.visible = false;
      scene.add(stone.debug);
      stones.push(stone);
      scene.add(mesh);
      world.addBody(body);
      attachStoneAudio(body);
      gameState.activeStone = stones[stones.length - 1];
      updateHud();
    }

    // Test stone helpers removed

    function keepStonesUpright(list) {
      list.forEach((s) => {
        const q = s.body.quaternion;
        // Extract yaw from quaternion directly to avoid unsupported toEuler order in Cannon.
        const w = q.w, x = q.x, y = q.y, z = q.z;
        const yaw = Math.atan2(2 * (w * y + x * z), 1 - 2 * (y * y + z * z));
        q.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), yaw);
        s.body.quaternion.copy(q);
        s.body.angularVelocity.set(0, s.body.angularVelocity.y, 0);
        const dims = stoneDimsFor(s.team);
        s.body.velocity.y = 0;
        s.body.position.y = dims.height / 2;
      });
    }

    function repositionWaitingStone() {
      const spawnZ = getSpawnZ();
      stones.forEach((s) => {
        if (!s.thrown) {
          const dims = stoneDimsFor(s.team);
          s.body.position.set(0, dims.height / 2, spawnZ);
          s.body.velocity.set(0, 0, 0);
          s.body.angularVelocity.set(0, 0, 0);
          s.mesh.position.copy(s.body.position);
        }
      });
    }

    function handlePlayerThrow(controller) {
      if (grabState.stone) return;
      if (gameState.waitingForNextEnd || gameState.gameOver) {
        tryPromptClick(controller);
        return;
      }
      startAudio(true);
      if (gameState.currentTeam !== 'player' || !gameState.activeStone || gameState.activeStone.thrown === true) return;
      const motion = computeMotionThrow(controller);
      if (motion) {
        throwStone(gameState.activeStone, motion.dir, motion.speed, motion.spin);
      } else {
        const dir = computePushDirection(controller);
        throwStone(gameState.activeStone, dir, params.pushSpeed, params.pushSpin);
      }
    }

    function beginGrab(controller) {
      if (gameState.waitingForNextEnd || gameState.gameOver) return;
      if (gameState.currentTeam !== 'player' || !gameState.activeStone || gameState.activeStone.thrown) return;
      startAudio(true);
      grabState.stone = gameState.activeStone;
      grabState.controller = controller;
      const s = grabState.stone;
      s.body.type = CANNON.Body.KINEMATIC;
      s.body.velocity.set(0, 0, 0);
      s.body.angularVelocity.set(0, 0, 0);
      s.body.updateMassProperties();
      s.body.wakeUp();
      hud.status.textContent = 'Hold grip, move to aim, release grip to throw.';
      drawHudCanvas();
    }

    function endGrab(controller) {
      if (!grabState.stone || grabState.controller !== controller) return;
      const s = grabState.stone;
      if (gameState.waitingForNextEnd || gameState.gameOver) {
        grabState.stone = null;
        grabState.controller = null;
        tryPromptClick(controller);
        return;
      }
      const motion = computeMotionThrow(controller);
      if (motion) {
        const vel = new CANNON.Vec3(motion.dir.x, 0, motion.dir.z).scale(motion.speed);
        releaseStone(s, vel, motion.spin);
      } else {
        const dir = computePushDirection(controller);
        const vel = new CANNON.Vec3(dir.x, 0, dir.z).scale(params.pushSpeed);
        releaseStone(s, vel, params.pushSpin);
      }
      grabState.stone = null;
      grabState.controller = null;
    }

    function aiThrow() {
      if (!gameState.activeStone) return;
      const start = gameState.activeStone.body.position;
      const accuracy = THREE.MathUtils.clamp(params.aiAccuracy, 0, 1);
      const center = new THREE.Vector3(0, 0, housePositionZ);
      const opponents = stones.filter(s => s.team === 'player' && s.thrown);
      const aiStones = stones.filter(s => s.team === 'ai' && s.thrown);
      const opponentInHouse = opponents.filter((s) => {
        const dist = Math.hypot(s.body.position.x - center.x, s.body.position.z - center.z);
        return dist <= params.houseRadius * 1.25;
      });
      const aiInHouse = aiStones.filter((s) => {
        const dist = Math.hypot(s.body.position.x - center.x, s.body.position.z - center.z);
        return dist <= params.houseRadius * 1.3;
      });

      const pickTargetStone = (list) => list.reduce((best, s) => {
        const dist = Math.hypot(s.body.position.x - center.x, s.body.position.z - center.z);
        if (!best || dist < best.dist) return { dist, stone: s };
        return best;
      }, null)?.stone;

      let shotType = 'draw';
      if (opponentInHouse.length && Math.random() < 0.55) {
        shotType = 'takeout';
      } else if (!opponentInHouse.length && (aiInHouse.length || Math.random() < 0.4)) {
        shotType = 'guard';
      }

      const curlSign = Math.random() < 0.5 ? -1 : 1;
      const lateralNoise = (spread) => THREE.MathUtils.randFloatSpread(spread * (1.25 - accuracy * 0.5));
      let target = new THREE.Vector3(0, start.y, housePositionZ);
      let power = params.throwPower;
      let spin = THREE.MathUtils.lerp(params.spinCurl * 0.22, params.spinCurl * 0.65, accuracy) * curlSign;

      if (shotType === 'guard') {
        const cover = aiInHouse[0] || opponentInHouse[0];
        const guardZ = housePositionZ + params.houseRadius + 2.2 + THREE.MathUtils.randFloatSpread(0.8);
        target = new THREE.Vector3(
          (cover ? cover.body.position.x : 0) + lateralNoise(params.houseRadius * 0.35),
          start.y,
          guardZ
        );
        power *= THREE.MathUtils.lerp(0.5, 0.7, accuracy);
      } else if (shotType === 'takeout' && opponentInHouse.length) {
        const targetStone = pickTargetStone(opponentInHouse);
        target = targetStone ? targetStone.body.position.clone() : target;
        target.x += lateralNoise(params.houseRadius * 0.15);
        spin = THREE.MathUtils.lerp(params.spinCurl * 0.1, params.spinCurl * 0.35, accuracy) * curlSign;
        power *= THREE.MathUtils.lerp(0.82, 0.98, accuracy);
      } else {
        target = new THREE.Vector3(
          lateralNoise(params.houseRadius * 0.5) + curlSign * THREE.MathUtils.lerp(0.35, 0.9, accuracy),
          start.y,
          housePositionZ + THREE.MathUtils.randFloatSpread(params.houseRadius * 0.4)
        );
        power *= THREE.MathUtils.lerp(0.64, 0.82, accuracy);
      }

      const dist = Math.abs(start.z - target.z);
      const distanceScale = THREE.MathUtils.clamp(dist / (params.sheetLength * 0.95), 0.55, 1);
      const weightJitter = 0.9 + (1 - accuracy) * 0.25 + THREE.MathUtils.randFloatSpread(0.12);
      power = Math.max(3, power * params.aiWeightBias * distanceScale * weightJitter);

      const dir = new THREE.Vector3(target.x - start.x, 0, target.z - start.z).normalize();
      throwStone(gameState.activeStone, dir, power, spin);
    }

    function throwStone(stone, dir, power, spin) {
      stone.thrown = true;
      const force = new CANNON.Vec3(dir.x, 0, dir.z).scale(power);
      stone.body.velocity.copy(force);
      stone.spin = spin;
      gameState.thrown[stone.team] += 1;
      hud.status.textContent = `Stone released (${teamLabel(stone.team)})`;
      drawHudCanvas();
      if (stone.team === 'player') triggerCrowdCheer(0.2);
      startAudio(stone.team === 'player');
      ensureSlideSound(stone.body);
    }

    function releaseStone(stone, velocity, spin) {
      stone.body.type = CANNON.Body.DYNAMIC;
      stone.body.mass = params.stoneMass;
      stone.body.updateMassProperties();
      stone.body.velocity.copy(velocity);
      stone.body.angularVelocity.set(0, 0, 0);
      stone.body.wakeUp();
      stone.thrown = true;
      stone.spin = spin || 0;
      gameState.thrown[stone.team] += 1;
      hud.status.textContent = `Stone released (${teamLabel(stone.team)})`;
      drawHudCanvas();
      startAudio(true);
      ensureSlideSound(stone.body);
    }

    function syncStoneTransforms(list) {
      list.forEach(s => {
        s.mesh.position.copy(s.body.position);
        s.mesh.quaternion.copy(s.body.quaternion).multiply(stoneVisualRotation);
        if (s.debug) {
          s.debug.position.copy(s.body.position);
          s.debug.quaternion.copy(s.body.quaternion);
        }
      });
    }

    function computePushDirection(controller) {
      if (params.useControllerAim && controller) {
        const dir = new THREE.Vector3();
        controller.getWorldDirection(dir);
        dir.y = 0;
        if (dir.lengthSq() < 0.001) dir.set(0, 0, -1);
        return dir.normalize();
      }
      if (params.useControllerAim && !controller) {
        const dir = new THREE.Vector3();
        camera.getWorldDirection(dir);
        dir.y = 0;
        if (dir.lengthSq() < 0.001) dir.set(0, 0, -1);
        return dir.normalize();
      }
      const angle = THREE.MathUtils.degToRad(params.pushDirectionDeg);
      return new THREE.Vector3(Math.sin(angle), 0, -Math.cos(angle)).normalize();
    }

    function computeMotionThrow(controller) {
      if (!controller) return null;
      const state = controllerState.get(controller);
      if (!state) return null;
      const flatVel = state.vel.clone();
      flatVel.y = 0;
      const speed = flatVel.length();
      if (speed < 0.05) return null;
      const dir = flatVel.normalize();
      const cappedSpeed = Math.min(speed * params.motionPowerScale, params.pushSpeed);
      const spin = THREE.MathUtils.clamp((state.angVel ? state.angVel.y : 0) * params.twistSpinScale, -5, 5);
      return { dir, speed: cappedSpeed, spin };
    }

    function setupAudioUnlock() {
      const unlock = () => {
        audio.hasGesture = true;
        startAudio(true);
      };
      ['pointerdown', 'touchstart', 'keydown'].forEach(evt => {
        window.addEventListener(evt, unlock, { once: true });
      });
    }

    async function startAudio(fromUser = false) {
      if (audio.ready) return;
      audio.hasGesture = audio.hasGesture || fromUser;
      if (!audio.hasGesture) return;
      try {
        audio.ctx = audio.ctx || new (window.AudioContext || window.webkitAudioContext)();
        await audio.ctx.resume();
        audio.slideBuffers.brown = createBrownNoiseBuffer();
        audio.slideBuffers.pink = createPinkNoiseBuffer();
        audio.buffers.ambience = await loadAudioBuffer('Ambience.mp3');
        audio.buffers.hard = await loadAudioBuffer('hardhit.wav');
        audio.buffers.soft = await loadAudioBuffer('softhit.wav');
        playAmbience();
        audio.ready = true;
      } catch (e) {
        console.warn('Audio init failed', e);
      }
    }

    async function loadAudioBuffer(path) {
      const res = await fetch(path);
      const arr = await res.arrayBuffer();
      return await audio.ctx.decodeAudioData(arr);
    }

    function playAmbience() {
      if (!audio.buffers.ambience || !audio.ctx) return;
      const src = audio.ctx.createBufferSource();
      src.buffer = audio.buffers.ambience;
      src.loop = true;
      const gain = audio.ctx.createGain();
      gain.gain.value = 0.12;
      src.connect(gain).connect(audio.ctx.destination);
      src.start();
      audio.ambience = src;
    }

    function createBrownNoiseBuffer() {
      const sampleRate = audio.ctx.sampleRate;
      const bufferSize = sampleRate * 2;
      const buffer = audio.ctx.createBuffer(1, bufferSize, sampleRate);
      const data = buffer.getChannelData(0);
      let lastOut = 0;
      for (let i = 0; i < bufferSize; i++) {
        const white = Math.random() * 2 - 1;
        lastOut = (lastOut + 0.02 * white) / 1.02;
        data[i] = lastOut * 3.5;
      }
      return buffer;
    }

    function createPinkNoiseBuffer() {
      const sampleRate = audio.ctx.sampleRate;
      const bufferSize = sampleRate * 2;
      const buffer = audio.ctx.createBuffer(1, bufferSize, sampleRate);
      const data = buffer.getChannelData(0);
      let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
      for (let i = 0; i < bufferSize; i++) {
        const white = Math.random() * 2 - 1;
        b0 = 0.99886 * b0 + white * 0.0555179;
        b1 = 0.99332 * b1 + white * 0.0750759;
        b2 = 0.96900 * b2 + white * 0.1538520;
        b3 = 0.86650 * b3 + white * 0.3104856;
        b4 = 0.55000 * b4 + white * 0.5329522;
        b5 = -0.7616 * b5 - white * 0.0168980;
        data[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
        data[i] *= 0.11;
        b6 = white * 0.115926;
      }
      return buffer;
    }

    function attachStoneAudio(body) {
      body.addEventListener('collide', (e) => handleStoneCollision(e));
      body.userData = body.userData || {};
    }

    function stopStoneAudio(body) {
      const slide = body.userData?.slide;
      if (!slide) return;
      ['brown', 'pink'].forEach((key) => {
        const src = slide[key];
        try { src?.stop?.(); } catch (e) { /* ignore ended node */ }
        src?.disconnect?.();
      });
      [slide.rumbleGain, slide.scrapeGain, slide.master].forEach((node) => node?.disconnect?.());
      body.userData.slide = null;
    }

    function ensureSlideSound(body) {
      if (!audio.ready || body.userData?.slide) return;
      const brown = audio.ctx.createBufferSource();
      brown.buffer = audio.slideBuffers.brown;
      brown.loop = true;
      const pink = audio.ctx.createBufferSource();
      pink.buffer = audio.slideBuffers.pink;
      pink.loop = true;

      const rumbleFilter = audio.ctx.createBiquadFilter();
      rumbleFilter.type = 'lowpass';
      rumbleFilter.frequency.value = 80;

      const scrapeFilter = audio.ctx.createBiquadFilter();
      scrapeFilter.type = 'bandpass';
      scrapeFilter.Q.value = 1;
      scrapeFilter.frequency.value = 400;

      const rumbleGain = audio.ctx.createGain();
      rumbleGain.gain.value = 0;
      const scrapeGain = audio.ctx.createGain();
      scrapeGain.gain.value = 0;

      const master = audio.ctx.createGain();
      master.gain.value = 0.5;

      brown.connect(rumbleFilter).connect(rumbleGain).connect(master);
      pink.connect(scrapeFilter).connect(scrapeGain).connect(master);
      master.connect(audio.ctx.destination);

      brown.start();
      pink.start();

      body.userData = body.userData || {};
      body.userData.slide = { brown, pink, rumbleFilter, scrapeFilter, rumbleGain, scrapeGain, master };
    }

    function updateSlideSound(body, isMoving) {
      if (!audio.ready || !body.userData?.slide) return;
      const slide = body.userData.slide;
      const speed = body.velocity.length();
      const vNorm = Math.min(1, Math.max(0, (speed - 0.05) / 5));
      const grit = THREE.MathUtils.clamp(params.friction / 0.002, 0, 1);
      const t = audio.ctx.currentTime;
      const rumbleVol = vNorm * 0.4;
      const rumbleFreq = 60 + vNorm * 150;
      const scrapeVol = vNorm * (0.2 + grit * 0.4);
      const scrapeFreq = 300 + vNorm * 800 + grit * 200;
      const scrapeQ = 0.5 + vNorm * 2;

      slide.rumbleGain.gain.setTargetAtTime(rumbleVol, t, 0.05);
      slide.rumbleFilter.frequency.setTargetAtTime(rumbleFreq, t, 0.05);
      slide.scrapeGain.gain.setTargetAtTime(scrapeVol, t, 0.05);
      slide.scrapeFilter.frequency.setTargetAtTime(scrapeFreq, t, 0.05);
      slide.scrapeFilter.Q.setTargetAtTime(scrapeQ, t, 0.05);

      if (!isMoving || speed < 0.05) {
        slide.rumbleGain.gain.setTargetAtTime(0, t, 0.08);
        slide.scrapeGain.gain.setTargetAtTime(0, t, 0.08);
      }
    }

    function handleStoneCollision(e) {
      if (!audio.ready) return;
      const other = e.body;
      const contact = e.contact;
      let impact = 0;
      if (contact && contact.getImpactVelocityAlongNormal) {
        impact = Math.abs(contact.getImpactVelocityAlongNormal());
      } else if (contact && contact.impactVelocity) {
        impact = Math.abs(contact.impactVelocity);
      } else {
        const rv = e.target.velocity.vsub(other.velocity);
        impact = rv.length();
      }
      if (impact < 0.15) return;
      const isStoneHit = other.material && other.material.name === 'stone';
      const buf = impact > 2 || isStoneHit ? audio.buffers.hard : audio.buffers.soft;
      if (!buf) return;
      const src = audio.ctx.createBufferSource();
      src.buffer = buf;
      const gain = audio.ctx.createGain();
      gain.gain.value = Math.min(0.2, 0.04 + impact * 0.06);
      src.connect(gain).connect(audio.ctx.destination);
      src.start();
    }

    function updateMiniMap() {
      if (!miniCtx) return;
      const w = miniMap.width, h = miniMap.height;
      miniCtx.clearRect(0, 0, w, h);
      miniCtx.fillStyle = 'rgba(6,12,20,0.95)';
      miniCtx.fillRect(0, 0, w, h);
      const cx = w / 2, cy = h / 2;
      const scale = Math.min(w, h) * 0.5 / params.houseRadius;
      const { rings } = (function getRingSpecs() {
        const standardOuter = 1.83;
        const scale = params.houseRadius / standardOuter;
        return {
          rings: [
            { outer: 1.83 * scale, color: '#1d68ff' },
            { outer: 1.22 * scale, color: '#ffffff' },
            { outer: 0.61 * scale, color: '#c82b41' },
            { outer: 0.1525 * scale, color: '#f7d80b' }
          ]
        };
      })();
      rings.forEach((ring) => {
        miniCtx.beginPath();
        miniCtx.strokeStyle = ring.color;
        miniCtx.lineWidth = 4;
        miniCtx.arc(cx, cy, ring.outer * scale, 0, Math.PI * 2);
        miniCtx.stroke();
      });
      const scoring = computeScoringData();
      stones.filter(s => s.thrown).forEach((s) => {
        const dx = s.body.position.x;
        const dz = s.body.position.z - housePositionZ;
        const x = cx + dx * scale;
        const y = cy - dz * scale;
        const dims = stoneDimsFor(s.team);
        const rad = Math.max(4, dims.radius * scale * 0.6);
        miniCtx.beginPath();
        miniCtx.fillStyle = s.team === 'player' ? '#ff6b8b' : '#ffd84d';
        miniCtx.strokeStyle = '#111';
        miniCtx.lineWidth = 1;
        miniCtx.arc(x, y, rad, 0, Math.PI * 2);
        miniCtx.fill();
        miniCtx.stroke();
        if (scoring.scoring && scoring.scoring.includes(s)) {
          miniCtx.beginPath();
          miniCtx.strokeStyle = '#00ffae';
          miniCtx.lineWidth = 2;
          miniCtx.arc(x, y, rad + 2, 0, Math.PI * 2);
          miniCtx.stroke();
        }
      });
      miniCtx.fillStyle = '#9fb4cc';
      miniCtx.font = '12px sans-serif';
      miniCtx.fillText('House view', 8, 16);
      if (miniMapTexture) miniMapTexture.needsUpdate = true;
    }

    function showEndOverlay(pScore, aScore) {
      const isFinal = gameState.currentEnd >= gameState.totalEnds;
      const winner = gameState.scores.player === gameState.scores.ai ? 'Tied' :
        (gameState.scores.player > gameState.scores.ai ? `${teamNames.player} leads` : `${teamNames.ai} leads`);
      endTitle.textContent = isFinal ? 'Game Complete' : `End ${gameState.currentEnd} Complete`;
      endBody.textContent = `End score - ${teamNames.player}: ${pScore}, ${teamNames.ai}: ${aScore}. Cumulative ${gameState.scores.player} - ${gameState.scores.ai} (${winner}).`;
      endScores.innerHTML = renderEndScoresTable(isFinal);
      nextEndBtn.style.display = isFinal ? 'none' : 'inline-block';
      playAgainBtn.style.display = isFinal ? 'inline-block' : 'none';
      quitBtn.style.display = isFinal ? 'inline-block' : 'none';
      endOverlay.style.display = 'flex';
      showVRPrompt(pScore, aScore);
      const cheerStrength = Math.max(pScore, aScore) > 0 ? 0.4 + Math.max(pScore, aScore) * 0.3 : 0.2;
      triggerCrowdCheer(cheerStrength);
      gameState.gameOver = isFinal;
      buildCrowd(); // increase crowd interest for next end
    }

    function renderEndScoresTable(includeFinal) {
      const rows = gameState.endScores.map(es => `<div>End ${es.end}: ${teamNames.player} ${es.player} - ${teamNames.ai} ${es.ai}</div>`).join('');
      const finalLine = includeFinal ? `<div style="margin-top:6px;"><strong>Final:</strong> ${teamNames.player} ${gameState.scores.player} - ${teamNames.ai} ${gameState.scores.ai}</div>` : '';
      return rows + finalLine;
    }

    function handleNextEnd() {
      if (gameState.currentEnd >= gameState.totalEnds) return;
      gameState.currentEnd += 1;
      endOverlay.style.display = 'none';
      hideVRPrompt();
      resetEnd();
      gameState.waitingForNextEnd = false;
      buildCrowd();
      drawHudCanvas();
    }

    function resetGame() {
      endOverlay.style.display = 'none';
      hideVRPrompt();
      gameState.scores.player = 0;
      gameState.scores.ai = 0;
      gameState.endScores = [];
      gameState.currentEnd = 1;
      gameState.gameOver = false;
      gameState.waitingForNextEnd = false;
      resetEnd();
      buildCrowd();
      drawHudCanvas();
    }

    function handleQuit() {
      gameState.gameOver = true;
      gameState.waitingForNextEnd = true;
      endOverlay.style.display = 'none';
      hideVRPrompt();
      hud.status.textContent = 'Game ended.';
      drawHudCanvas();
    }

    function updateStoneMeshes() {
      syncStoneTransforms(stones);
    }

    function monitorStoneState() {
      const active = gameState.activeStone;
      if (!active || !active.thrown) return;
      if (active.body.sleepState === CANNON.Body.SLEEPING ||
        active.body.velocity.lengthSquared() < 0.0006) {
        advanceTurn();
      }
    }

    function advanceTurn() {
      gameState.activeStone = null;
      const total = gameState.thrown.player + gameState.thrown.ai;
      if (total >= gameState.stonesPerTeam * 2) {
        evaluateScore();
        return;
      }
      const other = gameState.currentTeam === 'player' ? 'ai' : 'player';
      let next = other;
      if (gameState.thrown[next] >= gameState.stonesPerTeam) {
        next = gameState.currentTeam;
      }
      gameState.currentTeam = next;
      startTurn(next);
    }

    function startTurn(team) {
      if (gameState.waitingForNextEnd || gameState.gameOver) return;
      gameState.currentTeam = team;
      spawnStone(team);
      updateHud();
      if (team === 'ai') {
        hud.status.textContent = `${teamNames.ai} thinking...`;
        setTimeout(aiThrow, 800);
      } else {
        hud.status.textContent = 'Grip to grab, move, release to throw (trigger also works).';
      }
      drawHudCanvas();
    }

    function evaluateScore() {
      const result = computeScoringData();
      let pScore = 0, aScore = 0;
      if (result.winner) {
        if (result.winner === 'player') pScore = result.points;
        else aScore = result.points;
      }
      gameState.scores.player += pScore;
      gameState.scores.ai += aScore;
      gameState.endScores.push({ end: gameState.currentEnd, player: pScore, ai: aScore });
      gameState.waitingForNextEnd = true;
      gameState.inEnd = false;
      updateHud();
      showEndOverlay(pScore, aScore);
    }

    function clearStones() {
      stones.forEach(s => {
        scene.remove(s.mesh);
        world.removeBody(s.body);
        if (s.debug) {
          scene.remove(s.debug);
          s.debug.geometry.dispose();
          s.debug.material.dispose();
        }
        stopStoneAudio(s.body);
      });
      stones.length = 0;
    }

    function resetEnd() {
      gameState.waitingForNextEnd = false;
      gameState.gameOver = false;
      clearStones();
      gameState.thrown.player = 0;
      gameState.thrown.ai = 0;
      gameState.currentTeam = 'player';
      gameState.activeStone = null;
      gameState.inEnd = true;
      startTurn('player');
    }

    function getEndValue(endNumber, team) {
      const found = gameState.endScores.find(e => e.end === endNumber);
      return found ? found[team] : null;
    }

    function renderEndHeader() {
      if (!hud.endColumns) return;
      hud.endColumns.innerHTML = '';
      for (let i = 1; i <= gameState.totalEnds; i++) {
        const cell = document.createElement('div');
        cell.className = 'end-cell head';
        if (i === gameState.currentEnd) cell.classList.add('active');
        cell.textContent = i;
        hud.endColumns.appendChild(cell);
      }
    }

    function renderEndRow(container, team) {
      if (!container) return;
      container.innerHTML = '';
      for (let i = 1; i <= gameState.totalEnds; i++) {
        const val = getEndValue(i, team);
        const cell = document.createElement('div');
        cell.className = 'end-cell';
        if (i === gameState.currentEnd && gameState.inEnd && !gameState.waitingForNextEnd) {
          cell.classList.add('active');
        }
        cell.textContent = val != null ? val : (i === gameState.currentEnd ? '*' : '-');
        container.appendChild(cell);
      }
    }

    function renderStoneTrack(container, team) {
      if (!container) return;
      container.innerHTML = '';
      const used = gameState.thrown[team];
      for (let i = 0; i < gameState.stonesPerTeam; i++) {
        const pip = document.createElement('span');
        pip.className = `pip ${team}`;
        if (i < used) pip.classList.add('used');
        if (gameState.currentTeam === team && i === used && gameState.inEnd && !gameState.waitingForNextEnd) {
          pip.classList.add('active');
        }
        container.appendChild(pip);
      }
    }

    function updateScoreboardGrid() {
      if (hud.scoreboard) hud.scoreboard.style.setProperty('--end-count', gameState.totalEnds);
      renderEndHeader();
      renderEndRow(hud.playerEnds, 'player');
      renderEndRow(hud.aiEnds, 'ai');
      renderStoneTrack(hud.playerStones, 'player');
      renderStoneTrack(hud.aiStones, 'ai');
      if (hud.playerTotal) hud.playerTotal.textContent = gameState.scores.player;
      if (hud.aiTotal) hud.aiTotal.textContent = gameState.scores.ai;
      ['player', 'ai'].forEach((team) => {
        const row = hud.rows && hud.rows[team];
        if (row) row.classList.toggle('active', gameState.currentTeam === team && !gameState.waitingForNextEnd);
      });
    }

    function updateHud() {
      const nextTeamName = teamLabel(gameState.currentTeam);
      const remainingPlayer = Math.max(0, gameState.stonesPerTeam - gameState.thrown.player);
      const remainingAi = Math.max(0, gameState.stonesPerTeam - gameState.thrown.ai);
      if (hud.turn) hud.turn.textContent = `${nextTeamName} to deliver`;
      if (hud.stones) hud.stones.textContent = `Stones remaining (${teamNames.player} / ${teamNames.ai}): ${remainingPlayer} / ${remainingAi}`;
      if (hud.score) hud.score.textContent = `Totals: ${teamNames.player} ${gameState.scores.player} | ${teamNames.ai} ${gameState.scores.ai}`;
      if (hud.end) hud.end.textContent = `End ${gameState.currentEnd} of ${gameState.totalEnds}`;
      updateScoreboardGrid();
      drawHudCanvas();
    }

    function computeScoringData() {
      const center = new THREE.Vector3(0, 0, housePositionZ);
      const withinHouse = stones.filter(s => {
        if (!s.thrown) return false;
        const p = s.body.position;
        const dist = Math.hypot(p.x - center.x, p.z - center.z);
        return dist <= params.houseRadius * 1.05;
      });
      withinHouse.sort((a, b) => {
        const da = Math.hypot(a.body.position.x - center.x, a.body.position.z - center.z);
        const db = Math.hypot(b.body.position.x - center.x, b.body.position.z - center.z);
        return da - db;
      });
      if (withinHouse.length === 0) return { winner: null, points: 0, scoring: [] };
      const winner = withinHouse[0].team;
      const opponent = winner === 'player' ? 'ai' : 'player';
      const opponentBest = withinHouse.find(s => s.team === opponent);
      const cutoff = opponentBest ?
        Math.hypot(opponentBest.body.position.x - center.x, opponentBest.body.position.z - center.z) :
        Infinity;
      const scoring = withinHouse.filter(s => s.team === winner &&
        Math.hypot(s.body.position.x - center.x, s.body.position.z - center.z) < cutoff);
      return { winner, points: scoring.length, scoring, withinHouse };
    }

    function createAimArrow() {
      const geo = new THREE.CylinderGeometry(0, 0.04, 0.3, 8, 1);
      const mat = new THREE.MeshBasicMaterial({ color: '#ffdd55' });
      const arrow = new THREE.Mesh(geo, mat);
      arrow.rotation.x = Math.PI / 2;
      arrow.position.set(0, 0.2, params.sheetLength / 2 - 2);
      return arrow;
    }

    function updateAimIndicator() {
      const active = gameState.activeStone;
      if (!active || active.thrown) {
        crosshair.style.display = 'none';
        return;
      }
      crosshair.style.display = 'block';
      // The yellow helper arrow is intentionally suppressed.
      aimArrow.visible = false;
    }

    function pickRightController() {
      const session = renderer.xr.getSession();
      if (!session) return null;
      for (let i = 0; i < session.inputSources.length; i++) {
        const src = session.inputSources[i];
        if (src.handedness === 'right') {
          return src.targetRaySpace ? renderer.xr.getController(i) : null;
        }
      }
      return null;
    }

    function applySpinCurve(list = stones) {
      list.forEach((s) => {
        if (!s.thrown || s.body.sleepState === CANNON.Body.SLEEPING) return;
        const vel = s.body.velocity;
        const speed = Math.sqrt(vel.x * vel.x + vel.z * vel.z);
        if (speed < 0.01 || Math.abs(s.spin) < 0.01) return;
        const dir = new CANNON.Vec3(vel.x / speed, 0, vel.z / speed);
        const sideways = new CANNON.Vec3(-dir.z, 0, dir.x).scale(s.spin * params.iceCurl);
        s.body.applyForce(sideways, s.body.position);
      });
    }

    function pollButtons() {
      const session = renderer.xr.getSession();
      if (!session) return;
      session.inputSources.forEach((src) => {
        if (src.handedness !== 'left' || !src.gamepad) return;
        const btn = src.gamepad.buttons[3] || src.gamepad.buttons[1];
        const pressed = !!(btn && btn.pressed);
        if (pressed && !bButtonState) toggleUI();
        bButtonState = pressed;
      });
    }

    function toggleUI() {
      uiVisible = !uiVisible;
      uiPanel.style.display = uiVisible ? 'block' : 'none';
      wrapHelpers.visible = uiVisible;
      setStoneWrapVisible(uiVisible);
    }

    function setStoneWrapVisible(flag) {
      stones.forEach((s) => {
        if (s.debug) s.debug.visible = !!flag;
      });
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function buildControl(label, key, min, max, step) {
      const wrap = document.createElement('div');
      wrap.className = 'control';
      const title = document.createElement('label');
      const name = document.createElement('span');
      name.textContent = label;
      const value = document.createElement('span');
      value.className = 'value';
      value.textContent = params[key];
      title.appendChild(name);
      title.appendChild(value);
      const input = document.createElement('input');
      input.type = 'range';
      input.min = min;
      input.max = max;
      input.step = step;
      input.value = params[key];
      input.addEventListener('input', () => {
        const val = parseFloat(input.value);
        params[key] = val;
        value.textContent = val;
        applyParamChange(key);
      });
      wrap.appendChild(title);
      wrap.appendChild(input);
      return wrap;
    }

    function buildButton(label, onClick) {
      const btn = document.createElement('button');
      btn.textContent = label;
      btn.style.width = '100%';
      btn.style.padding = '8px';
      btn.style.marginTop = '6px';
      btn.style.background = '#13334c';
      btn.style.color = '#e9f2ff';
      btn.style.border = '1px solid rgba(255,255,255,0.2)';
      btn.style.borderRadius = '8px';
      btn.style.cursor = 'pointer';
      btn.addEventListener('click', onClick);
      btn.addEventListener('pointerdown', onClick);
      return btn;
    }

    function initUI() {
      const groups = [
        {
          title: 'Sheet',
          controls: [
            ['Length (m)', 'sheetLength', 36, 48, 0.25],
            ['Width (m)', 'sheetWidth', 4, 6, 0.1],
            ['House radius', 'houseRadius', 1.2, 2.5, 0.05]
          ]
        },
        {
          title: 'Stone',
          controls: [
            ['Radius', 'stoneRadius', 0.1, 2.5, 0.01],
            ['Height', 'stoneHeight', 0.08, 1.6, 0.01],
            ['Wrap scale', 'stoneScale', 0.01, 0.48, 0.01],
            ['AI scale x', 'aiStoneScaleFactor', 0.5, 12, 0.1],
            ['Mass', 'stoneMass', 12, 26, 0.5]
          ]
        },
        {
          title: 'Physics',
          controls: [
            // Center at 0.001 for finer low-range control
            ['Friction', 'friction', 0.00001, 0.002, 0.00001],
            ['Restitution', 'restitution', 0.01, 0.3, 0.005],
            ['Ice drag', 'iceDrag', 0.00001, 0.002, 0.00001],
            ['Spin drag', 'spinDrag', 0, 4, 0.05],
            ['Ice curl', 'iceCurl', 0.01, 0.6, 0.01],
            ['Spin curl', 'spinCurl', 0.05, 0.6, 0.01]
          ]
        },
        {
          title: 'Gameplay',
          controls: [
            ['Throw power (AI)', 'throwPower', 4, 36, 0.1],
            ['AI accuracy', 'aiAccuracy', 0.1, 1, 0.05],
            ['AI weight bias', 'aiWeightBias', 0.4, 1.6, 0.02]
          ]
        },
        {
          title: 'Push controls (all throws)',
          controls: [
            ['Push speed', 'pushSpeed', 0.5, 48, 0.1],
            ['Direction deg', 'pushDirectionDeg', -180, 180, 1],
            ['Spin (signed)', 'pushSpin', -2, 2, 0.05],
            ['Motion power scale', 'motionPowerScale', 0.2, 3, 0.05],
            ['Twist spin scale', 'twistSpinScale', 0, 3, 0.05]
          ]
        }
      ];

      groups.forEach(section => {
        const box = document.createElement('div');
        box.className = 'section';
        const header = document.createElement('h3');
        header.textContent = section.title;
        box.appendChild(header);
        section.controls.forEach(args => box.appendChild(buildControl(...args)));
        uiContent.appendChild(box);
      });

      const aimToggle = document.createElement('div');
      aimToggle.className = 'control';
      const label = document.createElement('label');
      label.textContent = 'Use controller/camera aim';
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = params.useControllerAim;
      checkbox.style.marginLeft = '8px';
      checkbox.addEventListener('change', () => {
        params.useControllerAim = checkbox.checked;
      });
      aimToggle.appendChild(label);
      aimToggle.appendChild(checkbox);
      uiPanel.appendChild(aimToggle);

      const envSection = document.createElement('div');
      envSection.className = 'section';
      const envHeader = document.createElement('h3');
      envHeader.textContent = 'Environment';
      envSection.appendChild(envHeader);
      const lightingLabel = document.createElement('div');
      lightingLabel.textContent = 'Lighting base';
      lightingLabel.className = 'muted';
      lightingLabel.style.fontSize = '12px';
      lightingLabel.style.marginTop = '4px';
      envSection.appendChild(lightingLabel);
      envSection.appendChild(buildButton('Domed arena', () => setEnvironmentTheme('domed')));
      envSection.appendChild(buildButton('Outdoor sheet', () => setEnvironmentTheme('outdoor')));
      const envMapLabel = document.createElement('div');
      envMapLabel.textContent = 'Environment map';
      envMapLabel.className = 'muted';
      envMapLabel.style.fontSize = '12px';
      envMapLabel.style.marginTop = '10px';
      envSection.appendChild(envMapLabel);
      envSection.appendChild(buildButton('Passendorf HDR', () => setEnvironmentMode('passendorf')));
      envSection.appendChild(buildButton('Indoor rink HDR', () => setEnvironmentMode('rink')));
      envSection.appendChild(buildButton('Sky dome only', () => setEnvironmentMode('off')));
      uiPanel.appendChild(envSection);
    }

    function applyParamChange(key) {
      switch (key) {
        case 'sheetLength':
        case 'sheetWidth':
        case 'houseRadius':
          initSheet();
          buildEnvironment();
          updateRigPosition();
          repositionWaitingStone();
          break;
        case 'stoneScale':
        case 'stoneRadius':
        case 'stoneHeight':
          stones.forEach((s) => retuneStonePhysics(s));
          repositionWaitingStone();
          break;
        case 'aiStoneScaleFactor':
          stones.forEach((s) => { if (s.team === 'ai') retuneStonePhysics(s); });
          repositionWaitingStone();
          break;
        case 'stoneMass':
          stones.forEach((s) => { s.body.mass = params.stoneMass; s.body.updateMassProperties(); });
          break;
        case 'friction':
          contact.friction = params.friction;
          break;
        case 'restitution':
          contact.restitution = params.restitution;
          break;
        case 'iceDrag':
          stones.forEach((s) => {
            s.body.linearDamping = params.iceDrag;
            s.body.angularDamping = physicsSpinDamping(params.spinDrag);
          });
          break;
        case 'spinDrag':
          stones.forEach((s) => { s.body.angularDamping = physicsSpinDamping(params.spinDrag); });
          break;
        default:
          break;
      }
    }

    function setEnvironmentTheme(theme) {
      params.environmentTheme = theme;
      buildEnvironment();
      drawHudCanvas();
    }

    function setEnvironmentMode(mode) {
      const idx = environmentModes.indexOf(mode);
      if (idx >= 0) {
        environmentModeIndex = idx;
        applyEnvironment(mode);
      }
    }

    function retuneStonePhysics(stone) {
      const dims = stoneDimsFor(stone.team);
      const spinDamping = physicsSpinDamping(params.spinDrag);
      stone.mesh.scale.setScalar(params.visualStoneScale);
      stone.body.shapes.length = 0;
      stone.body.shapeOffsets.length = 0;
      stone.body.shapeOrientations.length = 0;
      const shape = new CANNON.Cylinder(dims.radius, dims.radius, dims.height, 20);
      stone.body.addShape(shape);
      stone.body.mass = params.stoneMass;
      stone.body.updateMassProperties();
      stone.body.aabbNeedsUpdate = true;
      stone.body.linearDamping = params.iceDrag;
      stone.body.angularDamping = spinDamping;
      stone.body.angularFactor.set(0, 1, 0);
      stone.body.linearFactor.set(1, 0, 1);
      if (stone.debug) {
        scene.remove(stone.debug);
        stone.debug.geometry.dispose();
        stone.debug.material.dispose();
        stone.debug = createPhysicsDebugMesh(stone.team);
        stone.debug.visible = false;
        scene.add(stone.debug);
      }
      if (!stone.thrown) {
        stone.body.position.y = dims.height / 2;
      }
    }

    function createPhysicsDebugMesh(team) {
      const dims = stoneDimsFor(team);
      const geo = new THREE.CylinderGeometry(dims.radius, dims.radius, dims.height, 24);
      const mat = new THREE.MeshBasicMaterial({
        color: team === 'player' ? '#ff6b8b' : '#ffd84d',
        wireframe: true,
        transparent: true,
        opacity: 0.85,
        depthTest: false
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.renderOrder = 999;
      mesh.visible = false;
      return mesh;
    }

    function updateRigPosition() {
      const spawnZ = getSpawnZ();
      playerRig.position.set(0, 0, spawnZ);
      if (controls) {
        controls.target.set(0, 0.5, housePositionZ);
        controls.update();
      }
    }

    function disposeGroup(group) {
      group.children.slice().forEach((child) => {
        group.remove(child);
        child.traverse?.((c) => {
          if (c.geometry) c.geometry.dispose?.();
          if (c.material) {
            if (Array.isArray(c.material)) c.material.forEach(m => m.dispose?.());
            else c.material.dispose?.();
          }
        });
      });
    }

    async function loadEnvironmentMaps() {
      try {
        const hdrTexture = await rgbeLoader.loadAsync('passendorf_snow_4k.hdr');
        hdrTexture.mapping = THREE.EquirectangularReflectionMapping;
        hdrTexture.colorSpace = THREE.LinearSRGBColorSpace;
        environmentMaps.passendorf = {
          env: pmremGenerator.fromEquirectangular(hdrTexture).texture,
          background: hdrTexture
        };
      } catch (err) {
        console.warn('Failed to load HDR environment', err);
      }

      try {
        const rinkTexture = await textureLoader.loadAsync('Rink.jpeg');
        rinkTexture.mapping = THREE.EquirectangularReflectionMapping;
        rinkTexture.colorSpace = THREE.SRGBColorSpace;
        environmentMaps.rink = {
          env: pmremGenerator.fromEquirectangular(rinkTexture).texture,
          background: rinkTexture
        };
      } catch (err) {
        console.warn('Failed to load rink environment', err);
      }

      applyEnvironment(currentEnvironmentMode);
    }

    function applyEnvironment(mode = currentEnvironmentMode) {
      currentEnvironmentMode = mode;
      const entry = environmentMaps[mode] || {};
      const envTex = entry.env || null;
      const bgTex = mode === 'off' ? null : (entry.background || null);
      scene.environment = envTex;
      if (bgTex) {
        scene.background = bgTex;
      } else if (environmentBaseBackground) {
        scene.background = environmentBaseBackground.clone ? environmentBaseBackground.clone() : environmentBaseBackground;
      }
      if (skyDome) skyDome.visible = mode === 'off';
    }

    function cycleEnvironmentMode() {
      environmentModeIndex = (environmentModeIndex + 1) % environmentModes.length;
      currentEnvironmentMode = environmentModes[environmentModeIndex];
      applyEnvironment(currentEnvironmentMode);
    }

    function applyGroundTexture(material) {
      const tex = makeIceTexture();
      material.map = tex;
      material.roughnessMap = tex;
      material.bumpMap = tex;
      material.bumpScale = 0.012;
      material.needsUpdate = true;
    }

    function makeIceTexture() {
      if (iceTexture) return iceTexture;
      const size = 1024;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      const base = ctx.createLinearGradient(0, 0, size, size);
      base.addColorStop(0, '#e6eef9');
      base.addColorStop(1, '#c9d9eb');
      ctx.fillStyle = base;
      ctx.fillRect(0, 0, size, size);

      const noise = ctx.getImageData(0, 0, size, size);
      for (let i = 0; i < noise.data.length; i += 4) {
        const variance = Math.random() * 22;
        noise.data[i] = Math.min(255, noise.data[i] + variance * 0.35);
        noise.data[i + 1] = Math.min(255, noise.data[i + 1] + variance * 0.3);
        noise.data[i + 2] = Math.min(255, noise.data[i + 2] + variance);
      }
      ctx.putImageData(noise, 0, 0);

      for (let i = 0; i < 1200; i++) {
        const x = Math.random() * size;
        const y = Math.random() * size;
        const len = Math.random() * 28 + 8;
        const wobble = (Math.random() - 0.5) * 0.7;
        ctx.strokeStyle = `rgba(255,255,255,${Math.random() * 0.05 + 0.02})`;
        ctx.lineWidth = Math.random() * 1.2 + 0.2;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + len * Math.cos(wobble), y + len * Math.sin(wobble));
        ctx.stroke();
      }

      iceTexture = new THREE.CanvasTexture(canvas);
      iceTexture.wrapS = THREE.RepeatWrapping;
      iceTexture.wrapT = THREE.RepeatWrapping;
      iceTexture.repeat.set(8, 8);
      iceTexture.anisotropy = 8;
      iceTexture.needsUpdate = true;
      return iceTexture;
    }

    function buildEnvironment() {
      disposeGroup(envGroup);
      skyDome = null;
      const theme = params.environmentTheme || 'domed';
      environmentBaseBackground = new THREE.Color(theme === 'outdoor' ? '#7ab6ff' : '#0b192d');
      scene.background = environmentBaseBackground.clone();
      hemi.intensity = theme === 'outdoor' ? 1.0 : 0.9;
      dirLight.intensity = theme === 'outdoor' ? 0.75 : 0.9;

      const floorSize = Math.max(params.sheetLength, params.sheetWidth) * 3;
      const floorGeom = new THREE.PlaneGeometry(floorSize, floorSize);
      const floorMat = new THREE.MeshPhysicalMaterial({
        color: theme === 'outdoor' ? '#d7e6f5' : '#c6d8eb',
        roughness: 0.16,
        metalness: 0.08,
        reflectivity: 0.72,
        clearcoat: 0.9,
        clearcoatRoughness: 0.08,
        transmission: 0.02,
        ior: 1.31,
        envMapIntensity: 1.2
      });
      applyGroundTexture(floorMat);
      const floor = new THREE.Mesh(floorGeom, floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = -0.001;
      floor.receiveShadow = true;
      envGroup.add(floor);

      const boardHeight = stoneDimsFor('player').height * 1.4;
      const boardThickness = 0.15;
      const boardLen = params.sheetLength + 0.8;
      const boardWide = params.sheetWidth + 0.8;
      const boardMat = new THREE.MeshStandardMaterial({
        color: theme === 'outdoor' ? '#d9e4ec' : '#1a2638',
        emissive: theme === 'outdoor' ? '#8ba8c4' : '#0b101a',
        metalness: 0.2,
        roughness: 0.6
      });
      const makeBoard = (w, h, d, x, z, rotY = 0) => {
        const geo = new THREE.BoxGeometry(w, h, d);
        const mesh = new THREE.Mesh(geo, boardMat);
        mesh.position.set(x, h / 2, z);
        mesh.rotation.y = rotY;
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        envGroup.add(mesh);
      };
      makeBoard(boardThickness, boardHeight, boardLen, boardWide / 2, 0);
      makeBoard(boardThickness, boardHeight, boardLen, -boardWide / 2, 0);
      makeBoard(boardWide, boardHeight, boardThickness, 0, -boardLen / 2);

      const skyGeo = new THREE.SphereGeometry(70, 18, 12);
      const skyMat = new THREE.MeshBasicMaterial({ color: '#7ab6ff', side: THREE.BackSide });
      skyDome = new THREE.Mesh(skyGeo, skyMat);
      skyDome.position.y = 5;
      skyDome.visible = currentEnvironmentMode === 'off';
      envGroup.add(skyDome);

      const sun = new THREE.DirectionalLight(0xfff1c1, 0.55);
      sun.position.set(12, 18, 6);
      envGroup.add(sun);

      const bannerGeo = new THREE.PlaneGeometry(5, 1.2);
      const bannerMat = new THREE.MeshBasicMaterial({ color: '#1f7fff', transparent: true, opacity: 0.65 });
      const banner = new THREE.Mesh(bannerGeo, bannerMat);
      banner.position.set(0, boardHeight * 1.2, -boardLen / 2 - 0.05);
      envGroup.add(banner);

      const crowdGeo = new THREE.PlaneGeometry(boardWide, boardHeight * 1.5);
      const crowdMat = new THREE.MeshBasicMaterial({ color: '#112033', transparent: true, opacity: theme === 'outdoor' ? 0.4 : 0.6 });
      const crowd = new THREE.Mesh(crowdGeo, crowdMat);
      crowd.position.set(0, boardHeight * 0.75, -boardLen / 2 - 0.2);
      envGroup.add(crowd);

      buildVRPanels();
      buildCrowd(boardWide, boardLen, boardHeight);
      applyEnvironment(currentEnvironmentMode);
    }

    function buildVRPanels() {
      panelGroup.clear();
      const crowdSpread = params.sheetWidth * 1.6;
      const baseZ = housePositionZ - 1.5;
      const infoW = 13.2, infoH = 6.6;
      const mapW = 6.6, mapH = 6.6;

      // Info panel on left of crowd
      const infoRoot = new THREE.Group();
      infoRoot.position.set(-crowdSpread * 0.7 - infoW * 0.6, 2.0 + infoH * 0.02, baseZ);
      infoRoot.lookAt(new THREE.Vector3(playerRig.position.x, 1.6, playerRig.position.z));
      panelGroup.add(infoRoot);

      hudTexture = new THREE.CanvasTexture(hudCanvas);
      hudTexture.encoding = THREE.sRGBEncoding;
      hudTexture.needsUpdate = true;
      const hudMat = new THREE.MeshBasicMaterial({ map: hudTexture, transparent: true, side: THREE.DoubleSide });
      hudMesh = new THREE.Mesh(new THREE.PlaneGeometry(infoW, infoH), hudMat);
      hudMesh.position.set(0, infoH * 0.35, 0);
      hudMesh.renderOrder = 5;
      infoRoot.add(hudMesh);

      // Minimap panel on right of crowd, shifted further right by 75% of its width
      const mapRoot = new THREE.Group();
      mapRoot.position.set(crowdSpread * 0.7 + mapW * 0.75, 2.0 + mapH * 0.02, baseZ);
      mapRoot.lookAt(new THREE.Vector3(playerRig.position.x, 1.6, playerRig.position.z));
      panelGroup.add(mapRoot);

      miniMapTexture = new THREE.CanvasTexture(miniMap);
      miniMapTexture.encoding = THREE.sRGBEncoding;
      miniMapTexture.needsUpdate = true;
      const mmMat = new THREE.MeshBasicMaterial({ map: miniMapTexture, transparent: true, side: THREE.DoubleSide });
      miniMapMesh = new THREE.Mesh(new THREE.PlaneGeometry(mapW, mapH), mmMat);
      miniMapMesh.position.set(0, mapH * 0.3, 0);
      miniMapMesh.renderOrder = 5;
      mapRoot.add(miniMapMesh);

      drawHudCanvas();
      setupPointerLines();
    }

    function drawHudCanvas() {
      if (!hudCtx) return;
      const w = hudCanvas.width, h = hudCanvas.height;
      hudCtx.clearRect(0, 0, w, h);
      const bg = hudCtx.createLinearGradient(0, 0, w, h);
      bg.addColorStop(0, 'rgba(8,14,24,0.95)');
      bg.addColorStop(1, 'rgba(12,26,44,0.92)');
      hudCtx.fillStyle = bg;
      hudCtx.fillRect(0, 0, w, h);

      hudCtx.fillStyle = '#4de1ff';
      hudCtx.font = '26px "Barlow Condensed", "Segoe UI", sans-serif';
      hudCtx.textAlign = 'left';
      hudCtx.textBaseline = 'alphabetic';
      hudCtx.fillText(eventName.toUpperCase(), 18, 34);
      hudCtx.fillStyle = '#9fb4cc';
      hudCtx.font = '15px "Inter", "Segoe UI", sans-serif';
      hudCtx.fillText(`End ${gameState.currentEnd} of ${gameState.totalEnds} | Sheet A | ${matchupLabel}`, 18, 54);
      const nextTeam = teamLabel(gameState.currentTeam);
      hudCtx.fillStyle = '#e9f2ff';
      hudCtx.font = '17px "Inter", "Segoe UI", sans-serif';
      hudCtx.fillText(`${nextTeam} to deliver`, 18, 74);
      hudCtx.fillText(`Totals: ${teamNames.player} ${gameState.scores.player} | ${teamNames.ai} ${gameState.scores.ai}`, 18, 94);

      const pad = 16;
      const startY = 106;
      const teamColW = 110;
      const totalColW = 46;
      const endsCount = gameState.totalEnds;
      const endsWidth = w - pad * 2 - teamColW - totalColW;
      const cellW = endsWidth / endsCount;

      hudCtx.fillStyle = 'rgba(255,255,255,0.06)';
      hudCtx.fillRect(pad, startY, w - pad * 2, 24);
      hudCtx.textAlign = 'center';
      hudCtx.textBaseline = 'middle';
      hudCtx.font = '13px "Inter", "Segoe UI", sans-serif';
      hudCtx.fillStyle = '#9fb4cc';
      for (let i = 0; i < endsCount; i++) {
        const x = pad + teamColW + cellW * i + cellW / 2;
        if (i + 1 === gameState.currentEnd) {
          hudCtx.strokeStyle = 'rgba(77,225,255,0.6)';
          hudCtx.lineWidth = 2;
          hudCtx.strokeRect(pad + teamColW + cellW * i + 2, startY + 2, cellW - 4, 20);
        }
        hudCtx.fillText(i + 1, x, startY + 12);
      }
      const totalX = pad + teamColW + endsWidth + totalColW / 2;
      hudCtx.fillText('T', totalX, startY + 12);

      const rows = [
        { label: teamNames.player.toUpperCase(), team: 'player', color: '#ff6b8b' },
        { label: teamNames.ai.toUpperCase(), team: 'ai', color: '#ffd84d' }
      ];
      const rowGap = 34;
      rows.forEach((row, idx) => {
        const rowY = startY + 32 + idx * rowGap;
        const isActive = gameState.currentTeam === row.team && !gameState.waitingForNextEnd;
        if (isActive) {
          hudCtx.fillStyle = 'rgba(77,225,255,0.12)';
          hudCtx.fillRect(pad, rowY - 16, w - pad * 2, 30);
        }
        hudCtx.textAlign = 'left';
        hudCtx.fillStyle = row.color;
        hudCtx.font = '18px "Barlow Condensed", "Segoe UI", sans-serif';
        hudCtx.fillText(row.label, pad + 4, rowY);
        hudCtx.textAlign = 'center';
        hudCtx.font = '16px "Inter", "Segoe UI", sans-serif';
        for (let i = 0; i < endsCount; i++) {
          const endVal = getEndValue(i + 1, row.team);
          const display = endVal != null ? endVal : (i + 1 === gameState.currentEnd ? '*' : '-');
          const x = pad + teamColW + cellW * i + cellW / 2;
          hudCtx.fillStyle = endVal != null ? '#e9f2ff' : '#6f829c';
          hudCtx.fillText(display, x, rowY);
        }
        hudCtx.fillStyle = '#e9f2ff';
        hudCtx.fillText(gameState.scores[row.team], totalX, rowY);
      });

      const trackerStart = startY + 32 + rows.length * rowGap + 12;
      rows.forEach((row, idx) => {
        const y = trackerStart + idx * 18;
        hudCtx.textAlign = 'left';
        hudCtx.font = '12px "Inter", "Segoe UI", sans-serif';
        hudCtx.fillStyle = row.color;
        hudCtx.fillText('stones', pad + 4, y + 2);
        const totalStones = gameState.stonesPerTeam;
        const used = gameState.thrown[row.team];
        for (let i = 0; i < totalStones; i++) {
          const x = pad + 60 + i * 14;
          const isUsed = i < used;
          const isLive = gameState.currentTeam === row.team && i === used && gameState.inEnd && !gameState.waitingForNextEnd;
          const fill = row.team === 'player' ? ['#ffdce8', '#ff6b8b'] : ['#fff4cc', '#f3c228'];
          const grad = hudCtx.createRadialGradient(x - 3, y - 3, 2, x, y, 10);
          grad.addColorStop(0, fill[0]);
          grad.addColorStop(1, fill[1]);
          hudCtx.fillStyle = isUsed ? 'rgba(255,255,255,0.16)' : grad;
          hudCtx.strokeStyle = isLive ? 'rgba(77,225,255,0.8)' : 'rgba(255,255,255,0.35)';
          hudCtx.lineWidth = isLive ? 2 : 1;
          hudCtx.beginPath();
          hudCtx.arc(x, y, 6, 0, Math.PI * 2);
          hudCtx.fill();
          hudCtx.stroke();
          if (isUsed) {
            hudCtx.fillStyle = 'rgba(0,0,0,0.35)';
            hudCtx.beginPath();
            hudCtx.arc(x, y, 6, 0, Math.PI * 2);
            hudCtx.fill();
          }
        }
      });

      const statusText = hud.status.textContent || '';
      const isInstruction = /grip|press|controller|toggle|trigger/i.test(statusText);
      const status = gameState.waitingForNextEnd ? 'End complete - use UI to advance' :
        (isInstruction ? '' : statusText);
      hudCtx.textAlign = 'right';
      hudCtx.textBaseline = 'alphabetic';
      hudCtx.fillStyle = '#9fb4cc';
      hudCtx.font = '13px "Inter", "Segoe UI", sans-serif';
      hudCtx.fillText(status, w - pad, h - 14);
      hudCtx.strokeStyle = '#234';
      hudCtx.strokeRect(0.5, 0.5, w - 1, h - 1);
      if (hudTexture) hudTexture.needsUpdate = true;
    }

    function crowdPopulationForEnd() {
      const endsMax = Math.max(1, gameState.totalEnds - 1);
      const ratio = Math.min(1, Math.max(0, (gameState.currentEnd - 1) / endsMax));
      const base = 3 + Math.round(Math.random()); // start with 3-4 people
      const target = Math.round(THREE.MathUtils.lerp(base, 140, ratio));
      return Math.max(base, target);
    }

    function clearCrowd() {
      ['headMesh', 'torsoMesh'].forEach((k) => {
        if (crowdData[k]) {
          envGroup.remove(crowdData[k]);
          crowdData[k].geometry.dispose();
          if (Array.isArray(crowdData[k].material)) crowdData[k].material.forEach(m => m.dispose?.());
          else crowdData[k].material.dispose();
          crowdData[k] = null;
        }
      });
      if (crowdData.lights) {
        crowdData.lights.forEach(l => { envGroup.remove(l); l.dispose?.(); });
        crowdData.lights = [];
      }
      if (crowdData.targets) {
        crowdData.targets.forEach(t => envGroup.remove(t));
        crowdData.targets = [];
      }
      crowdData.jitter = [];
    }

    function buildCrowd(boardWide, boardLen, boardHeight) {
      clearCrowd();
      if (!boardWide || !boardLen || !boardHeight) {
        boardHeight = stoneDimsFor('player').height * 1.4;
        boardLen = params.sheetLength + 0.8;
        boardWide = params.sheetWidth + 0.8;
      }
      const count = crowdPopulationForEnd();
      const headRadius = 0.2;
      const torsoHeight = 0.45;
      const torsoGeo = new THREE.BoxGeometry(0.32, torsoHeight, 0.18);
      const torsoMat = new THREE.MeshPhongMaterial({
        color: '#8fa9c8',
        emissive: '#0f1a27',
        emissiveIntensity: 0.15,
        flatShading: true
      });
      const torsoMesh = new THREE.InstancedMesh(torsoGeo, torsoMat, count);
      torsoMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

      const headGeo = new THREE.SphereGeometry(headRadius, 14, 10);
      const headMat = new THREE.MeshPhongMaterial({
        color: '#d6c3b0',
        emissive: '#101820',
        emissiveIntensity: 0.25,
        flatShading: true
      });
      const headMesh = new THREE.InstancedMesh(headGeo, headMat, count);
      headMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

      const baseZ = housePositionZ - boardLen * 0.25 - 4.5;
      const depthSpread = 5;
      const heightSpread = 2.2;
      crowdData.jitter = [];
      const skinPalette = ['#f7d7c4', '#e7c2a0', '#d1a074', '#b67c50', '#8b5a33', '#6d4426'];
      const jacketPalette = ['#1f7fff', '#f25f5c', '#ffe066', '#247ba0', '#70c1b3', '#9b8bf4', '#f78fb3'];
      const perRow = 60;
      const widthSpread = boardWide * 2.8;
      const rows = Math.max(1, Math.ceil(count / perRow));
      const depthStep = depthSpread / rows;
      for (let i = 0; i < count; i++) {
        const row = Math.floor(i / perRow);
        const col = i % perRow;
        const colNorm = perRow > 1 ? col / (perRow - 1) : 0.5;
        const x = (colNorm - 0.5) * widthSpread + THREE.MathUtils.randFloatSpread(boardWide * 0.15);
        const z = baseZ - row * (depthStep * 0.8 + 0.3) - Math.random() * depthStep + THREE.MathUtils.randFloatSpread(0.4);
        const baseY = boardHeight * 1.0 + Math.random() * heightSpread;
        const mTorso = new THREE.Matrix4();
        mTorso.makeRotationY((Math.random() - 0.5) * 0.25);
        mTorso.setPosition(x, baseY, z);
        torsoMesh.setMatrixAt(i, mTorso);

        const mHead = new THREE.Matrix4();
        const headY = baseY + torsoHeight * 0.5 + headRadius * 0.95;
        mHead.makeRotationY((Math.random() - 0.5) * 0.3);
        mHead.setPosition(x, headY, z);
        headMesh.setMatrixAt(i, mHead);

        crowdData.jitter.push({
          base: new THREE.Vector3(x, headY, z),
          baseTorso: new THREE.Vector3(x, baseY, z),
          phase: Math.random() * Math.PI * 2,
          freq: THREE.MathUtils.lerp(0.5, 1.4, Math.random()),
          amp: THREE.MathUtils.lerp(0.02, 0.05, Math.random())
        });

        const jacket = new THREE.Color(jacketPalette[Math.floor(Math.random() * jacketPalette.length)]);
        jacket.offsetHSL((Math.random() - 0.5) * 0.05, (Math.random() - 0.5) * 0.08, (Math.random() - 0.5) * 0.08);
        torsoMesh.setColorAt(i, jacket);
        const skin = new THREE.Color(skinPalette[Math.floor(Math.random() * skinPalette.length)]);
        headMesh.setColorAt(i, skin);
      }
      headMesh.castShadow = false;
      headMesh.receiveShadow = false;
      torsoMesh.castShadow = false;
      torsoMesh.receiveShadow = false;
      envGroup.add(torsoMesh);
      envGroup.add(headMesh);
      crowdData.headMesh = headMesh;
      crowdData.torsoMesh = torsoMesh;
      crowdData.material = headMat;
      crowdData.torsoMaterial = torsoMat;
      crowdData.cheer = 0;

      const addLight = (xOffset) => {
        const light = new THREE.SpotLight(0x9fcfff, 0.8, 40, Math.PI / 5, 0.4, 1.5);
        light.position.set(xOffset, boardHeight * 2.2, housePositionZ - (params.sheetLength * 0.25) - 4);
        light.target.position.set(xOffset, boardHeight, housePositionZ - (params.sheetLength * 0.25) - 4.5);
        envGroup.add(light);
        envGroup.add(light.target);
        crowdData.lights.push(light);
        crowdData.targets.push(light.target);
      };
      addLight(-5);
      addLight(5);
    }

    function triggerCrowdCheer(strength = 1) {
      crowdData.cheer = Math.min(1.5, crowdData.cheer + strength);
    }


    function setupPointerLines() {
      [controller1, controller2].forEach((c, i) => {
        if (pointerLines[i]) panelGroup.remove(pointerLines[i]);
        const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -2)]);
        const mat = new THREE.LineBasicMaterial({ color: 0x4de1ff });
        const line = new THREE.Line(geo, mat);
        line.visible = false;
        c.add(line);
        pointerLines[i] = line;
      });
    }

    function updatePointers() {
      const session = renderer.xr.getSession();
      const promptActive = !!vrPrompt.group;
      [controller1, controller2].forEach((c, i) => {
        if (!c) return;
        pointerLines[i].visible = promptActive;
        if (!promptActive) return;
        const rc = raycasters[i];
        tempMatrix.identity().extractRotation(c.matrixWorld);
        rc.ray.origin.setFromMatrixPosition(c.matrixWorld);
        rc.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
        pointerLines[i].geometry.attributes.position.setXYZ(1, 0, 0, -2);
        pointerLines[i].geometry.attributes.position.needsUpdate = true;
      });
    }

    const tempMatrix = new THREE.Matrix4();

    function tryPromptClick(controller) {
      if (!vrPrompt.group) return;
      const index = controller === controller1 ? 0 : 1;
      const rc = raycasters[index];
      if (!rc) return;
      const hits = rc.intersectObjects(vrPrompt.buttons, false);
      if (hits.length) {
        const target = hits[0].object.userData.action;
        if (target === 'next') handleNextEnd();
        if (target === 'play') resetGame();
        if (target === 'quit') handleQuit();
      }
    }

    function updateCrowd(dt) {
      if (!crowdData.material) return;
      timeElapsed += dt;
      if (crowdData.cheer > 0) {
        crowdData.cheer = Math.max(0, crowdData.cheer - dt * 0.6);
      }
      const lively = 0.05 * Math.sin(timeElapsed * 2);
      const emissiveBase = 0.25 + crowdData.cheer * 0.8 + lively;
      if (crowdData.material) crowdData.material.emissiveIntensity = emissiveBase;
      if (crowdData.torsoMaterial) crowdData.torsoMaterial.emissiveIntensity = 0.1 + crowdData.cheer * 0.5;
      if (crowdData.headMesh && crowdData.jitter) {
        const m = new THREE.Matrix4();
        const mTorso = new THREE.Matrix4();
        const q = new THREE.Quaternion();
        const tmp = new THREE.Vector3();
        crowdData.jitter.forEach((j, idx) => {
          const sway = Math.sin(timeElapsed * j.freq + j.phase) * j.amp * (0.6 + crowdData.cheer);
          const nod = Math.sin(timeElapsed * j.freq * 0.65 + j.phase * 1.3) * j.amp * 0.6;
          tmp.set(j.base.x + nod * 0.25, j.base.y + sway, j.base.z + nod * 0.12);
          q.setFromEuler(new THREE.Euler(0, nod * 0.8, 0));
          m.makeRotationFromQuaternion(q);
          m.setPosition(tmp);
          crowdData.headMesh.setMatrixAt(idx, m);
          const torsoPos = j.baseTorso.clone();
          torsoPos.y += sway * 0.6;
          mTorso.makeRotationFromQuaternion(q);
          mTorso.setPosition(torsoPos);
          crowdData.torsoMesh.setMatrixAt(idx, mTorso);
        });
        crowdData.headMesh.instanceMatrix.needsUpdate = true;
        crowdData.torsoMesh.instanceMatrix.needsUpdate = true;
      }
    }

    function showVRPrompt(pScore, aScore) {
      if (vrPrompt.group) {
        panelGroup.remove(vrPrompt.group);
        vrPrompt.group = null;
        vrPrompt.buttons = [];
      }
      const group = new THREE.Group();
      const camPos = new THREE.Vector3();
      camera.getWorldPosition(camPos);
      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);
      forward.y = 0;
      forward.normalize();
      const promptPos = camPos.clone().add(forward.multiplyScalar(1.5));
      group.position.copy(promptPos);
      group.lookAt(camPos.x, camPos.y, camPos.z);
      const bg = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 0.7), new THREE.MeshBasicMaterial({ color: '#0c1827', opacity: 0.9, transparent: true }));
      bg.position.set(0, 0, -0.1);
      group.add(bg);
      const title = new THREE.Mesh(new THREE.PlaneGeometry(1.1, 0.2), new THREE.MeshBasicMaterial({ color: '#1f7fff' }));
      title.position.set(0, 0.2, 0);
      group.add(title);
      const label = makeLabelMesh(gameState.currentEnd >= gameState.totalEnds ? 'Game Complete' : `End ${gameState.currentEnd} Complete`, 0.5);
      label.position.set(0, 0.2, 0.01);
      group.add(label);
      const desc = makeLabelMesh(`End: ${teamNames.player} ${pScore} / ${teamNames.ai} ${aScore} | Total: ${gameState.scores.player}-${gameState.scores.ai}`, 0.22);
      desc.position.set(0, -0.05, 0.01);
      group.add(desc);

      const btnData = gameState.currentEnd >= gameState.totalEnds ?
        [
          { text: 'Play Again', action: 'play' },
          { text: 'Quit', action: 'quit' }
        ] :
        [{ text: 'Next End', action: 'next' }];
      const btnY = -0.28;
      btnData.forEach((btn, idx) => {
        const bw = 0.35, bh = 0.12;
        const mesh = new THREE.Mesh(new THREE.PlaneGeometry(bw, bh), new THREE.MeshBasicMaterial({ color: '#13334c' }));
        mesh.position.set((idx - (btnData.length - 1) / 2) * (bw + 0.08), btnY, 0.02);
        mesh.userData.action = btn.action;
        const txt = makeLabelMesh(btn.text, 0.13);
        txt.position.set(0, 0, 0.005);
        mesh.add(txt);
        group.add(mesh);
      });
      vrPrompt.group = group;
      vrPrompt.buttons = group.children.filter(c => c.userData && c.userData.action);
      panelGroup.add(group);
    }

    function hideVRPrompt() {
      if (vrPrompt.group) {
        panelGroup.remove(vrPrompt.group);
        vrPrompt.group = null;
        vrPrompt.buttons = [];
      }
    }

    function makeLabelMesh(text, size = 0.2) {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 128;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'rgba(0,0,0,0)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#e9f2ff';
      ctx.font = '48px Segoe UI';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, canvas.width / 2, canvas.height / 2);
      const tex = new THREE.CanvasTexture(canvas);
      const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
      const aspect = canvas.width / canvas.height;
      const mesh = new THREE.Mesh(new THREE.PlaneGeometry(size * aspect, size), mat);
      return mesh;
    }

    function updateControllerState(controller, dt) {
      if (!controller) return;
      const pos = new THREE.Vector3();
      controller.getWorldPosition(pos);
      const quat = new THREE.Quaternion();
      controller.getWorldQuaternion(quat);
      const prev = controllerState.get(controller);
      let vel = new THREE.Vector3();
      let angVel = new THREE.Vector3();
      if (prev) {
        vel = pos.clone().sub(prev.pos).divideScalar(Math.max(dt, 0.0001));
        const dq = prev.quat.clone().invert().multiply(quat);
        const axis = new THREE.Vector3(dq.x, dq.y, dq.z);
        const angle = 2 * Math.acos(THREE.MathUtils.clamp(dq.w, -1, 1));
        const sinHalf = Math.sqrt(1 - dq.w * dq.w);
        if (sinHalf > 0.0001) axis.multiplyScalar(1 / sinHalf);
        const omega = angle / Math.max(dt, 0.0001);
        angVel.copy(axis.multiplyScalar(omega));
      }
      controllerState.set(controller, { pos, vel, quat, angVel });
    }

    function updateGrabbedStone() {
      if (!grabState.stone || !grabState.controller) return;
      const pos = new THREE.Vector3();
      grabState.controller.getWorldPosition(pos);
      grabState.stone.body.position.set(pos.x, Math.max(pos.y, params.stoneHeight / 2), pos.z);
      grabState.stone.mesh.position.copy(grabState.stone.body.position);
      grabState.stone.body.velocity.set(0, 0, 0);
      grabState.stone.body.angularVelocity.set(0, 0, 0);
    }

    function applyCurlDrag(delta) {
      const applyList = (list) => {
        list.forEach((s) => {
          if (!s.thrown) return;
          s.body.velocity.scale(Math.max(0, 1 - params.iceDrag * delta), s.body.velocity);
          updateSlideSound(s.body, s.thrown);
        });
      };
      applyList(stones);
    }

    function applyExtraSpinDamping(delta) {
      const extra = extraSpinDrag(params.spinDrag);
      if (extra <= 0) return;
      const factor = Math.max(0, 1 - extra * delta);
      stones.forEach((s) => {
        if (!s.thrown || s.body.sleepState === CANNON.Body.SLEEPING) return;
        s.body.angularVelocity.scale(factor, s.body.angularVelocity);
      });
    }

    function animate() {
      renderer.setAnimationLoop(render);
    }

    const clock = new THREE.Clock();
    let timeElapsed = 0;
    function render() {
      const dt = Math.min(clock.getDelta(), 0.05);
      timeElapsed += dt;
      updateControllerState(controller1, dt);
      updateControllerState(controller2, dt);
      updateGrabbedStone();
      world.step(1 / 60, dt);
      keepStonesUpright(stones);
      applyCurlDrag(dt);
      applySpinCurve(stones);
      applyExtraSpinDamping(dt);
      updateStoneMeshes();
      updateMiniMap();
      updateAimIndicator();
      monitorStoneState();
      pollButtons();
      updateCrowd(dt);
      updatePointers();
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
